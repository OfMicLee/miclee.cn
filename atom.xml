<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MicLee&#39;s Bolg</title>
  
  <subtitle>道生一 一生二 二生三 三生万物</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://miclee.site/"/>
  <updated>2017-05-20T08:56:44.000Z</updated>
  <id>http://miclee.site/</id>
  
  <author>
    <name>射雕</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python 应用部署</title>
    <link href="http://miclee.site/2017/05/18/python-deploy/"/>
    <id>http://miclee.site/2017/05/18/python-deploy/</id>
    <published>2017-05-18T06:49:09.000Z</published>
    <updated>2017-05-20T08:56:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> flask 自带的服务器，能够完成了 web 服务的启动，但在生产环境下，无法满足性能要求。我们这里采用 gunicorn 做 wsgi容器，用来部署 python。 </em></strong><br><a id="more"></a></p><hr><p>web的部署，一般都是 nginx 做前端代理，中间 webservice 调用程序脚本。大概方式：nginx + webservice + script</p><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p>nginx，高性能的web服务器，通常用来在前端做反向代理服务器。<br>一个请求经过代理服务器从局域网发出，然后到达互联网上服务器，这个过程的代理为 <strong>正向代理</strong>。<br>如果一个请求，从互联网过来，先进入代理服务器，再由代理服务器转发给局域网的目标服务器，这个时候，代理服务器为 <strong>反向代理</strong>（相对正向而言）。</p><h2 id="webservice"><a href="#webservice" class="headerlink" title="webservice"></a>webservice</h2><p>webservice 也有很多方式。常见的有FastCGI，WSGI等。我们采用gunicorn为 wsgi容器，python为服务器script，采用flask框架。<br>最终的部署方式为：<br>nginx + gunicorn + flask</p><h2 id="gunicorn-使用"><a href="#gunicorn-使用" class="headerlink" title="gunicorn 使用"></a>gunicorn 使用</h2><ul><li><strong>安装</strong>  </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install gunicorn</span><br></pre></td></tr></table></figure><ul><li><strong>运行</strong>  </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunicorn -w4 -b0.0.0.0:8080 run:app</span><br></pre></td></tr></table></figure><p>-w 表示开启多少个 worker，-b 表示 gunicorn 开发的访问地址</p><p>为了在后台运行这个服务器（也即使它变成守护进程），可以传递-D选项给Gunicorn。这下它会持续运行，即使你关闭了当前的终端会话。</p><p>如果这么做了，当想要关闭服务器时就会困惑于到底应该关闭哪个进程。我们可以让Gunicorn把进程ID储存到文件中，这样如果想要停止或者重启服务器时，我们可以不用在一大串运行中的进程中搜索它。我们使用-p <file>选项来这么做。现在，我们的Gunicorn部署命令是这样：</file></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunicorn -w4 -b0.0.0.0:8080 run:app -p run.pid -D</span><br></pre></td></tr></table></figure><ul><li><strong>重启</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -HUP `cat run.pid` # 发送一个SIGHUP信号，终止进程</span><br></pre></td></tr></table></figure><ul><li><strong>关闭</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill `cat run.pid`</span><br></pre></td></tr></table></figure><ul><li><strong>访问地址的设置</strong><br>Gunicorn应该隐藏于反向代理之后。如果你直接让它监听来自外网的请求，它很容易成为拒绝服务攻击的目标。<br>只有在debug的情况下你才能把Gunicorn摆上前台，而且完工之后，切记把它重新隐藏到幕后。</li></ul><p>Gunicorn绑定在 127.0.0.1 上时，它仅仅监听来自服务器自身的连接。所以通常使用一个反向代理来作为外网和Gunicorn服务器的中介。<br>Gunicorn绑定在 0.0.0.0 上时，它就会监听所有请求，这样可以直接从外网发送请求给Gunicorn。debug的时候可以这么做。</p><h2 id="nginx的配置"><a href="#nginx的配置" class="headerlink" title="nginx的配置"></a>nginx的配置</h2><p>交给运维去管吧</p>]]></content>
    
    <summary type="html">
    
      flask 自带的服务器，能够完成了 web 服务的启动，但在生产环境下，无法满足性能要求。我们这里采用 gunicorn 做 wsgi容器，用来部署 python。
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>解决 ImportError cannot import name &#39;db&#39;</title>
    <link href="http://miclee.site/2017/05/17/ImportError/"/>
    <id>http://miclee.site/2017/05/17/ImportError/</id>
    <published>2017-05-17T03:19:14.000Z</published>
    <updated>2017-05-17T03:41:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 在使用 flask_sqlalchemy 的时候启动项目总是报错ImportError cannot import name 'db'，解决方案如此。 </em></strong><br><a id="more"></a></p><hr><h2 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "/Users/MicLee/WorkSpace/risk-model/pandora/pandora/__main__.py", line 28, in &lt;module&gt;</span><br><span class="line">    from pandora import get_app</span><br><span class="line">  File "/Users/MicLee/WorkSpace/risk-model/pandora/pandora/__init__.py", line 16, in &lt;module&gt;</span><br><span class="line">    import pandora.web.views</span><br><span class="line">  File "/Users/MicLee/WorkSpace/risk-model/pandora/pandora/web/views.py", line 8, in &lt;module&gt;</span><br><span class="line">    from pandora.dao import theta as ta</span><br><span class="line">  File "/Users/MicLee/WorkSpace/risk-model/pandora/pandora/dao/theta.py", line 8, in &lt;module&gt;</span><br><span class="line">    from pandora import db</span><br><span class="line">ImportError: cannot import name 'db'</span><br></pre></td></tr></table></figure><h2 id="错误相关项目结构"><a href="#错误相关项目结构" class="headerlink" title="错误相关项目结构"></a>错误相关项目结构</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pandora</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── __main__.py</span><br><span class="line">│   └── web</span><br><span class="line">│       ├── __init__.py</span><br><span class="line">│       └── views.py</span><br></pre></td></tr></table></figure><h2 id="错误相关代码"><a href="#错误相关代码" class="headerlink" title="错误相关代码"></a>错误相关代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">#</span><br><span class="line"># @Author  : MicLee</span><br><span class="line"># @Date    : 2017/4/5 17:55</span><br><span class="line"># @File    : __init__.py</span><br><span class="line"></span><br><span class="line">from flask import Flask</span><br><span class="line">from flask_sqlalchemy import SQLAlchemy</span><br><span class="line">from flask_cors import CORS, cross_origin</span><br><span class="line">from pandora import config</span><br><span class="line">import pandora.web.views</span><br><span class="line"></span><br><span class="line">__version__ = &quot;0.1&quot;</span><br><span class="line">__description__ = &quot;NFQ Risk Model.&quot;</span><br><span class="line"></span><br><span class="line">db = SQLAlchemy()</span><br><span class="line">_app = None</span><br><span class="line"></span><br><span class="line">def _create_app():</span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    app.config.from_object(config)</span><br><span class="line"></span><br><span class="line">    CORS(app)</span><br><span class="line">    db.init_app(app)</span><br><span class="line">    return app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_app():</span><br><span class="line">    global _app</span><br><span class="line">    if _app is None:</span><br><span class="line">        _app = _create_app()</span><br><span class="line">    return _app</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">#</span><br><span class="line"># @Author  : MicLee</span><br><span class="line"># @Date    : 2017/5/16 15:28</span><br><span class="line"># @File    : views.py</span><br><span class="line"></span><br><span class="line">from pandora import db</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>1、开始以为是import的路径错误，仔细研究了下python的import机制，并木有发现问题。<br>2、考虑到Python顺序执行的特点，在执行 “import pandora.web.views” 时加载views.py，执行“from pandora import db”，而“db = SQLAlchemy()”语句还没执行，db对象还没有被创建，所以发生ImportError!</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>将 “import pandora.web.views” 放到 <strong>init.py</strong> 的最后。</p>]]></content>
    
    <summary type="html">
    
      在使用 flask_sqlalchemy 的时候启动项目总是报错ImportError cannot import name &#39;db&#39;，解决方案如此。
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python字符串格式符</title>
    <link href="http://miclee.site/2017/05/16/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E7%AC%A6/"/>
    <id>http://miclee.site/2017/05/16/python字符串格式符/</id>
    <published>2017-05-16T06:28:00.000Z</published>
    <updated>2017-05-16T07:01:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 格式化字符串时，Python使用一个字符串作为模板。模板中有格式符，这些格式符为真实值预留位置，并说明真实数值应该呈现的格式。Python用一个 tuple 或者 字典 将多个值传递给模板，每个值对应一个格式符。 </em></strong><br><a id="more"></a></p><hr><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;I&apos;m %s. I&apos;m %d year old&quot; % (&apos;MicLee&apos;, 30))</span><br><span class="line"></span><br><span class="line">print(&quot;I&apos;m %(name)s. I&apos;m %(age)d year old&quot; % &#123;&apos;name&apos;:&apos;MicLee&apos;, &apos;age&apos;:30&#125;)</span><br></pre></td></tr></table></figure><h2 id="格式符"><a href="#格式符" class="headerlink" title="格式符"></a>格式符</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">%</span><span class="bash">s    字符串 (采用str()的显示)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">r    字符串 (采用repr()的显示)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">c    单个字符</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">b    二进制整数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">d    十进制整数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">i    十进制整数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">o    八进制整数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">x    十六进制整数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">e    指数 (基底写为e)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">E    指数 (基底写为E)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">f    浮点数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">F    浮点数，与上相同</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">g    指数(e)或浮点数 (根据显示长度)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">G    指数(E)或浮点数 (根据显示长度)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">%    字符<span class="string">"%"</span></span></span><br></pre></td></tr></table></figure><h2 id="高级格式符"><a href="#高级格式符" class="headerlink" title="高级格式符"></a>高级格式符</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[<span class="string">(name)</span>][<span class="symbol">flags</span>][<span class="string">width</span>].[precision]typecode</span><br></pre></td></tr></table></figure><p>(name)为命名</p><p>flags可以有+,-,’ ‘或0。+表示右对齐。-表示左对齐。’ ‘为一个空格，表示在正数的左侧填充一个空格，从而与负数对齐。0表示使用0填充。</p><p>width表示显示宽度</p><p>precision表示小数点后精度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&quot;%+10x&quot; % 10)</span><br><span class="line">        +a</span><br><span class="line">&gt;&gt;&gt; print(&quot;%04d&quot; % 5)</span><br><span class="line">0005</span><br><span class="line">&gt;&gt;&gt; print(&quot;%6.3f&quot; % 2.3)</span><br><span class="line"> 2.300</span><br></pre></td></tr></table></figure><p>上面的width, precision为两个整数。我们可以利用*，来动态代入这两个量。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&quot;%.*f&quot; % (4, 1.2))</span><br><span class="line">1.2000</span><br></pre></td></tr></table></figure><p>Python实际上用4来替换*，所以实际的模板为”%.4f”。</p><h2 id="r和-s的区别"><a href="#r和-s的区别" class="headerlink" title="%r和%s的区别"></a>%r和%s的区别</h2><p>%r用rper()方法处理对象<br>%s用str()方法处理对象</p><p>有些情况下，两者处理的结果是一样的，比如int型对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&quot;I&apos;m %s year old&quot; % 30)</span><br><span class="line">I&apos;m 30 year old</span><br><span class="line">&gt;&gt;&gt; print(&quot;I&apos;m %r year old&quot; % 30)</span><br><span class="line">I&apos;m 30 year old</span><br></pre></td></tr></table></figure></p><p>有些情况下是不一样的，比如str对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&quot;I&apos;m %s.&quot; % &apos;MicLee&apos;)</span><br><span class="line">I&apos;m MicLee.</span><br><span class="line">&gt;&gt;&gt; print(&quot;I&apos;m %r.&quot; % &apos;MicLee&apos;)</span><br><span class="line">I&apos;m &apos;MicLee&apos;.</span><br></pre></td></tr></table></figure></p><p>还有一种情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import datetime</span><br><span class="line">&gt;&gt;&gt; d = datetime.date.today()</span><br><span class="line">&gt;&gt;&gt; str(d)</span><br><span class="line">&apos;2011-05-14&apos;</span><br><span class="line">&gt;&gt;&gt; repr(d)</span><br><span class="line">&apos;datetime.date(2011, 5, 14)&apos;</span><br></pre></td></tr></table></figure></p><p>%r(也就是repr()方法)打印时能够重现它所代表的对象</p>]]></content>
    
    <summary type="html">
    
      格式化字符串时，Python使用一个字符串作为模板。模板中有格式符，这些格式符为真实值预留位置，并说明真实数值应该呈现的格式。Python用一个 tuple 或者 字典 将多个值传递给模板，每个值对应一个格式符。
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>SQLAlchemy</title>
    <link href="http://miclee.site/2017/05/16/SQLAlchemy/"/>
    <id>http://miclee.site/2017/05/16/SQLAlchemy/</id>
    <published>2017-05-16T06:10:26.000Z</published>
    <updated>2017-05-16T08:23:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 在上一章对比了Python几款ORM框架，决定在我的项目里使用SQLAlchemy，这里简单介绍下SQLAlchemy的使用。 </em></strong><br><a id="more"></a></p><hr><h2 id="一、单独使用SQLAlchemy"><a href="#一、单独使用SQLAlchemy" class="headerlink" title="一、单独使用SQLAlchemy"></a>一、单独使用SQLAlchemy</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1) 安装"></a>1) 安装</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">workon py3</span><br><span class="line">pip <span class="keyword">install</span> sqlalchemy</span><br></pre></td></tr></table></figure><h3 id="2-初始化DBSession"><a href="#2-初始化DBSession" class="headerlink" title="2) 初始化DBSession"></a>2) 初始化DBSession</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from sqlalchemy import Column, String, create_engine  </span><br><span class="line">from sqlalchemy.orm import sessionmaker  </span><br><span class="line">from sqlalchemy.ext.declarative import declarative_base  </span><br><span class="line"></span><br><span class="line"># 创建对象的基类:  </span><br><span class="line">Base = declarative_base()  </span><br><span class="line"></span><br><span class="line"># 定义User对象:  </span><br><span class="line">class User(Base):  </span><br><span class="line">    # 表的名字:  </span><br><span class="line">    __tablename__ = &apos;user&apos;  </span><br><span class="line"></span><br><span class="line">    # 表的结构:  </span><br><span class="line">    id = Column(String(20), primary_key=True)  </span><br><span class="line">    name = Column(String(20))  </span><br><span class="line"></span><br><span class="line"># 初始化数据库连接:  </span><br><span class="line"># &apos;数据库类型+数据库驱动名称://用户名:口令@机器地址:端口号/数据库名&apos;  </span><br><span class="line">engine = create_engine(&apos;mysql+mysqlconnector://root:root@localhost:3306/test&apos;)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 创建DBSession类型:  </span><br><span class="line">DBSession = sessionmaker(bind=engine)</span><br></pre></td></tr></table></figure><h3 id="3-添加一行记录"><a href="#3-添加一行记录" class="headerlink" title="3) 添加一行记录"></a>3) 添加一行记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 创建session对象:  </span><br><span class="line">session = DBSession()  </span><br><span class="line"># 创建新User对象:  </span><br><span class="line">new_user = User(id=&apos;5&apos;, name=&apos;Bob&apos;)  </span><br><span class="line"># 添加到session:  </span><br><span class="line">session.add(new_user)  </span><br><span class="line"># 提交即保存到数据库:  </span><br><span class="line">session.commit()  </span><br><span class="line"># 关闭session:  </span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure><h3 id="4-查询数据"><a href="#4-查询数据" class="headerlink" title="4) 查询数据"></a>4) 查询数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 创建Session:  </span><br><span class="line">session = DBSession()  </span><br><span class="line"># 创建Query查询，filter是where条件，最后调用one()返回唯一行，如果调用all()则返回所有行:  </span><br><span class="line">user = session.query(User).filter(User.id==&apos;5&apos;).one()  </span><br><span class="line"># 打印类型和对象的name属性:  </span><br><span class="line">print &apos;type:&apos;, type(user)  </span><br><span class="line">print &apos;name:&apos;, user.name  </span><br><span class="line"># 关闭Session:  </span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure><h3 id="5-创建一个一对多的关系"><a href="#5-创建一个一对多的关系" class="headerlink" title="5) 创建一个一对多的关系"></a>5) 创建一个一对多的关系</h3><p>一个人有多本书：当我们查询一个User对象时，该对象的books属性将返回一个包含若干个Book对象的list。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class User(Base):  </span><br><span class="line">    __tablename__ = &apos;user&apos;  </span><br><span class="line"></span><br><span class="line">    id = Column(String(20), primary_key=True)  </span><br><span class="line">    name = Column(String(20))  </span><br><span class="line">    # 一对多:  </span><br><span class="line">    books = relationship(&apos;Book&apos;)  </span><br><span class="line"></span><br><span class="line">class Book(Base):  </span><br><span class="line">    __tablename__ = &apos;book&apos;  </span><br><span class="line"></span><br><span class="line">    id = Column(String(20), primary_key=True)  </span><br><span class="line">    name = Column(String(20))  </span><br><span class="line">    # “多”的一方的book表是通过外键关联到user表的:  </span><br><span class="line">    user_id = Column(String(20), ForeignKey(&apos;user.id&apos;))</span><br></pre></td></tr></table></figure><h2 id="二、Flask-SQLAlchemy"><a href="#二、Flask-SQLAlchemy" class="headerlink" title="二、Flask-SQLAlchemy"></a>二、Flask-SQLAlchemy</h2><p>常见情况下对于只有一个 Flask 应用，所有您需要做的事情就是创建 Flask 应用，选择加载配置接着创建 SQLAlchemy 对象时候把 Flask 应用传递给它作为参数。</p><p>一旦创建，这个对象就包含 sqlalchemy 和 sqlalchemy.orm 中的所有函数和助手。此外它还提供一个名为 Model 的类，用于作为声明模型时的 delarative 基类:</p><h3 id="1）安装"><a href="#1）安装" class="headerlink" title="1）安装"></a>1）安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">workon py3</span><br><span class="line">pip install Flask-SQLAlchemy</span><br></pre></td></tr></table></figure><p>会附带安装 SQLAlchemy</p><h3 id="2）初始化"><a href="#2）初始化" class="headerlink" title="2）初始化"></a>2）初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># myapp.py</span><br><span class="line">from flask import Flask</span><br><span class="line">from flask.ext.sqlalchemy import SQLAlchemy</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[&apos;SQLALCHEMY_DATABASE_URI&apos;] = &apos;mysql://username:password@server/db&apos;</span><br><span class="line">db = SQLAlchemy(app)</span><br><span class="line"></span><br><span class="line"># 有一些部分在 SQLAlchemy 上是必选的，但是在 Flask-SQLAlchemy 上是可选的。 比如表名是自动地为您设置好的，除非您想要覆盖它。它是从转成小写的类名派生出来的，即 “CamelCase” 转换为 “camel_case”。</span><br><span class="line">class User(db.Model):</span><br><span class="line">    id = db.Column(db.Integer, primary_key=True)</span><br><span class="line">    username = db.Column(db.String(80), unique=True)</span><br><span class="line">    email = db.Column(db.String(120), unique=True)</span><br><span class="line"></span><br><span class="line">    def __init__(self, username, email):</span><br><span class="line">        self.username = username</span><br><span class="line">        self.email = email</span><br><span class="line"></span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &apos;&lt;User %r&gt;&apos; % self.username</span><br></pre></td></tr></table></figure><p><strong>常用类型：</strong></p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>Integer</td><td>一个整数</td></tr><tr><td>String(size)</td><td>有长度限制的字符串</td></tr><tr><td>Text</td><td>一些较长的 unicode 文本</td></tr><tr><td>DateTime</td><td>表示为 Python datetime 对象的 时间和日期</td></tr><tr><td>Float</td><td>存储浮点值</td></tr><tr><td>Boolean</td><td>存储布尔值</td></tr><tr><td>PickleType</td><td>存储为一个持久化的 Python 对象</td></tr><tr><td>LargeBinary</td><td>存储一个任意大的二进制数据</td></tr></tbody></table><h3 id="3）添加一行记录"><a href="#3）添加一行记录" class="headerlink" title="3）添加一行记录"></a>3）添加一行记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from myapp import User</span><br><span class="line"></span><br><span class="line">admin = User(&apos;admin&apos;, &apos;admin@example.com&apos;)</span><br><span class="line">guest = User(&apos;guest&apos;, &apos;guest@example.com&apos;)</span><br><span class="line"></span><br><span class="line">db.session.add(admin)</span><br><span class="line">db.session.add(guest)</span><br><span class="line">db.session.commit()</span><br><span class="line"># 没有必要在每个请求后关闭它(session)，Flask-SQLAlchemy 会帮您完成关闭操作。</span><br></pre></td></tr></table></figure><h3 id="4）查询记录"><a href="#4）查询记录" class="headerlink" title="4）查询记录"></a>4）查询记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from myapp import User</span><br><span class="line"></span><br><span class="line">users = User.query.all()</span><br><span class="line">print(users)</span><br><span class="line"># [&lt;User u&apos;admin&apos;&gt;, &lt;User u&apos;guest&apos;&gt;]</span><br><span class="line"></span><br><span class="line">admin = User.query.filter_by(username=&apos;admin&apos;).first()</span><br><span class="line">print(admin)</span><br><span class="line"># &lt;User u&apos;admin&apos;&gt;</span><br></pre></td></tr></table></figure><p><strong>更多用法参考：</strong> <a href="http://www.pythondoc.com/flask-sqlalchemy/quickstart.html#id2" target="_blank" rel="noopener">Flask-SQLAlchemy 快速入门</a></p>]]></content>
    
    <summary type="html">
    
      在上一章对比了Python几款ORM框架，决定在我的项目里使用SQLAlchemy，这里简单介绍下SQLAlchemy的使用。
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python ORM 框架对比</title>
    <link href="http://miclee.site/2017/05/16/python-orm/"/>
    <id>http://miclee.site/2017/05/16/python-orm/</id>
    <published>2017-05-16T05:52:19.000Z</published>
    <updated>2017-05-17T03:42:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> ORM技术 - Object-Relational Mapping, 把关系数据库的表结构映射到对象上。本篇对比Python几个流行的可选 ORM 库。 </em></strong><br><a id="more"></a></p><hr><h2 id="SQLObject"><a href="#SQLObject" class="headerlink" title="SQLObject"></a>SQLObject</h2><p><strong>优点：</strong>  </p><ul><li>采用了易懂的ActiveRecord 模式；  </li><li>一个相对较小的代码库；</li></ul><p><strong>缺点：</strong>  </p><ul><li>方法和类的命名遵循了Java 的小驼峰风格；  </li><li>不支持数据库session隔离工作单元；</li></ul><h2 id="Storm"><a href="#Storm" class="headerlink" title="Storm"></a>Storm</h2><p><strong>优点：</strong>  </p><ul><li>清爽轻量的API，短学习曲线和长期可维护性；  </li><li>不需要特殊的类构造函数，也没有必要的基类；</li></ul><p><strong>缺点：</strong>  </p><ul><li>迫使程序员手工写表格创建的DDL语句，而不是从模型类自动派生；  </li><li>Storm的贡献者必须把他们的贡献的版权给Canonical公司；  </li></ul><h2 id="Django’s-ORM"><a href="#Django’s-ORM" class="headerlink" title="Django’s ORM"></a>Django’s ORM</h2><p><strong>优点：</strong>  </p><ul><li>易用，学习曲线短；  </li><li>和Django紧密集合，用Django时使用约定俗成的方法去操作数据库；</li></ul><p><strong>缺点：</strong>  </p><ul><li>不好处理复杂的查询，强制开发者回到原生SQL;  </li><li>紧密和Django集成，使得在Django环境外很难使用;</li></ul><h2 id="peewee"><a href="#peewee" class="headerlink" title="peewee"></a>peewee</h2><p><strong>优点：</strong>  </p><ul><li>Django式的API，使其易用;  </li><li>轻量实现，很容易和任意web框架集成;</li></ul><p><strong>缺点：</strong>  </p><ul><li>不支持自动化 schema 迁移;  </li><li>多对多查询写起来不直观;</li></ul><h2 id="SQLAlchemy"><a href="#SQLAlchemy" class="headerlink" title="SQLAlchemy"></a>SQLAlchemy</h2><p><strong>优点：</strong>  </p><ul><li>企业级 API，使得代码有健壮性和适应性;  </li><li>灵活的设计，使得能轻松写复杂查询;</li></ul><p><strong>缺点：</strong>  </p><ul><li>工作单元概念不常;  </li><li>重量级 API，导致长学习曲线;</li></ul>]]></content>
    
    <summary type="html">
    
      ORM技术 - Object-Relational Mapping, 把关系数据库的表结构映射到对象上。本篇对比Python几个流行的可选 ORM 库。
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>RESTful API 设计指南【转】</title>
    <link href="http://miclee.site/2017/05/15/restful-api/"/>
    <id>http://miclee.site/2017/05/15/restful-api/</id>
    <published>2017-05-15T06:40:15.000Z</published>
    <updated>2017-05-15T06:55:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 网络应用程序，分为前端和后端两个部分。当前的发展趋势，就是前端设备层出不穷（手机、平板、桌面电脑、其他专用设备......）。因此，必须有一种统一的机制，方便不同的前端设备与后端进行通信。这导致API构架的流行，甚至出现"API First"的设计思想。RESTful API是目前比较成熟的一套互联网应用程序的API设计理论。 </em></strong><br><a id="more"></a></p><hr><p>我以前写过一篇《理解RESTful架构》，探讨如何理解这个概念。<br>今天，我将介绍RESTful API的设计细节，探讨如何设计一套合理、好用的API。我的主要参考了两篇文章（<a href="https://codeplanet.io/principles-good-restful-api-design/" target="_blank" rel="noopener">1</a>，<a href="https://bourgeois.me/rest/" target="_blank" rel="noopener">2</a>）。</p><h2 id="一、协议"><a href="#一、协议" class="headerlink" title="一、协议"></a>一、协议</h2><p>API与用户的通信协议，总是使用  <a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">HTTPs</a> 协议。  </p><h2 id="二、域名"><a href="#二、域名" class="headerlink" title="二、域名"></a>二、域名</h2><p>应该尽量将API部署在专用域名之下。<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span><span class="comment">//api.example.com</span></span><br></pre></td></tr></table></figure></p><p>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span>//example<span class="meta">.org</span>/api/</span><br></pre></td></tr></table></figure></p><h2 id="三、版本（Versioning）"><a href="#三、版本（Versioning）" class="headerlink" title="三、版本（Versioning）"></a>三、版本（Versioning）</h2><p>应该将API的版本号放入URL。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>api.example.com<span class="regexp">/v1/</span></span><br></pre></td></tr></table></figure><p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。</p><h2 id="四、路径（Endpoint）"><a href="#四、路径（Endpoint）" class="headerlink" title="四、路径（Endpoint）"></a>四、路径（Endpoint）</h2><p>路径又称”终点”（endpoint），表示API的具体网址。<br>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。<br>举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>api.example.com<span class="regexp">/v1/</span>zoos</span><br><span class="line">https:<span class="regexp">//</span>api.example.com<span class="regexp">/v1/</span>animals</span><br><span class="line">https:<span class="regexp">//</span>api.example.com<span class="regexp">/v1/</span>employees</span><br></pre></td></tr></table></figure><h2 id="五、HTTP动词"><a href="#五、HTTP动词" class="headerlink" title="五、HTTP动词"></a>五、HTTP动词</h2><p>对于资源的具体操作类型，由HTTP动词表示。<br>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET（<span class="keyword">SELECT</span>）：从服务器取出资源（一项或多项）。</span><br><span class="line">POST（<span class="keyword">CREATE</span>）：在服务器新建一个资源。</span><br><span class="line">PUT（<span class="keyword">UPDATE</span>）：在服务器更新资源（客户端提供改变后的完整资源）。</span><br><span class="line"><span class="keyword">PATCH</span>（<span class="keyword">UPDATE</span>）：在服务器更新资源（客户端提供改变的属性）。</span><br><span class="line"><span class="keyword">DELETE</span>（<span class="keyword">DELETE</span>）：从服务器删除资源。</span><br></pre></td></tr></table></figure><p>还有两个不常用的HTTP动词。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HEAD：获取资源的元数据。</span><br><span class="line">OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</span><br><span class="line">下面是一些例子。</span><br><span class="line">GET <span class="string">/zoos</span>：列出所有动物园</span><br><span class="line">POST <span class="string">/zoos</span>：新建一个动物园</span><br><span class="line">GET <span class="string">/zoos/ID</span>：获取某个指定动物园的信息</span><br><span class="line">PUT <span class="string">/zoos/ID</span>：更新某个指定动物园的信息（提供该动物园的全部信息）</span><br><span class="line">PATCH <span class="string">/zoos/ID</span>：更新某个指定动物园的信息（提供该动物园的部分信息）</span><br><span class="line">DELETE <span class="string">/zoos/ID</span>：删除某个动物园</span><br><span class="line">GET <span class="string">/zoos/ID/animals</span>：列出某个指定动物园的所有动物</span><br><span class="line">DELETE <span class="string">/zoos/ID/animals/ID</span>：删除某个指定动物园的指定动物</span><br></pre></td></tr></table></figure><h2 id="六、过滤信息（Filtering）"><a href="#六、过滤信息（Filtering）" class="headerlink" title="六、过滤信息（Filtering）"></a>六、过滤信息（Filtering）</h2><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。<br>下面是一些常见的参数。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?<span class="attribute">limit</span>=10：指定返回记录的数量</span><br><span class="line">?<span class="attribute">offset</span>=10：指定返回记录的开始位置。</span><br><span class="line">?<span class="attribute">page</span>=2&amp;per_page=100：指定第几页，以及每页的记录数。</span><br><span class="line">?<span class="attribute">sortby</span>=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</span><br><span class="line">?<span class="attribute">animal_type_id</span>=1：指定筛选条件</span><br></pre></td></tr></table></figure><p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p><h2 id="七、状态码（Status-Codes）"><a href="#七、状态码（Status-Codes）" class="headerlink" title="七、状态码（Status Codes）"></a>七、状态码（Status Codes）</h2><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">200 </span>OK - [<span class="keyword">GET</span>]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</span><br><span class="line"><span class="symbol">201 </span>CREATED - [POST/<span class="keyword">PUT</span>/PATCH]：用户新建或修改数据成功。</span><br><span class="line"><span class="symbol">202 </span>Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</span><br><span class="line"><span class="symbol">204 </span>NO CONTENT - [<span class="keyword">DELETE</span>]：用户删除数据成功。</span><br><span class="line"><span class="symbol">400 </span>INVALID REQUEST - [POST/<span class="keyword">PUT</span>/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</span><br><span class="line"><span class="symbol">401 </span>Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</span><br><span class="line"><span class="symbol">403 </span>Forbidden - [*] 表示用户得到授权（与<span class="number">401</span>错误相对），但是访问是被禁止的。</span><br><span class="line"><span class="symbol">404 </span><span class="keyword">NOT</span> FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</span><br><span class="line"><span class="symbol">406 </span><span class="keyword">Not</span> Acceptable - [<span class="keyword">GET</span>]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</span><br><span class="line"><span class="symbol">410 </span>Gone -[<span class="keyword">GET</span>]：用户请求的资源被永久删除，且不会再得到的。</span><br><span class="line"><span class="symbol">422 </span>Unprocesable entity - [POST/<span class="keyword">PUT</span>/PATCH] 当创建一个对象时，发生一个验证错误。</span><br><span class="line"><span class="symbol">500 </span>INTERNAL SERVER <span class="keyword">ERROR</span> - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</span><br></pre></td></tr></table></figure><p>状态码的完全列表参见<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html" target="_blank" rel="noopener">这里</a>。</p><h2 id="八、错误处理（Error-handling）"><a href="#八、错误处理（Error-handling）" class="headerlink" title="八、错误处理（Error handling）"></a>八、错误处理（Error handling）</h2><p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">error</span>: <span class="string">"Invalid API key"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="九、返回结果"><a href="#九、返回结果" class="headerlink" title="九、返回结果"></a>九、返回结果</h2><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET <span class="string">/collection</span>：返回资源对象的列表（数组）</span><br><span class="line">GET <span class="string">/collection/resource</span>：返回单个资源对象</span><br><span class="line">POST <span class="string">/collection</span>：返回新生成的资源对象</span><br><span class="line">PUT <span class="string">/collection/resource</span>：返回完整的资源对象</span><br><span class="line">PATCH <span class="string">/collection/resource</span>：返回完整的资源对象</span><br><span class="line">DELETE <span class="string">/collection/resource</span>：返回一个空文档</span><br></pre></td></tr></table></figure><h2 id="十、Hypermedia-API"><a href="#十、Hypermedia-API" class="headerlink" title="十、Hypermedia API"></a>十、Hypermedia API</h2><p>RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。<br>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"link"</span>: &#123;</span><br><span class="line">  <span class="attr">"rel"</span>:   <span class="string">"collection https://www.example.com/zoos"</span>,</span><br><span class="line">  <span class="attr">"href"</span>:  <span class="string">"https://api.example.com/zoos"</span>,</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"List of zoos"</span>,</span><br><span class="line">  <span class="attr">"type"</span>:  <span class="string">"application/vnd.yourformat+json"</span></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。<br>Hypermedia API的设计被称为HATEOAS。Github的API就是这种设计，访问api.github.com会得到一个所有可用API的网址列表。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"current_user_url"</span>: <span class="string">"https://api.github.com/user"</span>,</span><br><span class="line">  <span class="string">"authorizations_url"</span>: <span class="string">"https://api.github.com/authorizations"</span>,</span><br><span class="line">  <span class="string">//</span> <span class="string">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看到，如果想获取当前用户的信息，应该去访问api.github.com/user，然后就得到了下面结果。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"message"</span>: <span class="string">"Requires authentication"</span>,</span><br><span class="line">  <span class="attr">"documentation_url"</span>: <span class="string">"https://developer.github.com/v3"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码表示，服务器给出了提示信息，以及文档的网址。</p><h2 id="十一、其他"><a href="#十一、其他" class="headerlink" title="十一、其他"></a>十一、其他</h2><p>（1）API的身份认证应该使用OAuth 2.0框架。<br>（2）服务器返回的数据格式，应该尽量使用JSON，避免使用XML。</p><hr><p><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">【原文链接】</a></p>]]></content>
    
    <summary type="html">
    
      网络应用程序，分为前端和后端两个部分。当前的发展趋势，就是前端设备层出不穷（手机、平板、桌面电脑、其他专用设备......）。因此，必须有一种统一的机制，方便不同的前端设备与后端进行通信。这导致API构架的流行，甚至出现&quot;API First&quot;的设计思想。RESTful API是目前比较成熟的一套互联网应用程序的API设计理论。
    
    </summary>
    
      <category term="Http" scheme="http://miclee.site/categories/Http/"/>
    
    
      <category term="Http" scheme="http://miclee.site/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>Python Web 框架一览</title>
    <link href="http://miclee.site/2017/05/15/Python-Web%E6%A1%86%E6%9E%B6%E4%B8%80%E8%A7%88/"/>
    <id>http://miclee.site/2017/05/15/Python-Web框架一览/</id>
    <published>2017-05-15T03:03:05.000Z</published>
    <updated>2017-05-15T05:39:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> Python 有许多 web 框架可以供你选择。网上甚至还有教你怎么制作自己专属的框架的教程，因为这实在是太容易了。然后就导致了现在框架的质量参差不齐。我们来对这些框架做一个概述然后你可以挑出自己喜欢的。 </em></strong><br><a id="more"></a></p><hr><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们经常谈到的 python web 框架有这些：</p><table><thead><tr><th>名字</th><th>版本</th><th>最后更新</th><th>诞生时间</th><th>代码行数</th></tr></thead><tbody><tr><td>Django</td><td>1.3.1</td><td>2011-09-09</td><td>2005</td><td>115759</td></tr><tr><td>Flask</td><td>0.8</td><td>2011-09-29</td><td>2010</td><td>4681</td></tr><tr><td>Bottle</td><td>0.10.9</td><td>2012-02-11</td><td>2009</td><td>4634</td></tr><tr><td>Tornado</td><td>2.2</td><td>2012-01-30</td><td>2009</td><td>11701</td></tr><tr><td>Cherry.py</td><td>3.2.2</td><td>2011-10-19</td><td>2002</td><td>18828</td></tr><tr><td>web.py</td><td>0.36</td><td>2011-07-04</td><td>2006</td><td>7398</td></tr><tr><td>Brubeck</td><td>0.3.7</td><td>2011-12-20</td><td>011</td><td>1525</td></tr></tbody></table><p>注释1：加上 Brubeck 是因为我认为我们可以从这个框架身上学到很多，虽然这个框架已经不是 Python 框架了。</p><p>注释2：还有许多其他的框架比如说 Zope， Pylons， Pyramid － 我之所以没有写它们是因为我对它们没有经验。</p><p>注释3：如果 Flask 的代码加上 Werkzeug 和 Jinja2 的话一共约 35000 行。</p><p>注释4：代码行数意思是实际的 Python 代码。使用 CLOC 计数。</p><h2 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h2><p>这可能是最广为人知和使用最广泛的 Python web 框架了。我承认它确实非常强大。Django 有世界上最大的社区，最多的包，可以说只有你想不到的，没有它做不到的。它的文档非常完善，但是有的比较冷门的知识你还是需要去 StackOverflow 咨询一下。</p><p>Django 在配置上面遵循惯例，这样对于初学者来说比较容易，而且在比较复杂的应用上也有一定的灵活性。Django 致力于快速开发以及简洁实用的设计。</p><p>Django 只需要这么 几行代码 就可以实现一个“Hello World！”程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">from django.conf.urls.defaults import patterns</span><br><span class="line">from django.http import HttpResponse</span><br><span class="line">filepath, extension = os.path.splitext(__file__)</span><br><span class="line">ROOT_URLCONF = os.path.basename(filepath)</span><br><span class="line"></span><br><span class="line">def hello(request):</span><br><span class="line">    return HttpResponse(&apos;Hello World!&apos;)</span><br><span class="line"></span><br><span class="line">urlpatterns = patterns(&apos;&apos;, (r&apos;^/$&apos;, hello))</span><br></pre></td></tr></table></figure></p><p>关于 Django 我不喜欢的一点就是它有点儿被焊死的感觉。不要尝试着去改变它，否则你会碰壁的。我来解释一下这个说法：比如说我想要使用 SQLAlchemy 作为 ORM 然后 SQLAlchemy 就会把 Admin， Auth， Form 等等几乎所有的部分都给搞砸。所以你最好使用它附带的工具包。</p><p>快速教程： <a href="https://www.djangoproject.com/" target="_blank" rel="noopener">Django</a></p><p>它们都基于 Django： Disqus ， EveryBlock ， Guardian (newspaper) ， Firefox add-ons (Mozilla)</p><h2 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h2><p>这个灵巧的框架是由 Armin Ronacher 创造的。它的名字暗示了它的含义，它基本上就是一个微型的胶水框架。它把 Werkzeug 和 Jinja 粘合在了一起。所以它很容易被扩展。</p><p>Flask 也有许多的 扩展 可以供你使用，Flask 也有一群忠诚的粉丝和不断增加的用户群。它有一份很完善的文档，甚至还有一份唾手可得的常见范例。Flask 很容易使用，你只需要 3(7) 行代码就可以写出来一个 Hello World。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;)</span><br><span class="line">def hello():</span><br><span class="line">    return &quot;Hello World!&quot;</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure></p><p>我觉得这是它最大的优点也是缺点 － Flask 并不强制一个特定的 ORM。这会使得写扩展有点儿困难，你可能会想用某种形式的数据库层，但是用哪一个呢？Python 有非常多可以选择的。这个 Blog 是用 Flask 写的，部署在 Google App Engine 上。这很容易因为 Google Datastore 和其他的不太一样。所以有时候不强制一个 ORM 也是好事儿。</p><p>如果你想建一个新站的话 Flask 是个非常不错的选择。但我并不会向所有的初学者都推荐 Flask，我指的是那些不关心“为什么可以”，只关心它们“可不可以”的初学者。</p><p>快速教程： <a href="http://flask.pocoo.org/docs/0.12/quickstart/" target="_blank" rel="noopener">Flask quickstart</a></p><p>它们都基于 Flask： Dev news aggregator for Battlefield3 ， Media Queries ， Learn buffet ， Konstruktor (appengine)</p><h2 id="Bottle"><a href="#Bottle" class="headerlink" title="Bottle"></a>Bottle</h2><p>这个框架相对来说比较新。它受到了 Sinatra 的影响。Bottle 才是名副其实的微框架 － 它只有大约 4500 行代码。并且我认为这是最真实的基于 Python 的微框架，它除了 Python 标准库以外没有任何其它的依赖，甚至它还有自己独特的一点儿模版语言。Bottle 还是为数不多的支持 Python 3 的框架之一。</p><p>Bottle 的文档很详细并且抓住了事物的实质。Hello World 例子很像 Flask，也使用了装饰器来定义路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from bottle import route, run</span><br><span class="line"></span><br><span class="line">@route(&apos;/hello/:name&apos;)</span><br><span class="line">def hello(name):</span><br><span class="line">    return &apos;&lt;h1&gt;Hello %s!&lt;/h1&gt;&apos; % name.title()</span><br><span class="line"></span><br><span class="line">run(host=&apos;localhost&apos;, port=8080)</span><br></pre></td></tr></table></figure><p>我知道 Bottle 内部有一座桥梁来沟通各个部分，因为它只有一个文件。但是很难找到你想要的东西，它的代码散布的到处都是，看起来一团糟。</p><p>对于非常小的项目或者是实验性的项目来说，Bottle 是一个不错的选择。但是对于一些大型的项目来说最好就不要使用它了，因为它的扩展并不多。</p><p>快速教程： <a href="http://bottlepy.org/docs/dev/tutorial.html" target="_blank" rel="noopener">Bottle tutorial</a></p><p>它们都基于 Bottle： Plush (monitoring) ， Hobo (Blog enginee)</p><h2 id="web-py"><a href="#web-py" class="headerlink" title="web.py"></a>web.py</h2><p>以前 web.py 还很流行的时候被用来写 reddit。它能很好的处理流量问题。如果你用 web.py 开发 web 应用的话，你会发现它并不会阻碍你。 标准配置 很简单也很直观。web.py 在文件和文件夹的分类上面也做的非常棒。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import web</span><br><span class="line"></span><br><span class="line">urls = (&apos;/(.*)&apos;, &apos;hello&apos;)</span><br><span class="line">app = web.application(urls, globals())</span><br><span class="line"></span><br><span class="line">class hello:</span><br><span class="line">    def GET(self):</span><br><span class="line">        return &apos;Hello, World!&apos;</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure></p><p>很遗憾的是这个库最近已经成为了 rails 框架狂热者的受害者。它有可以帮你做几乎所有事情的自己的库 － 模版，表格，数据库。可能它们并不像其它库一样得到了良好的维护，但是还是有许多人在用它。</p><p>快速教程： <a href="http://webpy.org/" target="_blank" rel="noopener">web.py</a></p><p>它们基于 web.py： Yandex (russian search engine) ， Telephone directory (Switzerland)</p><h2 id="Tornado"><a href="#Tornado" class="headerlink" title="Tornado"></a>Tornado</h2><p>Tornado 不单单是个框架，还是个 web 服务器。它一开始是给 FriendFeed 开发的，后来在 2009 年的时候也给 Facebook 使用。它是为了解决实时服务而诞生的。为了做到这一点，Tornado 使用了异步非阻塞 IO。</p><p>Tornado 的文档非常技术性。它并不是为初学者准备的。这是一个 Hello World 程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import tornado.ioloop</span><br><span class="line">import tornado.web</span><br><span class="line"></span><br><span class="line">class MainHandler(tornado.web.RequestHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        self.write(&quot;Hello, world&quot;)</span><br><span class="line"></span><br><span class="line">application = tornado.web.Application([</span><br><span class="line">    (r&quot;/&quot;, MainHandler),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    application.listen(8888)</span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br></pre></td></tr></table></figure></p><p>默认情况下 Tornado 会传递 WSGI 层，因为 WSGI 并不能处理异步请求。Tornado 确实性能非常强，但是当调用数据库的时候它会阻塞 IO。</p><p>快速教程： <a href="http://www.tornadoweb.org/en/stable/" target="_blank" rel="noopener">Tornado</a></p><p>它们基于 Tornado： Too cool for me ， FriendFeed</p><h2 id="CherryPy"><a href="#CherryPy" class="headerlink" title="CherryPy"></a>CherryPy</h2><p>这是最古老的 Python 框架的一种。CherryPy 并没有得到广泛的应用，大家提到它第一反应是 web 服务器然后才是一个框架。在处理请求方面 CherryPy 也使用了队列来优化性能，但是它使用的是 线程池 技术。</p><p>CherryPy 的文档实际上非常少，但是基本上都可以涵盖主要的方面。CherryPy 也可以支持 Python 3。我必须说，它的 Hello World 例子非常漂亮：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import cherrypy</span><br><span class="line">class HelloWorld(object):</span><br><span class="line">    def index(self):</span><br><span class="line">    return &quot;Hello World!&quot;</span><br><span class="line">    index.exposed = True</span><br><span class="line"></span><br><span class="line">cherrypy.quickstart(HelloWorld())</span><br></pre></td></tr></table></figure></p><p>快速教程： <a href="http://docs.cherrypy.org/en/latest/" target="_blank" rel="noopener">CherryPy</a></p><p>它们基于 CherryPy： YouGov ， Cuil search engine (ended 2010)</p><h2 id="Brubeck"><a href="#Brubeck" class="headerlink" title="Brubeck"></a>Brubeck</h2><p>这是一个新的 Python 框架。其并不使用 WSGI 而直接在语言级别用 Mongrel2 作为服务器使用，这个仅把请求处理交给 Python 程序，请求作为协同程序来处理。</p><p>模块方面 Brubeck 使用了 DictShield 库，意思就是对于不同的数据库插件都可以在其之上来进行操作。</p><p>Brubeck 的文档非常少，但是你看到源码以后，你会知道其实并没有多少东西。所以它还是一个非常年轻并且在不断发展的框架。Hello World 例子看起来也很漂亮。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class DemoHandler(WebMessageHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        self.set_body(&apos;Hello world&apos;)</span><br><span class="line">        return self.render()</span><br><span class="line"></span><br><span class="line">urls = [(r&apos;^/&apos;, DemoHandler)]</span><br><span class="line">mongrel2_pair = (&apos;ipc://127.0.0.1:9999&apos;, &apos;ipc://127.0.0.1:9998&apos;)</span><br><span class="line"></span><br><span class="line">app = Brubeck(mongrel2_pair=mongrel2_pair,</span><br><span class="line">          handler_tuples=urls)</span><br><span class="line">app.run()</span><br></pre></td></tr></table></figure></p><p>唯一需要注意的是当你使用 Brubeck 的时候你也需要看看 Mongrel2 服务器的相关知识。</p><p>快速教程： <a href="http://brubeck.io/" target="_blank" rel="noopener">Brubeck.io</a></p><p>它们基于 Brubeck： ListSurf</p>]]></content>
    
    <summary type="html">
    
      Python 有许多 web 框架可以供你选择。网上甚至还有教你怎么制作自己专属的框架的教程，因为这实在是太容易了。然后就导致了现在框架的质量参差不齐。我们来对这些框架做一个概述然后你可以挑出自己喜欢的。
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>人生苦短，我用Python【转】</title>
    <link href="http://miclee.site/2017/05/12/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8C%E6%88%91%E7%94%A8Python/"/>
    <id>http://miclee.site/2017/05/12/人生苦短，我用Python/</id>
    <published>2017-05-12T09:28:26.000Z</published>
    <updated>2017-05-15T05:38:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> Python语言的发展简史。 </em></strong><br><a id="more"></a></p><hr><p>Python是我喜欢的语言，简洁，优美，容易使用。前两天，我很激昂的向朋友宣传Python的好处。</p><p>“好吧，我承认Python不错，但它为什么叫Python呢？”<br>“呃，似乎是一个电视剧的名字。”<br>“那你说的Guido是美国人么？”<br>“他从Google换到Dropbox工作，但他的名字像是荷兰人的。”<br>“你确定你很熟悉Python吗？”</p><p>所以为了雪耻，我花时间调查了Python的历史。我看到了Python中许多功能的来源和Python的设计理念，看到了一门编程语言的演化历史，看到了Python与开源运动的奇妙联系。从Python的历史中，我们可以一窥开源开发的理念和成就。</p><p>这也可以作为我写的Python快速教程的序篇。</p><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>Python的作者，Guido von Rossum，确实是荷兰人。1982年，Guido从阿姆斯特丹大学获得了数学和计算机硕士学位。然而，尽管他算得上是一位数学家，但他更加享受计算机带来的乐趣。用他的话说，尽管拥有数学和计算机双料资质，他总趋向于做计算机相关的工作，并热衷于做任何和编程相关的活儿。</p><p>在那个时候，Guido接触并使用过诸如Pascal、C、 Fortran等语言。这些语言的基本设计原则是让机器能更快运行。在80年代，虽然IBM和苹果已经掀起了个人电脑浪潮，但这些个人电脑的配置很低。比如早期的Macintosh，只有8MHz的CPU主频和128KB的RAM，一个大的数组就能占满内存。所有的编译器的核心是做优化，以便让程序能够运行。为了增进效率，语言也迫使程序员像计算机一样思考，以便能写出更符合机器口味的程序。在那个时代，程序员恨不得用手榨取计算机每一寸的能力。有人甚至认为C语言的指针是在浪费内存。至于动态类型，内存自动管理，面向对象…… 别想了，那会让你的电脑陷入瘫痪。</p><p>这种编程方式让Guido感到苦恼。Guido知道如何用C语言写出一个功能，但整个编写过程需要耗费大量的时间，即使他已经准确的知道了如何实现。他的另一个选择是shell。Bourne Shell作为UNIX系统的解释器已经长期存在。UNIX的管理员们常常用shell去写一些简单的脚本，以进行一些系统维护的工作，比如定期备份、文件系统管理等等。shell可以像胶水一样，将UNIX下的许多功能连接在一起。许多C语言下上百行的程序，在shell下只用几行就可以完成。然而，shell的本质是调用命令。它并不是一个真正的语言。比如说，shell没有数值型的数据类型，加法运算都很复杂。总之，shell不能全面的调动计算机的功能。</p><p>Guido希望有一种语言，这种语言能够像C语言那样，能够全面调用计算机的功能接口，又可以像shell那样，可以轻松的编程。ABC语言让Guido看到希望。ABC是由荷兰的数学和计算机研究所开发的。Guido在该研究所工作，并参与到ABC语言的开发。ABC语言以教学为目的。与当时的大部分语言不同，ABC语言的目标是“让用户感觉更好”。ABC语言希望让语言变得容易阅读，容易使用，容易记忆，容易学习，并以此来激发人们学习编程的兴趣。比如下面是一段来自Wikipedia的ABC程序，这个程序用于统计文本中出现的词的总数：  </p><pre><code>HOW TO RETURN words document:    PUT {} IN collection    FOR line IN document:        FOR word IN split line:        IF word not.in collection:            INSERT word IN collection    RETURN collection</code></pre><p>HOW TO用于定义一个函数。一个Python程序员应该很容易理解这段程序。ABC语言使用冒号和缩进来表示程序块。行尾没有分号。for和if结构中也没有括号()。赋值采用的是PUT，而不是更常见的等号。这些改动让ABC程序读起来像一段文字。</p><p>尽管已经具备了良好的可读性和易用性，ABC语言最终没有流行起来。在当时，ABC语言编译器需要比较高配置的电脑才能运行。而这些电脑的使用者通常精通计算机，他们更多考虑程序的效率，而非它的学习难度。除了硬件上的困难外，ABC语言的设计也存在一些致命的问题：</p><ul><li><p>可拓展性差。ABC语言不是模块化语言。如果想在ABC语言中增加功能，比如对图形化的支持，就必须改动很多地方。</p></li><li><p>不能直接进行IO。ABC语言不能直接操作文件系统。尽管你可以通过诸如文本流的方式导入数据，但ABC无法直接读写文件。输入输出的困难对于计算机语言来说是致命的。你能想像一个打不开车门的跑车么？</p></li><li><p>过度革新。ABC用自然语言的方式来表达程序的意义，比如上面程序中的HOW TO 。然而对于程序员来说，他们更习惯用function或者define来定义一个函数。同样，程序员更习惯用等号来分配变量。尽管ABC语言很特别，但学习难度也很大。</p></li><li><p>传播困难。ABC编译器很大，必须被保存在磁带上。当时Guido在访问的时候，就必须有一个大磁带来给别人安装ABC编译器。 这样，ABC语言就很难快速传播。</p></li></ul><p>1989年，为了打发圣诞节假期，Guido开始写Python语言的编译器。Python这个名字，来自Guido所挚爱的电视剧Monty Python’s Flying Circus。他希望这个新的叫做Python的语言，能符合他的理想：创造一种C和shell之间，功能全面，易学易用，可拓展的语言。Guido作为一个语言设计爱好者，已经有过设计语言的尝试。这一次，也不过是一次纯粹的hacking行为。</p><h2 id="一门语言的诞生"><a href="#一门语言的诞生" class="headerlink" title="一门语言的诞生"></a>一门语言的诞生</h2><p>1991年，第一个Python编译器诞生。它是用C语言实现的，并能够调用C语言的库文件。从一出生，Python已经具有了：类，函数，异常处理，包含表和词典在内的核心数据类型，以及模块为基础的拓展系统。</p><p>Python语法很多来自C，但又受到ABC语言的强烈影响。来自ABC语言的一些规定直到今天还富有争议，比如强制缩进。但这些语法规定让Python容易读。另一方面，Python聪明的选择服从一些惯例，特别是C语言的惯例。比如使用等号赋值，使用def来定义函数。Guido认为，如果“常识”上确立的东西，没有必要过度纠结。</p><p>Python从一开始就特别在意可拓展性。Python可以在多个层次上拓展。从高层上，你可以直接引入.py文件。在底层，你可以引用C语言的库。Python程序员可以快速的使用Python写.py文件作为拓展模块。但当性能是考虑的重要因素时，Python程序员可以深入底层，写C程序，编译为.so文件引入到Python中使用。Python就好像是使用钢构建房一样，先规定好大的框架。而程序员可以在此框架下相当自由的拓展或更改。</p><p>最初的Python完全由Guido本人开发。Python得到Guido同事的欢迎。他们迅速的反馈使用意见，并参与到Python的改进。Guido和一些同事构成Python的核心团队。他们将自己大部分的业余时间用于hack Python。随后，Python拓展到研究所之外。Python将许多机器层面上的细节隐藏，交给编译器处理，并凸显出逻辑层面的编程思考。Python程序员可以花更多的时间用于思考程序的逻辑，而不是具体的实现细节。这一特征吸引了广大的程序员。Python开始流行。<br>人生苦短，我用python</p><p><img src="https://raw.githubusercontent.com/OfMicLee/img-hosting/master/python/001.jpg" alt=""></p><h2 id="时势造英雄"><a href="#时势造英雄" class="headerlink" title="时势造英雄"></a>时势造英雄</h2><p>我们不得不暂停我们的Python时间，转而看一看瞬息万变的计算机行业。1990年代初，个人计算机开始进入普通家庭。Intel发布了486处理器，windows发布window 3.0开始的一系列视窗系统。计算机的性能大大提高。程序员开始关注计算机的易用性  ，比如图形化界面。</p><p><img src="https://raw.githubusercontent.com/OfMicLee/img-hosting/master/python/002.png" alt=""></p><p>由于计算机性能的提高，软件的世界也开始随之改变。硬件足以满足许多个人电脑的需要。硬件厂商甚至渴望高需求软件的出现，以带动硬件的更新换代。C++和Java相继流行。C++和Java提供了面向对象的编程范式，以及丰富的对象库。在牺牲了一定的性能的代价下，C++和Java大大提高了程序的产量。语言的易用性被提到一个新的高度。我们还记得，ABC失败的一个重要原因是硬件的性能限制。从这方面说，Python要比ABC幸运许多。</p><p>另一个悄然发生的改变是Internet。1990年代还是个人电脑的时代，windows和Intel挟PC以令天下，盛极一时。尽管Internet为主体的信息革命尚未到来，但许多程序员以及资深计算机用户已经在频繁使用Internet进行交流，比如使用email和newsgroup。Internet让信息交流成本大大下降。一种新的软件开发模式开始流行：开源。程序员利用业余时间进行软件开发，并开放源代码。1991年，Linus在comp.os.minix新闻组上发布了Linux内核源代码，吸引大批hacker的加入。Linux和GNU相互合作，最终构成了一个充满活力的开源平台。</p><p>硬件性能不是瓶颈，Python又容易使用，所以许多人开始转向Python。Guido维护了一个maillist，Python用户就通过邮件进行交流。Python用户来自许多领域，有不同的背景，对Python也有不同的需求。Python相当的开放，又容易拓展，所以当用户不满足于现有功能，很容易对Python进行拓展或改造。随后，这些用户将改动发给Guido，并由Guido决定是否将新的特征加入到Python或者标准库中。如果代码能被纳入Python自身或者标准库，这将极大的荣誉。由于Guido至高无上的决定权，他因此被称为“终身的仁慈独裁者”。</p><p>Python被称为“Battery Included”，是说它以及其标准库的功能强大。这些是整个社区的贡献。Python的开发者来自不同领域，他们将不同领域的优点带给Python。比如Python标准库中的正则表达是参考Perl，而lambda, map, filter, reduce等函数参考了Lisp。Python本身的一些功能以及大部分的标准库来自于社区。Python的社区不断扩大，进而拥有了自己的newsgroup，网站，以及基金。从Python 2.0开始，Python也从maillist的开发方式，转为完全开源的开发方式。社区气氛已经形成，工作被整个社区分担，Python也获得了更加高速的发展。</p><p>到今天，Python的框架已经确立。Python语言以对象为核心组织代码，支持多种编程范式，采用动态类型，自动进行内存回收。Python支持解释运行，并能调用C库进行拓展。Python有强大的标准库。由于标准库的体系已经稳定，所以Python的生态系统开始拓展到第三方包。这些包，如Django、web.py、wxpython、numpy、matplotlib、PIL，将Python升级成了物种丰富的热带雨林。</p><h2 id="启示录"><a href="#启示录" class="headerlink" title="启示录"></a>启示录</h2><p>Python崇尚优美、清晰、简单，是一个优秀并广泛使用的语言。Python在TIOBE排行榜中排行第八，它是Google的第三大开发语言，Dropbox的基础语言，豆瓣的服务器语言。Python的发展史可以作为一个代表，带给我许多启示。</p><p>在Python的开发过程中，社区起到了重要的作用。Guido自认为自己不是全能型的程序员，所以他只负责制订框架。如果问题太复杂，他会选择绕过去，也就是cut the corner。这些问题最终由社区中的其他人解决。社区中的人才是异常丰富的，就连创建网站，筹集基金这样与开发稍远的事情，也有人乐意于处理。如今的项目开发越来越复杂，越来越庞大，合作以及开放的心态成为项目最终成功的关键。</p><p>Python从其他语言中学到了很多，无论是已经进入历史的ABC，还是依然在使用的C和Perl，以及许多没有列出的其他语言。可以说，Python的成功代表了它所有借鉴的语言的成功。同样，Ruby借鉴了Python，它的成功也代表了Python某些方面的成功。每个语言都是混合体，都有它优秀的地方，但也有各种各样的缺陷。同时，一个语言“好与不好”的评判，往往受制于平台、硬件、时代等等外部原因。程序员经历过许多语言之争。其实，以开放的心态来接受各个语言，说不定哪一天，程序员也可以如Guido那样，混合出自己的语言。</p><p>无论Python未来的命运如何，Python的历史已经是本很有趣的小说。</p>]]></content>
    
    <summary type="html">
    
      Python语言的发展简史。
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>解决MAC系统上matplotlib无法使用问题</title>
    <link href="http://miclee.site/2017/05/12/%E8%A7%A3%E5%86%B3matplotlib%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://miclee.site/2017/05/12/解决matplotlib无法使用问题/</id>
    <published>2017-05-12T01:49:13.000Z</published>
    <updated>2017-05-12T01:58:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 在 MAC 上运行Python时，如果涉及到matplotlib画图，小火箭总是弹不出界面，有的还会报RuntimeError。 </em></strong><br><a id="more"></a></p><hr><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**RuntimeError**: Python <span class="keyword">is</span> <span class="keyword">not</span> installed <span class="keyword">as</span> a framework. The Mac OS X backend will <span class="keyword">not</span> be able <span class="keyword">to</span> function correctly <span class="keyword">if</span> Python <span class="keyword">is</span> <span class="keyword">not</span> installed <span class="keyword">as</span> a framework. See <span class="keyword">the</span> Python documentation <span class="keyword">for</span> more information <span class="keyword">on</span> installing Python <span class="keyword">as</span> a framework <span class="keyword">on</span> Mac OS X. Please either reinstall Python <span class="keyword">as</span> a framework, <span class="keyword">or</span> <span class="keyword">try</span> one <span class="keyword">of</span> <span class="keyword">the</span> other backends.</span><br></pre></td></tr></table></figure><p><strong>原因：</strong>  </p><p>Problem Cause In mac os image rendering back end of matplotlib (what-is-a-backend to render using the API of Cocoa by default). There is Qt4Agg and GTKAgg and as a back-end is not the default. Set the back end of macosx that is differ compare with other windows or linux os.</p><p><strong>解决方案：</strong></p><p>创建文件 ~/.matplotlib/matplotlibrc<br>增加内容:<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">backend: </span>TkAgg</span><br></pre></td></tr></table></figure></p><p>搞定收工！</p>]]></content>
    
    <summary type="html">
    
      在 MAC 上运行Python时，如果涉及到matplotlib画图，小火箭总是弹不出界面，有的还会报RuntimeError。
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Numpy 矩阵乘法</title>
    <link href="http://miclee.site/2017/05/10/py-dot-multiply/"/>
    <id>http://miclee.site/2017/05/10/py-dot-multiply/</id>
    <published>2017-05-10T09:02:17.000Z</published>
    <updated>2017-05-16T05:50:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 在NumPy中，array用于表示通用的N维数组，matrix则特定用于线性代数计算。array和matrix都可以用来表示矩阵，二者在进行乘法操作时，有一些不同之处。 </em></strong><br><a id="more"></a></p><hr><h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><p>使用array时，运算符 * 用于计算数量积（点乘），函数 dot() 用于计算矢量积（叉乘），例子如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">a = np.array([[1, 2], [3, 4]])</span><br><span class="line">b = np.array([[5, 6], [7, 8]])</span><br><span class="line"></span><br><span class="line">print(&apos;a * b = \n&apos;, a * b)</span><br><span class="line">print(&apos;dot(a, b) = \n&apos;, np.dot(a, b))</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a * b =</span><br><span class="line">[[ 5 12]</span><br><span class="line"> [21 32]]</span><br><span class="line">dot(a, b) =</span><br><span class="line">[[19 22]</span><br><span class="line"> [43 50]]</span><br></pre></td></tr></table></figure><p>可见，当a和b为array时， a <em> b 计算了a和b的数量积（对应Matlab的 a .</em> b ）， dot(a, b) 计算了a和b的矢量积（对应Matlab的 a * b ）。</p><h2 id="matrix"><a href="#matrix" class="headerlink" title="matrix"></a>matrix</h2><p>与array不同的是，使用matrix时，运算符 * 用于计算矢量积，函数 multiply() 用于计算数量积，例子如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">a = np.mat(&apos;1 2; 3 4&apos;)</span><br><span class="line">b = np.mat(&apos;5 6; 7 8&apos;);</span><br><span class="line"></span><br><span class="line">print &apos;a * b = \n&apos;, a * b</span><br><span class="line">print &apos;multiply(a, b) = \n&apos;, np.multiply(a, b)</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a * b =</span><br><span class="line"><span class="string">[[19 22]</span></span><br><span class="line"><span class="string"> [43 50]]</span></span><br><span class="line">multiply(a, b) =</span><br><span class="line"><span class="string">[[ 5 12]</span></span><br><span class="line"><span class="string"> [21 32]]</span></span><br></pre></td></tr></table></figure><p>可见，当a和b为matrix时， a * b 计算了a和b的矢量积， multiply(a, b) 计算了a和b的数量积。当使用matrix时，无论是生成矩阵还是计算，Numpy的风格和Matlab更加贴近，降低了语言切换时的负担。</p>]]></content>
    
    <summary type="html">
    
      在NumPy中，array用于表示通用的N维数组，matrix则特定用于线性代数计算。array和matrix都可以用来表示矩阵，二者在进行乘法操作时，有一些不同之处。
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>range、xrange、arange比较</title>
    <link href="http://miclee.site/2017/05/10/python-range/"/>
    <id>http://miclee.site/2017/05/10/python-range/</id>
    <published>2017-05-10T05:31:51.000Z</published>
    <updated>2017-05-11T10:56:41.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> range & xrange属于python的原生方法，arange属于numpy库的方法，具体区别如下。 </em></strong><br><a id="more"></a></p><hr><h2 id="range"><a href="#range" class="headerlink" title="range"></a>range</h2><p>官方文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">range(stop) -&gt; range object</span><br><span class="line">range(start, stop[, step]) -&gt; range object</span><br><span class="line"></span><br><span class="line">Return an object that produces a sequence of integers from start (inclusive)</span><br><span class="line">to stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.</span><br><span class="line">start defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.</span><br><span class="line">These are exactly the valid indices for a list of 4 elements.</span><br><span class="line">When step is given, it specifies the increment (or decrement).</span><br></pre></td></tr></table></figure></p><p><strong>函数说明：</strong><br>根据start与stop指定的范围以及step设定的步长，生成一个序列。<br>range示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; range(5)</span><br><span class="line">[0, 1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt; range(1,5)</span><br><span class="line">[1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt; range(0,6,2)</span><br><span class="line">[0, 2, 4]</span><br></pre></td></tr></table></figure></p><h2 id="xrange"><a href="#xrange" class="headerlink" title="xrange"></a>xrange</h2><p><strong>函数说明：</strong><br>用法与range完全相同，所不同的是生成的不是一个数组，而是一个生成器。<br>xrange示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; xrange(5)</span><br><span class="line">xrange(5)</span><br><span class="line">&gt;&gt;&gt; list(xrange(5))</span><br><span class="line">[0, 1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt; xrange(1,5)</span><br><span class="line">xrange(1, 5)</span><br><span class="line">&gt;&gt;&gt; list(xrange(1,5))</span><br><span class="line">[1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt; xrange(0,6,2)</span><br><span class="line">xrange(0, 6, 2)</span><br><span class="line">&gt;&gt;&gt; list(xrange(0,6,2))</span><br><span class="line">[0, 2, 4]</span><br></pre></td></tr></table></figure></p><p>要生成很大的数字序列的时候，用xrange会比range性能优很多，因为不需要一上来就开辟一块很大的内存空间，这两个基本上都是在循环的时候用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in range(0, 100):</span><br><span class="line">print i</span><br><span class="line">for i in xrange(0, 100):</span><br><span class="line">print i</span><br></pre></td></tr></table></figure></p><p><strong>在Python 3中，range()的实现方式与xrange()函数相同，所以就不存在专用的xrange()（在Python 3中使用xrange()会触发NameError）。</strong>  </p><h2 id="arange"><a href="#arange" class="headerlink" title="arange"></a>arange</h2><p><strong>官方文档：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">numpy.arange([start, ]stop, [step, ]dtype=None)</span><br><span class="line">Return evenly spaced values within a given interval.</span><br><span class="line"></span><br><span class="line">Values are generated within the half-open interval [start, stop) (in other words, the interval including start but excluding stop). For integer arguments the function is equivalent to the Python built-in range function, but returns an ndarray rather than a list.</span><br><span class="line">```   </span><br><span class="line">用法等同于range，区别在于返回的是ndarray而非list。</span><br><span class="line">```python3</span><br><span class="line">&gt;&gt;&gt; np.arange(3)</span><br><span class="line">array([0, 1, 2])</span><br><span class="line">&gt;&gt;&gt; np.arange(3.0)</span><br><span class="line">array([ 0.,  1.,  2.])</span><br><span class="line">&gt;&gt;&gt; np.arange(3,7)</span><br><span class="line">array([3, 4, 5, 6])</span><br><span class="line">&gt;&gt;&gt; np.arange(3,7,2)</span><br><span class="line">array([3, 5])</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      range &amp; xrange属于python的原生方法，arange属于numpy库的方法，具体区别如下。
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>机器学习里的常用数学概念</title>
    <link href="http://miclee.site/2017/04/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%87%8C%E7%9A%84%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E6%A6%82%E5%BF%B5/"/>
    <id>http://miclee.site/2017/04/26/机器学习里的常用数学概念/</id>
    <published>2017-04-26T08:26:40.000Z</published>
    <updated>2017-04-26T08:40:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 机器学习是门数学强相关的学科，在学习过程中不得不回过头去复习很多大学甚至中学的数学概念，在此记录下，方便以后查询。会持续往里更新。。。 </em></strong><br><a id="more"></a></p><hr><h2 id="偏差（Bias）"><a href="#偏差（Bias）" class="headerlink" title="偏差（Bias）"></a>偏差（Bias）</h2><p>   偏差描述的是预测值和真实值的差距。<br>   偏差越大，越偏离真实数据。  </p><h2 id="方差（Variance）"><a href="#方差（Variance）" class="headerlink" title="方差（Variance）"></a>方差（Variance）</h2><p>   方差描述的是预测值的变化范围、离散程度。<br>   方差越大，数据的分布越分散。  </p><h2 id="标准差"><a href="#标准差" class="headerlink" title="标准差"></a>标准差</h2><p>   标准差是方差的算术平方根。<br>   标准差和均值的量纲是一致的，在描述一个波动范围时更方便。<br>   如，身高分布是 170cm ± 10cm，标准差为10，方差为100。   </p><h2 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h2><p>   协方差用于衡量两个变量的总体误差。<br>   方差是协方差的一种特殊情况，即当两个变量是相同的情况。  </p><hr><h2 id="中位数"><a href="#中位数" class="headerlink" title="中位数"></a>中位数</h2><p>   将一组数据按大小一次排列，把处在中间位置的一个数据（或最中间两位数的平均数）叫做这组数据的中位数。  </p><h2 id="众数"><a href="#众数" class="headerlink" title="众数"></a>众数</h2><p>   一组数据中出现次数最多的数。</p>]]></content>
    
    <summary type="html">
    
      机器学习是门数学强相关的学科，在学习过程中不得不回过头去复习很多大学甚至中学的数学概念，在此记录下，方便以后查询。会持续往里更新。。。
    
    </summary>
    
      <category term="机器学习" scheme="http://miclee.site/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://miclee.site/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>数据挖掘</title>
    <link href="http://miclee.site/2017/04/26/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    <id>http://miclee.site/2017/04/26/数据挖掘/</id>
    <published>2017-04-26T08:06:36.000Z</published>
    <updated>2017-04-26T08:42:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 在机器学习那章提到过，数据挖掘就是“机器学习+数据库”。就是在大型数据存储库中自动发现有用信息的过程。数据库中的知识发现。 </em></strong><br><a id="more"></a></p><hr><h2 id="数据挖掘主要任务"><a href="#数据挖掘主要任务" class="headerlink" title="数据挖掘主要任务"></a>数据挖掘主要任务</h2><ul><li>预测建模  <ul><li>分类：预测离散的目标变量</li><li>回归：预测连续的目标变量</li></ul></li><li>关联分析<br>发现数据中强关联特征的模式，如购物篮分析。</li><li>聚类分析<br>发现紧密相关的观测值组群，如新闻分类聚合。  </li><li>异常检测<br>识别其特征显著不同于其他数据的观测值，这样的观测值称为 <em>异常点</em> 或 <em>利群点</em>。如信贷欺诈、网络攻击、疾病发现、生态系统扰动等。  </li></ul><h2 id="数据挖掘主要步骤"><a href="#数据挖掘主要步骤" class="headerlink" title="数据挖掘主要步骤"></a>数据挖掘主要步骤</h2><ol><li>业务理解  </li><li>数据理解  </li><li>数据准备<br>数据准备就是对数据预处理，包括抽样、缺失值&amp;异常值处理、变量选择、数据分箱、数据降维等。  </li><li>建模  </li><li>模型评估<br>常用评估方法：混淆矩阵、基尼系数、K-S曲线、ROC曲线等。</li><li>模型发布</li></ol><h2 id="常用分类算法"><a href="#常用分类算法" class="headerlink" title="常用分类算法"></a>常用分类算法</h2><ul><li>决策树</li><li>基于规则的分类器</li><li>K-最近邻分类器</li><li>支持向量机</li><li>贝叶斯分类</li><li>人工神经网络</li><li>Logistic回归</li><li>多分类器组合使用</li></ul>]]></content>
    
    <summary type="html">
    
      在机器学习那章提到过，数据挖掘就是“机器学习+数据库”。就是在大型数据存储库中自动发现有用信息的过程。数据库中的知识发现。
    
    </summary>
    
      <category term="机器学习" scheme="http://miclee.site/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="数据挖掘" scheme="http://miclee.site/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>机器学习</title>
    <link href="http://miclee.site/2017/04/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://miclee.site/2017/04/26/机器学习/</id>
    <published>2017-04-26T07:13:26.000Z</published>
    <updated>2017-04-26T08:14:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 今年正式开始学习机器学习，记了很多笔记在小本子上（本人还是比较偏爱传统书写），缺点就是回头翻阅起来检索比较困难，So干脆花点时间整理到博客上吧，方便自己也方便他人。由于我目前的工作主要用到机器学习的分类算法，所以会先入手研究这方面，其他的以后再慢慢补充吧。 </em></strong><br><a id="more"></a></p><hr><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>机器学习是人工智能的一个分支。<br>机器学习方法是指用某些算法指导计算机利用已有的数据，得出适当的模型，并利用此模型对新的情境给出判断（预测未来）的一种方法。  </p><p>人工智能 &gt; 机器学习 &gt; 深度学习（即多层神经网络）</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li><p><strong>监督学习</strong><br>从给定的训练数据集中学习出一个函数，当新的数据到来时，可以根据这个函数预测结果。<br>监督学习的训练集要求是包括输入和输出，也可以说是特征和目标。训练集中的目标是由人标注的。<br>常见的监督学习算法包括 <em>回归分析</em> 和 <em>统计分类</em>。  </p><ul><li><strong>回归分析（Regression）</strong><br>预测一个连续值的输出，比如房价。</li><li><strong>统计分类（Classification）</strong><br>预测一个离散值的输出。又细分为二元分类和多元分类。  </li></ul></li><li><p><strong>无监督学习</strong><br>它是一种学习机制，给算法大量的数据，自动找出数据中蕴含的数据结构。<br>无监督学习中，没有属性或标签这一概念，也就是说所有数据都是一样的，没有区别。<br>与监督学习相比，训练集没有人为标注的结果。<br>常见的无监督学习算法有 <em>聚类算法</em> 和 <em>鸡尾酒会算法</em>。  </p><ul><li><strong>聚类算法</strong><br>不同的个体归入不同的类。如谷歌新闻分类。</li><li><strong>鸡尾酒会算法</strong><br>分离出叠加在一起的分类。</li></ul></li><li><p><strong>半监督学习</strong><br>介于监督学习与无监督学习之间。</p></li><li><p><strong>增强学习</strong><br>强调如何基于环境而行动，以取得最大化的预期利益。其灵感来源于心理学中的行为主义理论，即有机体如何在环境给予的奖励或惩罚的刺激下，逐步形成对刺激的预期，产生能获得最大利益的习惯性行为。这个方法具有普适性，因此在其他许多领域都有研究，例如博弈论、控制论、运筹学、信息论、仿真优化、多主体系统学习、群体智能、统计学以及遗传算法。  </p><p>增强学习和标准的监督式学习之间的区别在于，它并不需要出现正确的输入/输出对，也不需要精确校正次优化的行为。强化学习更加专注于在线规划，需要在探索（在未知的领域）和遵从（现有知识）之间找到平衡。强化学习中的“探索-遵从”的交换，在“多臂老虎机问题”和“有限MDP”中研究得最多。</p><h2 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h2><ul><li><strong>模式识别</strong><br>模式识别 = 机器学习，前者是工业界的概念。  </li><li><strong>数据挖掘</strong><br>数据挖掘 = 机器学习 + 数据库   </li><li><strong>统计学习</strong><br>统计学习 ≈ 机器学习，前者偏数学，后者偏实践。</li><li><strong>语音识别</strong><br>语言处理 + 机器学习</li><li><strong>计算机视觉</strong><br>图像处理 + 机器学习</li><li><strong>自然语言处理</strong><br>文本处理 + 机器学习</li></ul></li></ul><h2 id="经典代表算法"><a href="#经典代表算法" class="headerlink" title="经典代表算法"></a>经典代表算法</h2><ul><li><strong>监督学习算法</strong>  <ul><li>线性回归</li><li>逻辑回归</li><li>神经网络</li><li>SVM  </li></ul></li><li><strong>无监督算法</strong>  <ul><li>聚类算法</li><li>降维算法</li></ul></li><li><strong>特殊</strong><ul><li>推荐算法</li></ul></li></ul><h2 id="开发机器学习应用程序的步骤"><a href="#开发机器学习应用程序的步骤" class="headerlink" title="开发机器学习应用程序的步骤"></a>开发机器学习应用程序的步骤</h2><ol><li>收集数据    </li><li>准备数据  </li><li>分析数据  </li><li>训练算法（无监督学习不需要这一步）  </li><li>测试算法  </li><li>使用算法  </li></ol>]]></content>
    
    <summary type="html">
    
      今年正式开始学习机器学习，记了很多笔记在小本子上（本人还是比较偏爱传统书写），缺点就是回头翻阅起来检索比较困难，So干脆花点时间整理到博客上吧，方便自己也方便他人。由于我目前的工作主要用到机器学习的分类算法，所以会先入手研究这方面，其他的以后再慢慢补充吧。
    
    </summary>
    
      <category term="机器学习" scheme="http://miclee.site/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://miclee.site/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>更改Hexo的Markdown解析</title>
    <link href="http://miclee.site/2017/04/20/%E6%9B%B4%E6%94%B9Hexo%E7%9A%84Markdown%E8%A7%A3%E6%9E%90/"/>
    <id>http://miclee.site/2017/04/20/更改Hexo的Markdown解析/</id>
    <published>2017-04-20T08:28:45.000Z</published>
    <updated>2017-04-20T09:23:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> Hexo默认使用marked.js去解析我们写的markdown，以前用的就很不爽，解析的效果跟atom里预览效果不一致，本来想换个引擎，无奈有一些老的博文需要调整，索性改一下marked.js的解析方法。 </em></strong><br><a id="more"></a></p><hr><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在写博文<a href="http://miclee.cn/2017/04/20/Python下划线使用" target="_blank" rel="noopener">Python下划线使用</a>时因为有一堆的下滑线要写，hexo默认使用marked.js去解析我们写的markdown，比如一些符号，_代表斜体，会被处理为<em>标签，比如x_i在开始被渲染的时候，处理为x<em>i</em>，比如<strong>init</strong>会被处理成<strong>init</strong>。</em></p><p>考虑到我后面会写机器学习相关的一些东西，里面会涉及到很多数学公式，会影响解析，SO趁现在动动手。</p><h2 id="利用MathJax来渲染LaTeX数学公式"><a href="#利用MathJax来渲染LaTeX数学公式" class="headerlink" title="利用MathJax来渲染LaTeX数学公式"></a>利用MathJax来渲染LaTeX数学公式</h2><p>题外一下，MathJax的hexo插件安装方法。<br>cd到博文目录：<br><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-<span class="built_in">math</span> <span class="comment">--save</span></span><br><span class="line">hexo <span class="built_in">math</span> install</span><br></pre></td></tr></table></figure></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ./node_modules/marked/lib/marked.js</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//escape: /^\\([\\`*&#123;&#125;\[\]()#+\-.!_&gt;])/,</span></span><br><span class="line"><span class="built_in">escape</span>: <span class="regexp">/^\\([`*&#123;&#125;\[\]()# +\-.!_&gt;])/</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">//strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,</span></span><br><span class="line">strong: <span class="regexp">/^\*\*([\s\S]+?)\*\*(?!\*)/</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">//em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span></span><br><span class="line">em:<span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure><p>So以后写 <em>斜体</em> 和 <strong>粗体</strong> 只能用* 和 ** 了</p><h2 id="解决方案二：更换Markdown引擎"><a href="#解决方案二：更换Markdown引擎" class="headerlink" title="解决方案二：更换Markdown引擎"></a>解决方案二：更换Markdown引擎</h2><p>比如换成pandoc：</p><ol><li><p>安装pandoc</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>Pandoc</span><br></pre></td></tr></table></figure></li><li><p>安装 <a href="https://github.com/wzpan/hexo-renderer-pandoc" target="_blank" rel="noopener">hexo-renderer-pandoc</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">uninstall</span> hexo-renderer-marked <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-renderer-pandoc <span class="comment">--save</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="解决方案三：一个个用-转义吧"><a href="#解决方案三：一个个用-转义吧" class="headerlink" title="解决方案三：一个个用\转义吧"></a>解决方案三：一个个用\转义吧</h2>]]></content>
    
    <summary type="html">
    
      Hexo默认使用marked.js去解析我们写的markdown，以前用的就很不爽，解析的效果跟atom里预览效果不一致，本来想换个引擎，无奈有一些老的博文需要调整，索性改一下marked.js的解析方法。
    
    </summary>
    
      <category term="blog" scheme="http://miclee.site/categories/blog/"/>
    
    
      <category term="blog" scheme="http://miclee.site/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Python下划线使用</title>
    <link href="http://miclee.site/2017/04/20/Python%E4%B8%8B%E5%88%92%E7%BA%BF%E4%BD%BF%E7%94%A8/"/>
    <id>http://miclee.site/2017/04/20/Python下划线使用/</id>
    <published>2017-04-20T05:43:52.000Z</published>
    <updated>2017-04-20T09:03:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 在 python 中，下划线命名规则往往令初学者相当疑惑：单下划线、双下划线、双下划线还分前后...那它们的作用与使用场景到底有何区别呢？ </em></strong><br><a id="more"></a></p><hr><h2 id="单下划线（-）"><a href="#单下划线（-）" class="headerlink" title="单下划线（_）"></a>单下划线（_）</h2><p>通常情况下，会在以下3种场景中使用：</p><ol><li><p>在解释器中：在这种情况下，‘_‘代表交互式解释器会话中上一条执行的语句的结果。这种用法首先被标准CPython解释器采用，然后其他类型的解释器也先后采用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>_ Traceback (most recent call last):</span><br><span class="line">File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">'_'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_</span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'alright!'</span> <span class="keyword">if</span> _ <span class="keyword">else</span> <span class="string">':('</span></span><br><span class="line"><span class="string">'alright!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_</span><br><span class="line"><span class="string">'alright!'</span></span><br></pre></td></tr></table></figure></li><li><p>作为一个名称：这与上面一点稍微有些联系，此时‘<em>‘作为临时性的名称使用。这样，当其他人阅读你的代码时将会知道，你分配了一个特定的名称，但是并不会在后面再次用到该名称。例如，下面的例子中，你可能对循环计数中的实际值并不感兴趣，此时就可以使用‘</em>‘。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">42</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">    do_something()</span><br></pre></td></tr></table></figure></li><li><p>国际化：也许你也曾看到‘_‘会被作为一个函数来使用。这种情况下，它通常用于实现国际化和本地化字符串之间翻译查找的函数名称，这似乎源自并遵循相应的C约定。例如，在Django文档‘转换‘章节中，你将能看到如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.translation <span class="keyword">import</span> ugettext <span class="keyword">as</span> _</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span><span class="params">(request)</span>:</span></span><br><span class="line">output = _(<span class="string">"Welcome to my site."</span>)</span><br><span class="line"><span class="keyword">return</span> HttpResponse(output)</span><br></pre></td></tr></table></figure></li></ol><p>可以发现，场景二和场景三中的使用方法可能会相互冲突，所以我们需要避免在使用”<em>“作为国际化查找转换功能的代码块中同时使用‘</em>‘作为临时名称。</p><h2 id="名称前的单下划线（如：-shahriar）"><a href="#名称前的单下划线（如：-shahriar）" class="headerlink" title="名称前的单下划线（如：_shahriar）"></a>名称前的单下划线（如：_shahriar）</h2><p>程序员使用名称前的单下划线，用于指定该名称属性为‘私有‘。这有点类似于惯例，为了使其他人（或你自己）使用这些代码时将会知道以‘_‘开头的名称只供内部使用。正如Python文档中所述：</p><p>以下划线‘_‘为前缀的名称（如_spam）应该被视为API中非公开的部分（不管是函数、方法还是数据成员）。此时，应该将它们看作是一种实现细节，在修改它们时无需对外部通知。</p><p>正如上面所说，这确实类似一种惯例，因为它对解释器来说确实有一定的意义，如果你写了代码‘from &lt;模块/包名&gt; import *‘，那么以‘_‘开头的名称都不会被导入，除非模块或包中的‘<strong>all</strong>‘列表显式地包含了它们。了解更多请查看 <a href="https://shahriar.svbtle.com/importing-star-in-python" target="_blank" rel="noopener">Importing * in Python</a></p><h2 id="名称前的双下划线（如：-shahriar）"><a href="#名称前的双下划线（如：-shahriar）" class="headerlink" title="名称前的双下划线（如：__shahriar）"></a>名称前的双下划线（如：__shahriar）</h2><p>名称（具体为一个方法名）前双下划线（<strong>）的用法并不是一种惯例，对解释器来说它有特定的意义。Python中的这种用法是为了避免与子类定义的名称冲突。Python文档指出，‘</strong>spam‘这种形式（至少两个前导下划线，最多一个后续下划线）的任何标识符将会被‘_classname__spam‘这种形式原文取代，在这里‘classname‘是去掉前导下划线的当前类名。例如下面的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">_internal_use</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">__method_name</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(A())</span><br><span class="line">[<span class="string">'_A__method_name'</span>, ..., <span class="string">'_internal_use'</span>]</span><br></pre></td></tr></table></figure></p><p>正如所预料的，‘_internal_use‘并未改变，而‘<strong>method_name‘却被变成了‘_ClassName</strong>method_name‘。此时，如果你创建A的一个子类B，那么你将不能轻易地覆写A中的方法‘__method_name‘。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">__method_name</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(B())</span><br><span class="line">[<span class="string">'_A__method_name'</span>, <span class="string">'_B__method_name'</span>, ..., <span class="string">'_internal_use'</span>]</span><br></pre></td></tr></table></figure><p>通常用作类的私有成员</p><h2 id="名称前后的双下划线（如：init）"><a href="#名称前后的双下划线（如：init）" class="headerlink" title="名称前后的双下划线（如：init）"></a>名称前后的双下划线（如：<strong>init</strong>）</h2><p>这种用法表示Python中特殊的方法名。其实，这只是一种惯例，对Python系统来说，这将确保不会与用户自定义的名称冲突。通常，你将会覆写这些方法，并在里面实现你所需要的功能，以便Python调用它们。例如，当定义一个类时，你经常会覆写‘<strong>init</strong>‘方法。</p><p>双下划线开头双下划线结尾的是一些 Python 的‘魔术‘对象，如类成员的 <strong>init</strong>、<strong>del</strong>、<strong>add</strong>、<strong>getitem</strong> 等，以及全局的 <strong>file</strong>、<strong>name</strong> 等。 Python 官方推荐永远不要将这样的命名方式应用于自己的变量或函数，而是按照文档说明来使用。虽然你也可以编写自己的特殊方法名，但不要这样做。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__mine__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(C)</span><br><span class="line"><span class="meta">... </span>[..., <span class="string">'__mine__'</span>, ...]</span><br></pre></td></tr></table></figure><h2 id="用-all-暴露接口"><a href="#用-all-暴露接口" class="headerlink" title="用 all 暴露接口"></a>用 <strong>all</strong> 暴露接口</h2><p>Python 可以在模块级别暴露接口：</p><p><strong>all</strong> = [“foo”, “bar”]</p><p>很多时候这么做还是很有好处的……</p><p>提供了哪些是公开接口的约定</p><p>不像 Ruby 或者 Java，Python 没有语言原生的可见性控制，而是靠一套需要大家自觉遵守的‘约定‘下工作。比如下划线开头的应该对外部不可见。同样，<strong>all</strong> 也是对于模块公开接口的一种约定，比起下划线，<strong>all</strong> 提供了暴露接口用的‘白名单‘。一些不以下划线开头的变量（比如从其他地方 import 到当前模块的成员）可以同样被排除出去。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Python 用下划线作为变量前缀和后缀指定特殊变量。</p><ul><li>_xxx     不能用’from module import *‘导入</li><li><strong>xxx</strong>  系统定义名字</li><li>__xxx    类中的私有变量名</li></ul><p>_xxx 被看作是‘私有的‘，在模块或类外不可以使用。当变量是私有的时候，用_xxx 来表示变量是很好的习惯。</p><p><strong>xxx</strong> 对Python 来说有特殊含义，对于普通的变量应当避免这种命名风格。</p><p>__xxx 是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。</p><h2 id="PEP规范"><a href="#PEP规范" class="headerlink" title="PEP规范"></a>PEP规范</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PEP-0008:</span><br><span class="line"></span><br><span class="line">In addition, the following special forms using leading or trailing underscores are recognized (these can generally be combined with any case convention):</span><br><span class="line"></span><br><span class="line"><span class="code">    - _single_leading_underscore: weak "internal use" indicator. E.g. "from M import \*" does not import objects whose name starts with an underscore.</span></span><br><span class="line"></span><br><span class="line"><span class="code">    - single_trailing_underscore_: used by convention to avoid conflicts with Python keyword, e.g.</span></span><br><span class="line"></span><br><span class="line"><span class="code">      Tkinter.Toplevel(master, class_='ClassName')</span></span><br><span class="line"></span><br><span class="line"><span class="code">    - __double_leading_underscore: when naming a class attribute, invokes name mangling (inside class FooBar, __boo becomes _FooBar__boo; see below).</span></span><br><span class="line"></span><br><span class="line"><span class="code">    - __double_leading_and_trailing_underscore__: "magic" objects or attributes that live in user-controlled namespaces. E.g. __init__,</span></span><br><span class="line"><span class="code">      __import__ or __file__. Never invent such names; only use them as documented.</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      在 python 中，下划线命名规则往往令初学者相当疑惑：单下划线、双下划线、双下划线还分前后...那它们的作用与使用场景到底有何区别呢？
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Java keytool</title>
    <link href="http://miclee.site/2017/04/19/Java_keytool/"/>
    <id>http://miclee.site/2017/04/19/Java_keytool/</id>
    <published>2017-04-19T09:47:51.000Z</published>
    <updated>2017-04-19T10:18:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> Keytool是一个Java数据证书的管理工具，它使用户能够管理自己的公钥/私钥对及相关证书，用于（通过数字签名）自我认证（用户向别的用户/服务认证自己）或数据完整性以及认证服务。它还允许用户储存他们的通信对等者的公钥（以证书形式）。Keytool将密钥（key）和证书（certificates）存在一个称为秘钥仓库(keystore)的文件中。 </em></strong><br><a id="more"></a></p><hr><p>在keystore里，包含两种数据：</p><ul><li><p>密钥实体（Key entity）<br>每项存放极为敏感的加密密钥信息，这种信息以一种受保护的格式储存以防止未授权的访问。通常，储存在这类项中的密钥是机密密钥，或是伴有用于认证相应公钥用的证书“链”的私钥。keytool 和 jarsigner 工具只处理后一类型的项，即私钥及其关联的证书链。</p></li><li><p>可信任的证书实体（trusted certificate entries）<br>每项包含一个属于另一团体的公钥证书。它之所以叫做“可信任的证书”，是因为密钥仓库的拥有者相信证书中的公钥确实属于证书“主体”（拥有者）识别的身份。证书签发人通过对证书签名来保证这点。</p></li></ul><h2 id="生成keystore"><a href="#生成keystore" class="headerlink" title="生成keystore"></a>生成keystore</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -<span class="built_in">alias</span> miclee -keyalg RSA -validity <span class="number">1000</span> -keystore miclee.keystore</span><br></pre></td></tr></table></figure><h2 id="查看证书"><a href="#查看证书" class="headerlink" title="查看证书"></a>查看证书</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -<span class="type">list</span> -keystore miclee.keystore -storepass <span class="number">123456</span> -v</span><br></pre></td></tr></table></figure><h2 id="导出证书（只能导出公钥）"><a href="#导出证书（只能导出公钥）" class="headerlink" title="导出证书（只能导出公钥）"></a>导出证书（只能导出公钥）</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -exportcert -alias miclee -keystore miclee<span class="selector-class">.keystore</span> -file miclee<span class="selector-class">.crt</span> -storepass <span class="number">123456</span></span><br></pre></td></tr></table></figure><p>导出的miclee.crt为二进制格式，如果想要ASCII格式，请参考博文：<a href="http://miclee.cn/2017/04/19/certificate/" target="_blank" rel="noopener">安全证书</a></p><h2 id="查看导出的证书"><a href="#查看导出的证书" class="headerlink" title="查看导出的证书"></a>查看导出的证书</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -printcert -<span class="built_in">file</span> miclee.crt</span><br></pre></td></tr></table></figure><h2 id="证书条目的删除"><a href="#证书条目的删除" class="headerlink" title="证书条目的删除"></a>证书条目的删除</h2><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -<span class="keyword">delete</span> -<span class="keyword">alias</span> miclee -keystore miclee.keystore -storepass <span class="number">123456</span></span><br></pre></td></tr></table></figure><h2 id="证书条目口令的修改"><a href="#证书条目口令的修改" class="headerlink" title="证书条目口令的修改"></a>证书条目口令的修改</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -keypasswd -alias miclee -keypass <span class="number">123456</span> -new <span class="number">654321</span> -keystore miclee.keystore -storepass <span class="number">123456</span></span><br></pre></td></tr></table></figure><h2 id="keystore口令的修改"><a href="#keystore口令的修改" class="headerlink" title="keystore口令的修改"></a>keystore口令的修改</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -storepasswd -keystore miclee.keystore -storepass <span class="number">123456</span> -new <span class="number">654321</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Keytool是一个Java数据证书的管理工具，它使用户能够管理自己的公钥/私钥对及相关证书，用于（通过数字签名）自我认证（用户向别的用户/服务认证自己）或数据完整性以及认证服务。它还允许用户储存他们的通信对等者的公钥（以证书形式）。Keytool将密钥（key）和证书（certificates）存在一个称为秘钥仓库(keystore)的文件中。
    
    </summary>
    
      <category term="加密技术" scheme="http://miclee.site/categories/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="加密技术" scheme="http://miclee.site/tags/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>安全证书</title>
    <link href="http://miclee.site/2017/04/19/certificate/"/>
    <id>http://miclee.site/2017/04/19/certificate/</id>
    <published>2017-04-19T09:09:27.000Z</published>
    <updated>2017-04-19T10:25:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 证书、标准、格式、转换方式 </em></strong><br><a id="more"></a></p><hr><h2 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h2><p>SSL - Secure Sockets Layer，现在应该叫”TLS”，但由于习惯问题，我们还是叫”SSL”比较多.http协议默认情况下是不加密内容的，这样就很可能在内容传播的时候被别人监听到，对于安全性要求较高的场合，必须要加密，https就是带加密的http协议，而https的加密是基于SSL的，它执行的是一个比较下层的加密，也就是说，在加密前，你的服务器程序在干嘛，加密后也一样在干嘛，不用动，这个加密对用户和开发者来说都是透明的。</p><h2 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h2><p>OpenSSL - 简单地说，OpenSSL是SSL的一个实现，SSL只是一种规范.理论上来说，SSL这种规范是安全的，目前的技术水平很难破解，但SSL的实现就可能有些漏洞，如著名的”心脏出血”.OpenSSL还提供了一大堆强大的工具软件，强大到90%我们都用不到.</p><h2 id="证书标准-X-509"><a href="#证书标准-X-509" class="headerlink" title="证书标准-X.509"></a>证书标准-X.509</h2><p>X.509是常见通用的证书标准，主要定义了证书中应该包含哪些内容。所有的证书都符合为Public Key<br>Infrastructure (PKI) 制定的 ITU-T X509 国际标准。其详情可以参考RFC5280，SSL使用的就是这种证书标准。</p><h2 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h2><ul><li><strong>PEM - Privacy Enhanced Mail</strong><br>PEM格式通常用于数字证书认证机构（Certificate Authorities，CA）。内容为Base64编码的ASCII码文件，有类似”—–BEGIN CERTIFICATE—–” 和 “—–END CERTIFICATE—–”的头尾标记。服务器认证证书，中级认证证书和私钥都可以储存为PEM格式（认证证书其实就是公钥）。Apache和*NIX服务器偏向于使用这种编码格式。</li></ul><p>常用扩展名：.pem | .crt | .cer | .key</p><p>查看PEM格式证书的信息：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -<span class="keyword">in</span> certificate<span class="selector-class">.pem</span> -text -noout</span><br></pre></td></tr></table></figure></p><ul><li><strong>DER - Distinguished Encoding Rules</strong><br>DER格式与PEM不同之处在于其使用二进制而不是Base64编码的ASCII。所有类型的认证证书和私钥都可以存储为DER格式。Java和Windows服务器偏向于使用这种编码格式。</li></ul><p>常用扩展名：.der | .cer</p><p>查看DER格式证书的信息：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -<span class="keyword">in</span> certificate<span class="selector-class">.der</span> -inform der -text -noout</span><br></pre></td></tr></table></figure></p><ul><li><strong>PKCS - Public-Key Cryptography Standards</strong><br>PKCS是由 RSA 实验室与其它安全系统开发商为促进公钥密码的发展而制订的一系列标准，PKCS 目前共发布过 15 个标准。 常用的有：<ul><li>PKCS#7 Cryptographic Message Syntax Standard</li><li>PKCS#10 Certification Request Standard</li><li>PKCS#12 Personal Information Exchange Syntax Standard</li></ul></li></ul><h2 id="转换方式"><a href="#转换方式" class="headerlink" title="转换方式"></a>转换方式</h2><ul><li><p><strong>PEM <-> DER</-></strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -outform der -<span class="keyword">in</span> certificate<span class="selector-class">.pem</span> -out certificate.der</span><br><span class="line"></span><br><span class="line">openssl x509 -inform der -<span class="keyword">in</span> certificate<span class="selector-class">.cer</span> -out certificate.pem</span><br></pre></td></tr></table></figure></li><li><p><strong>PEM <-> P7B</-></strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl crl2pkcs7 -nocrl -certfile certificate<span class="selector-class">.cer</span> -out certificate<span class="selector-class">.p7b</span> -certfile CACert.cer</span><br><span class="line"></span><br><span class="line">openssl pkcs7 -print_certs -<span class="keyword">in</span> certificate<span class="selector-class">.p7b</span> -out certificate.cer</span><br></pre></td></tr></table></figure></li><li><p><strong>PEM <-> PFX</-></strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -export -out certificate<span class="selector-class">.pfx</span> -inkey privateKey<span class="selector-class">.key</span> -<span class="keyword">in</span> certificate<span class="selector-class">.crt</span> -certfile CACert.crt</span><br><span class="line"></span><br><span class="line">openssl pkcs12 -<span class="keyword">in</span> certificate<span class="selector-class">.pfx</span> -out certificate<span class="selector-class">.cer</span> -nodes</span><br></pre></td></tr></table></figure></li></ul><p>PXF转PEM后certificate.cer文件包含认证证书和私钥，需要把它们分开存储才能使用。</p><p>要转换KEY文件也类似，只不过把x509换成rsa，要转CSR的话，把x509换成req</p><h2 id="证书获取"><a href="#证书获取" class="headerlink" title="证书获取"></a>证书获取</h2><ul><li><strong>向权威证书颁发机构申请证书</strong><br>用这命令生成一个csr:<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">openssl</span> <span class="selector-tag">req</span> <span class="selector-tag">-newkey</span> <span class="selector-tag">rsa</span><span class="selector-pseudo">:2048</span> <span class="selector-tag">-new</span> <span class="selector-tag">-nodes</span> <span class="selector-tag">-keyout</span> <span class="selector-tag">my</span><span class="selector-class">.key</span> <span class="selector-tag">-out</span> <span class="selector-tag">my</span><span class="selector-class">.csr</span></span><br></pre></td></tr></table></figure></li></ul><p>把csr交给权威证书颁发机构，权威证书颁发机构对此进行签名，完成.保留好csr，当权威证书颁发机构颁发的证书过期的时候，你还可以用同样的csr来申请新的证书，key保持不变。</p><ul><li><strong>生成自签名的证书</strong><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">openssl</span> <span class="selector-tag">req</span> <span class="selector-tag">-newkey</span> <span class="selector-tag">rsa</span><span class="selector-pseudo">:2048</span> <span class="selector-tag">-new</span> <span class="selector-tag">-nodes</span> <span class="selector-tag">-x509</span> <span class="selector-tag">-days</span> 3650 <span class="selector-tag">-keyout</span> <span class="selector-tag">key</span><span class="selector-class">.pem</span> <span class="selector-tag">-out</span> <span class="selector-tag">cert</span><span class="selector-class">.pem</span></span><br></pre></td></tr></table></figure></li></ul><p>在生成证书的过程中会要你填一堆的东西，其实真正要填的只有Common Name，通常填写你服务器的域名，如”yourcompany.com”，或者你服务器的IP地址，其它都可以留空的.<br>生产环境中还是不要使用自签的证书，否则浏览器会不认，或者如果你是企业应用的话能够强制让用户的浏览器接受你的自签证书也行.向权威机构要证书通常是要钱的，但现在也有免费的，仅仅需要一个简单的域名验证即可。有兴趣的话查查”沃通数字证书”。</p>]]></content>
    
    <summary type="html">
    
      证书、标准、格式、转换方式
    
    </summary>
    
      <category term="加密技术" scheme="http://miclee.site/categories/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="加密技术" scheme="http://miclee.site/tags/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Python之禅</title>
    <link href="http://miclee.site/2017/04/19/Python%E4%B9%8B%E7%A6%85/"/>
    <id>http://miclee.site/2017/04/19/Python之禅/</id>
    <published>2017-04-19T06:41:37.000Z</published>
    <updated>2017-05-12T09:49:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 有人说，要想学好一门编程语言，你就需要接受这门语言的哲学。那么如果你想精通Python，就需要践行Python背后的设计哲学。 </em></strong><br><a id="more"></a></p><hr><h2 id="python哲学"><a href="#python哲学" class="headerlink" title="python哲学"></a>python哲学</h2><p>Python之所以与众不同，在于它强调一种哲学理念，用黑字表示强调吧：</p><p><strong>Python的设计哲学是“优雅”、“明确”、“简单”。</strong></p><p>Python开发者的哲学是“用一种方法，最好是只有一种方法来做一件事。在设计Python语言时，如果面临多种选择，Python开发者一般会拒绝花俏的语法，而选择明确没有或者很少有歧义的语法。由于这种设计观念的差异，Python源代码通常具备更好的可读性，并且能够支撑大规模的软件开发。这些准则被称为Python格言。  </p><h2 id="The-Zen-of-Python"><a href="#The-Zen-of-Python" class="headerlink" title="The Zen of Python"></a>The Zen of Python</h2><p>Python之父是荷兰人Guido van Rossum，被誉为历史上最伟大的12名程序员之一。他在设计Python时，目的是设计出一种优美而强大，提供给非专业程序设计师使用的语言，同时采取开放策略，使Python能够完美结合如C 、 C++和Java等其他语言。Guido对python设计之初提出了规范和风格，名为“Pythonic”，它指的是以Python的方式去编写代码、组织逻辑和对象行为。而对Python哲学的最好阐述，莫过于核心开发者Tim Peters所总结的“Python之禅”（The Zen of Python）了。启动Python解释器后，输入import this就可以看到全文了。</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import this</span><br><span class="line"></span><br><span class="line">The Zen <span class="keyword">of</span> Python, <span class="keyword">by</span> Tim Peters</span><br><span class="line"></span><br><span class="line">Beautiful <span class="keyword">is</span> better than ugly.</span><br><span class="line"><span class="keyword">Explicit</span> <span class="keyword">is</span> better than implicit.</span><br><span class="line">Simple <span class="keyword">is</span> better than complex.</span><br><span class="line">Complex <span class="keyword">is</span> better than complicated.</span><br><span class="line">Flat <span class="keyword">is</span> better than nested.</span><br><span class="line">Sparse <span class="keyword">is</span> better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren<span class="comment">'t special enough to break the rules.</span></span><br><span class="line">Although practicality beats purity.</span><br><span class="line">Errors should never pass silently.</span><br><span class="line">Unless explicitly silenced.</span><br><span class="line"><span class="keyword">In</span> the face <span class="keyword">of</span> ambiguity, refuse the temptation <span class="keyword">to</span> guess.</span><br><span class="line">There should be one-- <span class="keyword">and</span> preferably only one --obvious way <span class="keyword">to</span> <span class="keyword">do</span> it.</span><br><span class="line">Although that way may <span class="keyword">not</span> be obvious at first unless you<span class="comment">'re Dutch.</span></span><br><span class="line">Now <span class="keyword">is</span> better than never.</span><br><span class="line">Although never <span class="keyword">is</span> often better than *right* now.</span><br><span class="line"><span class="keyword">If</span> the implementation <span class="keyword">is</span> hard <span class="keyword">to</span> explain, it<span class="comment">'s a bad idea.</span></span><br><span class="line"><span class="keyword">If</span> the implementation <span class="keyword">is</span> easy <span class="keyword">to</span> explain, it may be a good idea.</span><br><span class="line">Namespaces are one honking great idea -- <span class="keyword">let</span><span class="comment">'s do more of those!</span></span><br></pre></td></tr></table></figure><h2 id="Python之禅"><a href="#Python之禅" class="headerlink" title="Python之禅"></a>Python之禅</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">优美胜于丑陋，</span><br><span class="line">明了胜于晦涩。</span><br><span class="line">简洁胜于复杂，</span><br><span class="line">复杂胜于凌乱。</span><br><span class="line">扁平胜于嵌套，</span><br><span class="line">稀疏胜于密繁。</span><br><span class="line">可读性很重要！</span><br><span class="line">即便假借特例的实用性之名，也不可违背这些规则。</span><br><span class="line">不要放过一切错误，除非错误本身需要以忽略对待。</span><br><span class="line">不确定面前，我们应抵挡妄加猜测的引诱。</span><br><span class="line">应该有一种，也但愿只有这一种是显而易见的解决之道。</span><br><span class="line">万事开头难，除非荷兰人。</span><br><span class="line">做好过不做，而不假思索就动手还不如不做。</span><br><span class="line">如果某个实现无法很好阐释，那么它肯定是一个糟糕的办法；</span><br><span class="line">如果某个实现很容易说清楚，那么它可能就是个不错的方案。</span><br><span class="line">命名空间是个绝妙的发明——对此我们应多多益善！</span><br></pre></td></tr></table></figure><h2 id="蛇宗三字经"><a href="#蛇宗三字经" class="headerlink" title="蛇宗三字经"></a>蛇宗三字经</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">美胜丑</span><br><span class="line">明胜暗</span><br><span class="line">简胜复</span><br><span class="line">复胜杂</span><br><span class="line">浅胜深</span><br><span class="line">疏胜密</span><br><span class="line">辞达意</span><br><span class="line">不逾矩</span><br><span class="line">弃至清</span><br><span class="line">无阴差</span><br><span class="line">有阳错</span><br><span class="line">拒疑数</span><br><span class="line">求完一</span><br><span class="line">虽不至，向往之</span><br><span class="line">敏于行</span><br><span class="line">戒莽撞</span><br><span class="line">差难言</span><br><span class="line">好易说</span><br><span class="line">每师出，多有名</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      有人说，要想学好一门编程语言，你就需要接受这门语言的哲学。那么如果你想精通Python，就需要践行Python背后的设计哲学。
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>virtualenvwrapper设置</title>
    <link href="http://miclee.site/2017/04/18/py_virtualenvwrapper/"/>
    <id>http://miclee.site/2017/04/18/py_virtualenvwrapper/</id>
    <published>2017-04-18T11:16:24.000Z</published>
    <updated>2017-04-19T05:17:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> virtualenv 是一个可以在同一计算机中隔离多个python版本的工具。有时，两个不同的项目可能需要不同版本的python，如 python2.6.6 / python3.0 ，但是如果都装到一起，经常会导致问题。所以需要一个工具能够将这两种或几种不同版本的环境隔离开来，需要哪个版本就切换到哪个版本做为默认版本。virtualenv 既是满足这个需求的工具。它能够用于创建独立的Python环境，多个Python相互独立，互不影响。 </em></strong><br><a id="more"></a></p><hr><p>virtualenvwrapper是virtualenv的扩展管理包，用于更方便管理虚拟环境，它可以做：</p><ul><li>将所有虚拟环境整合在一个目录下</li><li>管理（新增，删除，复制）虚拟环境</li><li>切换虚拟环境</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> virtualenv</span><br><span class="line">pip <span class="keyword">install</span> virtualenvwrapper</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在 ~/.bash_profile 文件里添加以下配置：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">WORKON_HOME</span>=~/.virtualenvs</span><br><span class="line">source /usr/local/bin/virtualenvwrapper.sh</span><br></pre></td></tr></table></figure><p>别忘了执行 source .bash_profile</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>所有的命令可使用：virtualenvwrapper –help 进行查看，这里列出几个常用的：</p><ul><li>创建基本环境：mkvirtualenv [环境名]</li><li>删除环境：rmvirtualenv [环境名]</li><li>激活环境：workon [环境名]</li><li>退出环境：deactivate</li><li>列出所有环境：workon 或者 lsvirtualenv -b</li></ul><h2 id="安装Python3-环境"><a href="#安装Python3-环境" class="headerlink" title="安装Python3 环境"></a>安装Python3 环境</h2><p>先安装Python3：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>Python3</span><br></pre></td></tr></table></figure><p>创建环境：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkvirtualenv --python=<span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>python3 envname</span><br></pre></td></tr></table></figure><p>查看环境：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">workon</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      virtualenv 是一个可以在同一计算机中隔离多个python版本的工具。有时，两个不同的项目可能需要不同版本的python，如 python2.6.6 / python3.0 ，但是如果都装到一起，经常会导致问题。所以需要一个工具能够将这两种或几种不同版本的环境隔离开来，需要哪个版本就切换到哪个版本做为默认版本。virtualenv 既是满足这个需求的工具。它能够用于创建独立的Python环境，多个Python相互独立，互不影响。
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
</feed>
