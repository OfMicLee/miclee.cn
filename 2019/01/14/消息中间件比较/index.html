<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>消息中间件比较 | MicLee&#39;s Bolg</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一发一存一消费，没有最好的消息队列中间件(简称消息中间件)，只有最合适的消息中间件。">
<meta name="keywords" content="分布式">
<meta property="og:type" content="article">
<meta property="og:title" content="消息中间件比较">
<meta property="og:url" content="http://miclee.site/2019/01/14/消息中间件比较/index.html">
<meta property="og:site_name" content="MicLee&#39;s Bolg">
<meta property="og:description" content="一发一存一消费，没有最好的消息队列中间件(简称消息中间件)，只有最合适的消息中间件。">
<meta property="og:locale" content="zh">
<meta property="og:image" content="https://raw.githubusercontent.com/ofmiclee/img-hosting/master/distributed/MQvs1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ofmiclee/img-hosting/master/distributed/MQvs2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ofmiclee/img-hosting/master/distributed/MQvs3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ofmiclee/img-hosting/master/distributed/MQvs4.png">
<meta property="og:updated_time" content="2019-01-14T10:37:33.489Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="消息中间件比较">
<meta name="twitter:description" content="一发一存一消费，没有最好的消息队列中间件(简称消息中间件)，只有最合适的消息中间件。">
<meta name="twitter:image" content="https://raw.githubusercontent.com/ofmiclee/img-hosting/master/distributed/MQvs1.png">
  
    <link rel="alternative" href="/atom.xml" title="MicLee&#39;s Bolg" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">MicLee&#39;s Bolg</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">道生一 一生二 二生三 三生万物</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://miclee.site"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-消息中间件比较" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/14/消息中间件比较/" class="article-date">
  <time datetime="2019-01-14T09:56:49.000Z" itemprop="datePublished">2019-01-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring-Cloud/">Spring Cloud</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      消息中间件比较
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong><em> 一发一存一消费，没有最好的消息队列中间件(简称消息中间件)，只有最合适的消息中间件。 </em></strong><br><a id="more"></a></p>
<hr>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>非实时性<br>当不需要立即获得结果，但是并发量又需要进行控制的时候，差不多就是需要使用消息队列的时候。主要解决了应用耦合、异步处理、流量削锋等问题。</li>
<li>应用耦合<br>多应用间通过消息队列对同一消息进行处理，避免调用接口失败导致整个过程失败；（如：订单-&gt;库存）</li>
<li>异步处理<br>多应用对消息队列中同一消息进行处理，应用间并发处理消息，相比串行处理，减少处理时间；(点对多场景，广播场景(注册发短信，发邮件)等等)</li>
<li>限流削峰<br>应用于秒杀或抢购活动中，避免流量过大导致应用系统挂掉的情况；</li>
<li>消息驱动的系统<br>系统分为消息队列、消息生产者、消息消费者，生产者负责产生消息，消费者(可能有多个)负责对消息进行处理；分工处理(各自对应相应的队列)，灵活应用(收到就处理/定时处理)</li>
</ul>
<h3 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h3><ul>
<li>点对点<br>每个消息只有一个消费者（Consumer），不可重复消费(一旦被消费，消息就不再在消息队列中)</li>
<li><p>发布/订阅<br>微信公众号(Topic)，大伙(订阅者)订阅关注之后，微信公众号运营平台(发布者)发布信息后，大伙微信就都收到信息了，这里其实还分pull/push的。一个是主动推送，一个是被动拉取<br>基于发布/订阅模式做扩展就是横向扩展，多个队列及消费分组订阅(提高消费能力)</p>
</li>
<li><p>pull<br>主动权在于消费方，优点是按需消费(吃自助餐，能吃多少拿多少)，而且服务端队列堆积的消息处理也相对简单(不用记录状态啊，状态都消费端)；缺点就是消息延迟(不知道啥时候去拉取更新)，这时候有小伙伴会问，那为啥不叫服务端通知一下呢(有句话叫不在其位不谋其政，服务端通知必然要记录通知状态和增加之间的通信带宽；当然也可以根据实际情况来选择和push组合起来用(男女搭配干活不累嘛)来提高消息的实时性)</p>
</li>
<li>push<br>主动权就在服务方了，优点是实时性高，服务端可以统一管理来进行负载，不过也容易导致慢消费(就得考虑消费方受不受得了，毕竟你说你了解，但也只有对方才清楚你有多了解)；缺点就是发送消息的状态是集中式管理，压力大啊(要分发消息还要记录状态还要做备份，又当爹来又当妈，你说累不累)<br>对于顺序消息，这种场景有限且成本太高的方式就得慎重考虑了，对那种全局有序但允许出现小误差的场景(日志推送)，pull模式就非常适合了(所以说kafka为啥常用于日志处理、大数据等方面)，要问为什么？自己去领悟</li>
</ul>
<h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><ol>
<li>功能<br>这个就多了，优先级队列、延迟队列(划分不同的延迟队列来避免重新排序消耗性能，缺点嘛自己悟)、死信队列(放没有推送成功的)、消费模式(pull/push)、广播消费、消息回溯(可追溯嘛，不然被卖了都不知道是谁)、消息堆积+持久化、消息追踪(链路条，方便定位)、消息过滤(根据规则过滤啊，不同类别消息发送到不同topic)、多协议支持(通用性)、跨语言支持(流行程度)、流量控制(嘿嘿嘿，上面有)、消息顺序性(还要再说一遍？)、安全机制(身份认证，权限认证(读写))、消息幂等性(承诺知道不，答应人家的事就一定要做到)、事务性消息(不想说)等</li>
<li>性能<br>一般是指其吞吐量(统一大小的消息体和不同大小的消息体生产和消耗能力)，性能和功能很多时候是相悖的，鱼和熊掌不可兼得。</li>
<li>高可靠、高可用<br>先说可靠，主要在于消息的持久化这一块(消息只要写入就一定会被消费，不会因为故障导致数据丢失(这个就很好测试出来了吧))。如果是从系统的角度来看就得从整体的维度去衡量了(不能单单只靠消息中间件本身，要从生产端、服务端、消费端三个维度去保障)。<br>再说可用，主要在于一个是对外部服务的依赖性(像kafka依赖zookeeper)，依赖也分强依赖和弱依赖，一个在于本身的备份机制所带来的保障性(像主从复制这种备份啊，增加多个slave来加强保障同时也会存在资源浪费，大部分时候Slave可能是空闲的)。</li>
<li>运维<br>通常有审核评估啊、监控啊、报警提醒啊、容灾啊、扩容啊、升级部署等等，一方面看中间件支撑的维度，一方面就看结合自动化运维的难易度<br>社区力度及生态发展：这个好理解吧，使用开源框架最开始基本上愉快的奔跑，但时不时的总会掉坑里，能不能爬出来一方面看自身的实力，一方面就看社区的力度了</li>
<li>成本<br>尽量贴合团队自身的技术栈体系，让一个C栈的团队去深挖zeroMQ总比scala编写kafka要容易的多<br><img src="https://raw.githubusercontent.com/ofmiclee/img-hosting/master/distributed/MQvs1.png" alt="">    </li>
</ol>
<h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p>基于erlang开发，是采用Erlang语言实现的AMQP协议的消息中间件，最初起源于金融系统，用于在分布式系统中存储转发消息。RabbitMQ发展到今天，被越来越多的人认可，这和它在可靠性、可用性、扩展性、功能丰富等方面的卓越表现是分不开的。</p>
<ul>
<li><p>优点：<br>由于erlang语言的特性，mq性能较好，高并发；<br>健壮、稳定、易用、跨平台、支持多种语言、文档齐全；<br>有消息确认机制和持久化机制，可靠性高；<br>高度可定制的路由；<br>管理界面较丰富，在互联网公司也有较大规模的应用；<br>社区活跃度高；  </p>
</li>
<li><p>缺点：<br>尽管结合erlang语言本身的并发优势，性能较好，但是不利于做二次开发和维护；<br>实现了代理架构，意味着消息在发送到客户端之前可以在中央节点上排队。此特性使得RabbitMQ易于使用和部署，但是使得其运行速度较慢，因为中央节点增加了延迟，消息封装后也比较大；<br>需要学习比较复杂的接口和协议，学习和维护成本较高；  </p>
</li>
</ul>
<h4 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h4><p>基于java开发，是Apache出品的、采用Java语言编写的完全基于JMS1.1规范的面向消息的中间件，为应用程序提供高效的、可扩展的、稳定的和安全的企业级消息通信。不过由于历史原因包袱太重，目前市场份额没有后面三种消息中间件多，其最新架构被命名为Apollo,(京东的消息中间件就是基于activeMQ开发的)</p>
<ul>
<li><p>优点：<br>跨平台(JAVA编写与平台无关有，ActiveMQ几乎可以运行在任何的JVM上)<br>可以用JDBC：可以将数据持久化到数据库<br>支持JMS ：支持JMS的统一接口;<br>支持自动重连；<br>有安全机制：支持基于shiro，jaas等多种安全配置机制，可以对Queue/Topic进行认证和授权<br>监控完善：拥有完善的监控，包括Web Console，JMX，Shell命令行，Jolokia的REST API；<br>界面友善：提供的Web Console可以满足大部分情况，还有很多第三方的组件可以使用，如hawtio；  </p>
</li>
<li><p>缺点：<br>社区活跃度不及RabbitMQ高；<br>会出莫名其妙的问题，会丢失消息；<br>不适合用于上千个队列的应用场景；  </p>
</li>
</ul>
<h4 id="zeroMQ"><a href="#zeroMQ" class="headerlink" title="zeroMQ"></a>zeroMQ</h4><p>基于C开发，号称史上最快的消息队列，基于C语言开发。ZeroMQ是一个消息处理队列库，可在多线程、多内核和主机之间弹性伸缩，虽然大多数时候我们习惯将其归入消息队列家族之中，但是其和前面的几款有着本质的区别，ZeroMQ本身就不是一个消息队列服务器，更像是一组底层网络通讯库，对原有的Socket API上加上一层封装而已。</p>
<ul>
<li><p>优点：<br>号称最快的消息队列系统，尤其针对大吞吐量的需求场景<br>单独部署或集成到应用中使用，不需要安装和运行一个消息服务器或中间件，因为你的应用程序将扮演了这个服务角色<br>能够实现高级/复杂的队列，但是开发人员需要自己组合多种技术框架<br>跨平台，多语言支持<br>可作为Socket通信库使用  </p>
</li>
<li><p>缺点：<br>仅提供非持久性的队列，也就是说如果down机，数据将会丢失</p>
</li>
</ul>
<h4 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h4><p>基于java开发（阿里消息中间件），是阿里开源的消息中间件，目前已经捐献个Apache基金会，它是由Java语言开发的，具备高吞吐量、高可用性、适合大规模分布式系统应用等特点，经历过双11的洗礼，实力不容小觑。</p>
<p><strong>几个重要概念：</strong>  </p>
<ul>
<li>Broker：简单来说就是消息队列服务器实体。  </li>
<li>Exchange：消息交换机，它指定消息按什么规则，路由到哪个队列。</li>
<li>Queue：消息队列载体，每个消息都会被投入到一个或多个队列。</li>
<li>Binding：绑定，它的作用就是把exchange和queue按照路由规则绑定起来。</li>
<li>Routing Key：路由关键字，exchange根据这个关键字进行消息投递。</li>
<li>vhost：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。</li>
<li>producer：消息生产者，就是投递消息的程序。</li>
<li>consumer：消息消费者，就是接受消息的程序。  </li>
<li><p>channel：消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。         </p>
</li>
<li><p>优点：<br>单机支持 1 万以上持久化队列<br>RocketMQ 的所有消息都是持久化的，先写入系统 pagecache(页高速缓冲存储器)，然后刷盘，可以保证内存与磁盘都有一份数据，访问时，直接从内存读取；<br>模型简单，接口易用（JMS 的接口很多场合并不太实用）；<br>性能非常好，可以大量堆积消息在broker(集群中包含一个或多个服务器，这些服务器被称为broker)中；<br>支持多种消费，包括集群消费、广播消费等；<br>各个环节分布式扩展设计，主从HA(高可用性集群)；<br>开发度较活跃，版本更新很快；  </p>
</li>
<li><p>缺点：<br>支持的客户端语言不多，目前是java及c++，其中c++不成熟；<br>RocketMQ社区关注度及成熟度也不及前两者；<br>没有web管理界面，提供了一个CLI(命令行界面)管理工具带来查询、管理和诊断各种问题；<br>没有在 mq 核心中去实现JMS等接口；  </p>
</li>
</ul>
<h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><p>基于Scala和Java开发，起初是由LinkedIn公司采用Scala语言开发的一个分布式、多分区、多副本且基于zookeeper协调的分布式消息系统，现已捐献给Apache基金会。它是一种高吞吐量的分布式发布订阅消息系统，以可水平扩展和高吞吐率而被广泛使用。目前越来越多的开源分布式处理系统如Cloudera、Apache Storm、Spark、Flink等都支持与Kafka集成。  </p>
<p><strong>几个重要概念：</strong></p>
<ul>
<li>Broker：Kafka集群包含一个或多个服务器，这种服务器被称为broker</li>
<li>Topic：每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。</li>
<li>Partition：Parition是物理上的概念，每个Topic包含一个或多个Partition.</li>
<li>Producer：负责发布消息到Kafka broker</li>
<li>Consumer：消息消费者，向Kafka broker读取消息的客户端。  </li>
<li><p>Consumer Group：每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）                </p>
</li>
<li><p>优点：<br>客户端语言丰富，支持java、.net、php、ruby、python、go等多种语言；<br>性能卓越，单机写入TPS约在百万条/秒，消息大小10个字节；<br>提供完全分布式架构, 并有replica机制, 拥有较高的可用性和可靠性, 理论上支持消息无限堆积；<br>支持批量操作；<br>消费者采用Pull方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;<br>有优秀的第三方Kafka Web管理界面Kafka-Manager；<br>在日志领域比较成熟，被多家公司和多个开源项目使用；  </p>
</li>
<li><p>缺点：<br>Kafka单机超过64个队列/分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间变长；<br>使用短轮询方式，实时性取决于轮询间隔时间；<br>消费失败不支持重试；<br>支持消息顺序，但是一台代理宕机后，就会产生消息乱序；<br>社区更新较慢；  </p>
</li>
</ul>
<h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><p>Redis的PUB/SUB机制，即发布-订阅模式。利用的Redis的列表(lists)数据结构。比较好的使用模式是，生产者lpush消息，消费者brpop消息，并设定超时时间，可以减少redis的压力。只有在Redis宕机且数据没有持久化的情况下丢失数据，可以根据业务通过AOF和缩短持久化间隔来保证很高的可靠性，而且也可以通过多个client来提高消费速度。但相对于专业的消息队列来说，该方案消息的状态过于简单(没有状态)，且没有ack机制，消息取出后消费失败依赖于client记录日志或者重新push到队列里面。<br>redis不支持分组(这点很重要，在做负载均衡的时候劣势就体现出来)，不过可以完全当做一个轻量级的队列使用，但redis他爹做了disque，可以去试一试。</p>
<h3 id="RabbitMQ-vs-Kafka"><a href="#RabbitMQ-vs-Kafka" class="headerlink" title="RabbitMQ vs Kafka"></a>RabbitMQ vs Kafka</h3><ul>
<li><p>功能对比：<br><img src="https://raw.githubusercontent.com/ofmiclee/img-hosting/master/distributed/MQvs2.png" alt=""><br><img src="https://raw.githubusercontent.com/ofmiclee/img-hosting/master/distributed/MQvs3.png" alt=""><br><img src="https://raw.githubusercontent.com/ofmiclee/img-hosting/master/distributed/MQvs4.png" alt="">    </p>
</li>
<li><p>应用方面：<br>RabbitMQ,遵循AMQP协议，由内在高并发的erlanng语言开发，用在实时的对可靠性要求比较高的消息传递上。<br>kafka它主要用于处理活跃的流式数据,大数据量的数据处理上。</p>
</li>
<li><p>架构模型方面：<br>RabbitMQ遵循AMQP协议，RabbitMQ的broker由Exchange,Binding,queue组成，其中exchange和binding组成了消息的路由键；客户端Producer通过连接channel和server进行通信，Consumer从queue获取消息进行消费（长连接，queue有消息会推送到consumer端，consumer循环从输入流读取数据）。rabbitMQ以broker为中心；有消息的确认机制。<br>kafka遵从一般的MQ结构，producer，broker，consumer，以consumer为中心，消息的消费信息保存的客户端consumer上，consumer根据消费的点，从broker上批量pull数据；无消息确认机制。</p>
</li>
<li><p>吞吐量：<br>rabbitMQ在吞吐量方面稍逊于kafka，他们的出发点不一样，rabbitMQ支持对消息的可靠的传递，支持事务，不支持批量的操作；基于存储的可靠性的要求存储可以采用内存或者硬盘。<br>kafka具有高的吞吐量，内部采用消息的批量处理，zero-copy机制，数据的存储和获取是本地磁盘顺序批量操作，具有O(1)的复杂度，消息处理的效率很高。</p>
</li>
<li><p>可用性方面：<br>rabbitMQ支持miror(镜像)的queue，主queue失效，miror queue接管。<br>kafka的broker支持主备模式。</p>
</li>
<li><p>集群负载均衡方面：<br>rabbitMQ的负载均衡需要单独的loadbalancer进行支持。<br>kafka采用zookeeper对集群中的broker、consumer进行管理，可以注册topic到zookeeper上；通过zookeeper的协调机制，producer保存对应topic的broker信息，可以随机或者轮询发送到broker上；并且producer可以基于语义指定分片，消息发送到broker的某分片上。</p>
</li>
</ul>
<p>参考链接：<a href="https://juejin.im/post/5b32044ef265da59654c3027" target="_blank" rel="noopener">https://juejin.im/post/5b32044ef265da59654c3027</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://miclee.site/2019/01/14/消息中间件比较/" data-id="cjqw6o3ls008e28s6tgo2tryn" class="article-share-link">Share</a>
      
        <a href="http://miclee.site/2019/01/14/消息中间件比较/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式/">分布式</a></li></ul>

      <span style="color:gray;font-weight:bold">
      本文阅读量&nbsp;<span id="busuanzi_value_page_pv"></span>&nbsp;次
      </span>
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/01/11/分布式事务/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">分布式事务</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">ABOUT ME</h3>
    <div class="widget">
          80后老码农<br>
          Sun认证SCJP工程师<br>
          <br>
          研究领域：<br>
          高并发电商交易型网站设计<br>
          微服务架构<br>
          容器化平台搭建<br>
          DevOps<br>
          机器学习<br>
          <!-- <span id="busuanzi_container_site_uv">
          本站访问量&nbsp;<span id="busuanzi_value_site_pv"></span>&nbsp;次
          </span> -->
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Http/">Http</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Cloud/">Spring Cloud</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-cloud/">Spring cloud</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/blog/">blog</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nodejs/">nodejs</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/react/">react</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tomcat/">tomcat</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/加密技术/">加密技术</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术综合/">技术综合</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/电商交易/">电商交易</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/移动端/">移动端</a><span class="category-list-count">4</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a><span class="archive-list-count">11</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/14/消息中间件比较/">消息中间件比较</a>
          </li>
        
          <li>
            <a href="/2019/01/11/分布式事务/">分布式事务</a>
          </li>
        
          <li>
            <a href="/2018/12/30/无需数据迁移的弹性扩容分片算法/">基于sharding-sphere无需数据迁移的弹性扩容分片算法</a>
          </li>
        
          <li>
            <a href="/2018/12/30/分布式ID/">分布式ID</a>
          </li>
        
          <li>
            <a href="/2018/12/26/电商秒杀场景实现方案/">电商秒杀场景实现方案</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2019 射雕
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <span id="busuanzi_container_site_pv">
            &nbsp;&nbsp;本站总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>&nbsp;次&nbsp;&nbsp;
            &nbsp;&nbsp;本站访客数&nbsp;<span id="busuanzi_value_site_uv"></span>&nbsp;人
            </span>
    	</div>
      	<!-- <div class="footer-right">
          Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      	</div> -->
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'micleewj';
  
  var disqus_url = 'http://miclee.site/2019/01/14/消息中间件比较/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>