<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[MicLee's Bolg]]></title>
  <subtitle><![CDATA[技术创造价值，分享带来快乐]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://miclee.cn/"/>
  <updated>2017-05-15T06:49:50.000Z</updated>
  <id>http://miclee.cn/</id>
  
  <author>
    <name><![CDATA[MicLee]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[RESTful API 设计指南【转】]]></title>
    <link href="http://miclee.cn/2017/05/15/restful-api/"/>
    <id>http://miclee.cn/2017/05/15/restful-api/</id>
    <published>2017-05-15T06:40:15.000Z</published>
    <updated>2017-05-15T06:49:50.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em>  </em></strong><br><a id="more"></a></p>
<hr>
<p>网络应用程序，分为前端和后端两个部分。当前的发展趋势，就是前端设备层出不穷（手机、平板、桌面电脑、其他专用设备……）。<br>因此，必须有一种统一的机制，方便不同的前端设备与后端进行通信。这导致API构架的流行，甚至出现”API First”的设计思想。RESTful API是目前比较成熟的一套互联网应用程序的API设计理论。我以前写过一篇《理解RESTful架构》，探讨如何理解这个概念。<br>今天，我将介绍RESTful API的设计细节，探讨如何设计一套合理、好用的API。我的主要参考了两篇文章（<a href="https://codeplanet.io/principles-good-restful-api-design/" target="_blank" rel="external">1</a>，<a href="https://bourgeois.me/rest/" target="_blank" rel="external">2</a>）。</p>
<h2 id="一、协议"><a href="#一、协议" class="headerlink" title="一、协议"></a>一、协议</h2><p>API与用户的通信协议，总是使用  <a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="external">HTTPs</a> 协议。  </p>
<h2 id="二、域名"><a href="#二、域名" class="headerlink" title="二、域名"></a>二、域名</h2><p>应该尽量将API部署在专用域名之下。<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">https:<span class="comment">//api.example.com</span></div><div class="line">```  </div><div class="line">如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。</div></pre></td></tr></table></figure></p>
<p><a href="https://example.org/api/" target="_blank" rel="external">https://example.org/api/</a><br><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 三、版本（Versioning）</div><div class="line">应该将API的版本号放入URL。</div></pre></td></tr></table></figure></p>
<p><a href="https://api.example.com/v1/" target="_blank" rel="external">https://api.example.com/v1/</a><br><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。</div><div class="line"></div><div class="line">## 四、路径（Endpoint）</div><div class="line">路径又称<span class="string">"终点"</span>（endpoint），表示API的具体网址。</div><div class="line">在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的<span class="string">"集合"</span>（collection），所以API中的名词也应该使用复数。</div><div class="line">举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</div></pre></td></tr></table></figure></p>
<p><a href="https://api.example.com/v1/zoos" target="_blank" rel="external">https://api.example.com/v1/zoos</a><br><a href="https://api.example.com/v1/animals" target="_blank" rel="external">https://api.example.com/v1/animals</a><br><a href="https://api.example.com/v1/employees" target="_blank" rel="external">https://api.example.com/v1/employees</a><br><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 五、HTTP动词</div><div class="line">对于资源的具体操作类型，由HTTP动词表示。</div><div class="line">常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</div></pre></td></tr></table></figure></p>
<p>GET（SELECT）：从服务器取出资源（一项或多项）。<br>POST（CREATE）：在服务器新建一个资源。<br>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。<br>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。<br>DELETE（DELETE）：从服务器删除资源。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">还有两个不常用的HTTP动词。</div></pre></td></tr></table></figure></p>
<p>HEAD：获取资源的元数据。<br>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。<br>下面是一些例子。<br>GET /zoos：列出所有动物园<br>POST /zoos：新建一个动物园<br>GET /zoos/ID：获取某个指定动物园的信息<br>PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）<br>PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）<br>DELETE /zoos/ID：删除某个动物园<br>GET /zoos/ID/animals：列出某个指定动物园的所有动物<br>DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 六、过滤信息（Filtering）</div><div class="line">如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</div><div class="line">下面是一些常见的参数。</div></pre></td></tr></table></figure></p>
<p>?limit=10：指定返回记录的数量<br>?offset=10：指定返回记录的开始位置。<br>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。<br>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。<br>?animal_type_id=1：指定筛选条件<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET <span class="regexp">/zoo/</span>ID<span class="regexp">/animals 与 GET /</span>animals?zoo_id=ID 的含义是相同的。</div><div class="line"></div><div class="line"><span class="comment">## 七、状态码（Status Codes）</span></div><div class="line">服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</div></pre></td></tr></table></figure></p>
<p>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。<br>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。<br>202 Accepted - [<em>]：表示一个请求已经进入后台排队（异步任务）<br>204 NO CONTENT - [DELETE]：用户删除数据成功。<br>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。<br>401 Unauthorized - [</em>]：表示用户没有权限（令牌、用户名、密码错误）。<br>403 Forbidden - [<em>] 表示用户得到授权（与401错误相对），但是访问是被禁止的。<br>404 NOT FOUND - [</em>]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。<br>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。<br>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。<br>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。<br>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">状态码的完全列表参见[<span class="string">这里</span>](<span class="link">https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html</span>)。</div><div class="line"></div><div class="line"><span class="section">## 八、错误处理（Error handling）</span></div><div class="line">如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</div></pre></td></tr></table></figure></p>
<p>{<br>    error: “Invalid API key”<br>}<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 九、返回结果</div><div class="line">针对不同操作，服务器向用户返回的结果应该符合以下规范。</div></pre></td></tr></table></figure></p>
<p>GET /collection：返回资源对象的列表（数组）<br>GET /collection/resource：返回单个资源对象<br>POST /collection：返回新生成的资源对象<br>PUT /collection/resource：返回完整的资源对象<br>PATCH /collection/resource：返回完整的资源对象<br>DELETE /collection/resource：返回一个空文档<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 十、Hypermedia API</div><div class="line">RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。</div><div class="line">比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</div></pre></td></tr></table></figure></p>
<p>{“link”: {<br>  “rel”:   “collection <a href="https://www.example.com/zoos" target="_blank" rel="external">https://www.example.com/zoos</a>“,<br>  “href”:  “<a href="https://api.example.com/zoos" target="_blank" rel="external">https://api.example.com/zoos</a>“,<br>  “title”: “List of zoos”,<br>  “type”:  “application/vnd.yourformat+json”<br>}}<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。</div><div class="line">Hypermedia API的设计被称为HATEOAS。Github的API就是这种设计，访问api<span class="selector-class">.github</span><span class="selector-class">.com</span>会得到一个所有可用API的网址列表。</div></pre></td></tr></table></figure></p>
<p>{<br>  “current_user_url”: “<a href="https://api.github.com/user" target="_blank" rel="external">https://api.github.com/user</a>“,<br>  “authorizations_url”: “<a href="https://api.github.com/authorizations" target="_blank" rel="external">https://api.github.com/authorizations</a>“,<br>  // …<br>}<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">从上面可以看到，如果想获取当前用户的信息，应该去访问api<span class="selector-class">.github</span><span class="selector-class">.com</span>/user，然后就得到了下面结果。</div></pre></td></tr></table></figure></p>
<p>{<br>  “message”: “Requires authentication”,<br>  “documentation_url”: “<a href="https://developer.github.com/v3" target="_blank" rel="external">https://developer.github.com/v3</a>“<br>}<br>```</p>
<p>上面代码表示，服务器给出了提示信息，以及文档的网址。</p>
<h2 id="十一、其他"><a href="#十一、其他" class="headerlink" title="十一、其他"></a>十一、其他</h2><p>（1）API的身份认证应该使用OAuth 2.0框架。<br>（2）服务器返回的数据格式，应该尽量使用JSON，避免使用XML。</p>
<hr>
<p><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="external">【原文链接】</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong><em>  </em></strong><br>]]>
    
    </summary>
    
      <category term="Http" scheme="http://miclee.cn/tags/Http/"/>
    
      <category term="Http" scheme="http://miclee.cn/categories/Http/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python Web 框架一览]]></title>
    <link href="http://miclee.cn/2017/05/15/Python-Web%E6%A1%86%E6%9E%B6%E4%B8%80%E8%A7%88/"/>
    <id>http://miclee.cn/2017/05/15/Python-Web框架一览/</id>
    <published>2017-05-15T03:03:05.000Z</published>
    <updated>2017-05-15T05:39:40.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> Python 有许多 web 框架可以供你选择。网上甚至还有教你怎么制作自己专属的框架的教程，因为这实在是太容易了。然后就导致了现在框架的质量参差不齐。我们来对这些框架做一个概述然后你可以挑出自己喜欢的。 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们经常谈到的 python web 框架有这些：</p>
<table>
<thead>
<tr>
<th>名字</th>
<th>版本</th>
<th>最后更新</th>
<th>诞生时间</th>
<th>代码行数</th>
</tr>
</thead>
<tbody>
<tr>
<td>Django</td>
<td>1.3.1</td>
<td>2011-09-09</td>
<td>2005</td>
<td>115759</td>
</tr>
<tr>
<td>Flask</td>
<td>0.8</td>
<td>2011-09-29</td>
<td>2010</td>
<td>4681</td>
</tr>
<tr>
<td>Bottle</td>
<td>0.10.9</td>
<td>2012-02-11</td>
<td>2009</td>
<td>4634</td>
</tr>
<tr>
<td>Tornado</td>
<td>2.2</td>
<td>2012-01-30</td>
<td>2009</td>
<td>11701</td>
</tr>
<tr>
<td>Cherry.py</td>
<td>3.2.2</td>
<td>2011-10-19</td>
<td>2002</td>
<td>18828</td>
</tr>
<tr>
<td>web.py</td>
<td>0.36</td>
<td>2011-07-04</td>
<td>2006</td>
<td>7398</td>
</tr>
<tr>
<td>Brubeck</td>
<td>0.3.7</td>
<td>2011-12-20</td>
<td>011</td>
<td>1525</td>
</tr>
</tbody>
</table>
<p>注释1：加上 Brubeck 是因为我认为我们可以从这个框架身上学到很多，虽然这个框架已经不是 Python 框架了。</p>
<p>注释2：还有许多其他的框架比如说 Zope， Pylons， Pyramid － 我之所以没有写它们是因为我对它们没有经验。</p>
<p>注释3：如果 Flask 的代码加上 Werkzeug 和 Jinja2 的话一共约 35000 行。</p>
<p>注释4：代码行数意思是实际的 Python 代码。使用 CLOC 计数。</p>
<h2 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h2><p>这可能是最广为人知和使用最广泛的 Python web 框架了。我承认它确实非常强大。Django 有世界上最大的社区，最多的包，可以说只有你想不到的，没有它做不到的。它的文档非常完善，但是有的比较冷门的知识你还是需要去 StackOverflow 咨询一下。</p>
<p>Django 在配置上面遵循惯例，这样对于初学者来说比较容易，而且在比较复杂的应用上也有一定的灵活性。Django 致力于快速开发以及简洁实用的设计。</p>
<p>Django 只需要这么 几行代码 就可以实现一个“Hello World！”程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import os</div><div class="line">from django.conf.urls.defaults import patterns</div><div class="line">from django.http import HttpResponse</div><div class="line">filepath, extension = os.path.splitext(__file__)</div><div class="line">ROOT_URLCONF = os.path.basename(filepath)</div><div class="line"></div><div class="line">def hello(request):</div><div class="line">    return HttpResponse(&apos;Hello World!&apos;)</div><div class="line"></div><div class="line">urlpatterns = patterns(&apos;&apos;, (r&apos;^/$&apos;, hello))</div></pre></td></tr></table></figure></p>
<p>关于 Django 我不喜欢的一点就是它有点儿被焊死的感觉。不要尝试着去改变它，否则你会碰壁的。我来解释一下这个说法：比如说我想要使用 SQLAlchemy 作为 ORM 然后 SQLAlchemy 就会把 Admin， Auth， Form 等等几乎所有的部分都给搞砸。所以你最好使用它附带的工具包。</p>
<p>快速教程： <a href="https://www.djangoproject.com/" target="_blank" rel="external">Django</a></p>
<p>它们都基于 Django： Disqus ， EveryBlock ， Guardian (newspaper) ， Firefox add-ons (Mozilla)</p>
<h2 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h2><p>这个灵巧的框架是由 Armin Ronacher 创造的。它的名字暗示了它的含义，它基本上就是一个微型的胶水框架。它把 Werkzeug 和 Jinja 粘合在了一起。所以它很容易被扩展。</p>
<p>Flask 也有许多的 扩展 可以供你使用，Flask 也有一群忠诚的粉丝和不断增加的用户群。它有一份很完善的文档，甚至还有一份唾手可得的常见范例。Flask 很容易使用，你只需要 3(7) 行代码就可以写出来一个 Hello World。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">from flask import Flask</div><div class="line">app = Flask(__name__)</div><div class="line"></div><div class="line">@app.route(&quot;/&quot;)</div><div class="line">def hello():</div><div class="line">    return &quot;Hello World!&quot;</div><div class="line"></div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    app.run()</div></pre></td></tr></table></figure></p>
<p>我觉得这是它最大的优点也是缺点 － Flask 并不强制一个特定的 ORM。这会使得写扩展有点儿困难，你可能会想用某种形式的数据库层，但是用哪一个呢？Python 有非常多可以选择的。这个 Blog 是用 Flask 写的，部署在 Google App Engine 上。这很容易因为 Google Datastore 和其他的不太一样。所以有时候不强制一个 ORM 也是好事儿。</p>
<p>如果你想建一个新站的话 Flask 是个非常不错的选择。但我并不会向所有的初学者都推荐 Flask，我指的是那些不关心“为什么可以”，只关心它们“可不可以”的初学者。</p>
<p>快速教程： <a href="http://flask.pocoo.org/docs/0.12/quickstart/" target="_blank" rel="external">Flask quickstart</a></p>
<p>它们都基于 Flask： Dev news aggregator for Battlefield3 ， Media Queries ， Learn buffet ， Konstruktor (appengine)</p>
<h2 id="Bottle"><a href="#Bottle" class="headerlink" title="Bottle"></a>Bottle</h2><p>这个框架相对来说比较新。它受到了 Sinatra 的影响。Bottle 才是名副其实的微框架 － 它只有大约 4500 行代码。并且我认为这是最真实的基于 Python 的微框架，它除了 Python 标准库以外没有任何其它的依赖，甚至它还有自己独特的一点儿模版语言。Bottle 还是为数不多的支持 Python 3 的框架之一。</p>
<p>Bottle 的文档很详细并且抓住了事物的实质。Hello World 例子很像 Flask，也使用了装饰器来定义路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">from bottle import route, run</div><div class="line"></div><div class="line">@route(&apos;/hello/:name&apos;)</div><div class="line">def hello(name):</div><div class="line">    return &apos;&lt;h1&gt;Hello %s!&lt;/h1&gt;&apos; % name.title()</div><div class="line"></div><div class="line">run(host=&apos;localhost&apos;, port=8080)</div></pre></td></tr></table></figure>
<p>我知道 Bottle 内部有一座桥梁来沟通各个部分，因为它只有一个文件。但是很难找到你想要的东西，它的代码散布的到处都是，看起来一团糟。</p>
<p>对于非常小的项目或者是实验性的项目来说，Bottle 是一个不错的选择。但是对于一些大型的项目来说最好就不要使用它了，因为它的扩展并不多。</p>
<p>快速教程： <a href="http://bottlepy.org/docs/dev/tutorial.html" target="_blank" rel="external">Bottle tutorial</a></p>
<p>它们都基于 Bottle： Plush (monitoring) ， Hobo (Blog enginee)</p>
<h2 id="web-py"><a href="#web-py" class="headerlink" title="web.py"></a>web.py</h2><p>以前 web.py 还很流行的时候被用来写 reddit。它能很好的处理流量问题。如果你用 web.py 开发 web 应用的话，你会发现它并不会阻碍你。 标准配置 很简单也很直观。web.py 在文件和文件夹的分类上面也做的非常棒。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import web</div><div class="line"></div><div class="line">urls = (&apos;/(.*)&apos;, &apos;hello&apos;)</div><div class="line">app = web.application(urls, globals())</div><div class="line"></div><div class="line">class hello:</div><div class="line">    def GET(self):</div><div class="line">        return &apos;Hello, World!&apos;</div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    app.run()</div></pre></td></tr></table></figure></p>
<p>很遗憾的是这个库最近已经成为了 rails 框架狂热者的受害者。它有可以帮你做几乎所有事情的自己的库 － 模版，表格，数据库。可能它们并不像其它库一样得到了良好的维护，但是还是有许多人在用它。</p>
<p>快速教程： <a href="http://webpy.org/" target="_blank" rel="external">web.py</a></p>
<p>它们基于 web.py： Yandex (russian search engine) ， Telephone directory (Switzerland)</p>
<h2 id="Tornado"><a href="#Tornado" class="headerlink" title="Tornado"></a>Tornado</h2><p>Tornado 不单单是个框架，还是个 web 服务器。它一开始是给 FriendFeed 开发的，后来在 2009 年的时候也给 Facebook 使用。它是为了解决实时服务而诞生的。为了做到这一点，Tornado 使用了异步非阻塞 IO。</p>
<p>Tornado 的文档非常技术性。它并不是为初学者准备的。这是一个 Hello World 程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import tornado.ioloop</div><div class="line">import tornado.web</div><div class="line"></div><div class="line">class MainHandler(tornado.web.RequestHandler):</div><div class="line">    def get(self):</div><div class="line">        self.write(&quot;Hello, world&quot;)</div><div class="line"></div><div class="line">application = tornado.web.Application([</div><div class="line">    (r&quot;/&quot;, MainHandler),</div><div class="line">])</div><div class="line"></div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    application.listen(8888)</div><div class="line">    tornado.ioloop.IOLoop.instance().start()</div></pre></td></tr></table></figure></p>
<p>默认情况下 Tornado 会传递 WSGI 层，因为 WSGI 并不能处理异步请求。Tornado 确实性能非常强，但是当调用数据库的时候它会阻塞 IO。</p>
<p>快速教程： <a href="http://www.tornadoweb.org/en/stable/" target="_blank" rel="external">Tornado</a></p>
<p>它们基于 Tornado： Too cool for me ， FriendFeed</p>
<h2 id="CherryPy"><a href="#CherryPy" class="headerlink" title="CherryPy"></a>CherryPy</h2><p>这是最古老的 Python 框架的一种。CherryPy 并没有得到广泛的应用，大家提到它第一反应是 web 服务器然后才是一个框架。在处理请求方面 CherryPy 也使用了队列来优化性能，但是它使用的是 线程池 技术。</p>
<p>CherryPy 的文档实际上非常少，但是基本上都可以涵盖主要的方面。CherryPy 也可以支持 Python 3。我必须说，它的 Hello World 例子非常漂亮：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import cherrypy</div><div class="line">class HelloWorld(object):</div><div class="line">    def index(self):</div><div class="line">    return &quot;Hello World!&quot;</div><div class="line">    index.exposed = True</div><div class="line"></div><div class="line">cherrypy.quickstart(HelloWorld())</div></pre></td></tr></table></figure></p>
<p>快速教程： <a href="http://docs.cherrypy.org/en/latest/" target="_blank" rel="external">CherryPy</a></p>
<p>它们基于 CherryPy： YouGov ， Cuil search engine (ended 2010)</p>
<h2 id="Brubeck"><a href="#Brubeck" class="headerlink" title="Brubeck"></a>Brubeck</h2><p>这是一个新的 Python 框架。其并不使用 WSGI 而直接在语言级别用 Mongrel2 作为服务器使用，这个仅把请求处理交给 Python 程序，请求作为协同程序来处理。</p>
<p>模块方面 Brubeck 使用了 DictShield 库，意思就是对于不同的数据库插件都可以在其之上来进行操作。</p>
<p>Brubeck 的文档非常少，但是你看到源码以后，你会知道其实并没有多少东西。所以它还是一个非常年轻并且在不断发展的框架。Hello World 例子看起来也很漂亮。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class DemoHandler(WebMessageHandler):</div><div class="line">    def get(self):</div><div class="line">        self.set_body(&apos;Hello world&apos;)</div><div class="line">        return self.render()</div><div class="line"></div><div class="line">urls = [(r&apos;^/&apos;, DemoHandler)]</div><div class="line">mongrel2_pair = (&apos;ipc://127.0.0.1:9999&apos;, &apos;ipc://127.0.0.1:9998&apos;)</div><div class="line"></div><div class="line">app = Brubeck(mongrel2_pair=mongrel2_pair,</div><div class="line">          handler_tuples=urls)</div><div class="line">app.run()</div></pre></td></tr></table></figure></p>
<p>唯一需要注意的是当你使用 Brubeck 的时候你也需要看看 Mongrel2 服务器的相关知识。</p>
<p>快速教程： <a href="http://brubeck.io/" target="_blank" rel="external">Brubeck.io</a></p>
<p>它们基于 Brubeck： ListSurf</p>
]]></content>
    <summary type="html">
    <![CDATA[Python 有许多 web 框架可以供你选择。网上甚至还有教你怎么制作自己专属的框架的教程，因为这实在是太容易了。然后就导致了现在框架的质量参差不齐。我们来对这些框架做一个概述然后你可以挑出自己喜欢的。]]>
    
    </summary>
    
      <category term="Python" scheme="http://miclee.cn/tags/Python/"/>
    
      <category term="Python" scheme="http://miclee.cn/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[人生苦短，我用Python【转】]]></title>
    <link href="http://miclee.cn/2017/05/12/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8C%E6%88%91%E7%94%A8Python/"/>
    <id>http://miclee.cn/2017/05/12/人生苦短，我用Python/</id>
    <published>2017-05-12T09:28:26.000Z</published>
    <updated>2017-05-15T05:38:25.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> Python语言的发展简史。 </em></strong><br><a id="more"></a></p>
<hr>
<p>Python是我喜欢的语言，简洁，优美，容易使用。前两天，我很激昂的向朋友宣传Python的好处。</p>
<p>“好吧，我承认Python不错，但它为什么叫Python呢？”<br>“呃，似乎是一个电视剧的名字。”<br>“那你说的Guido是美国人么？”<br>“他从Google换到Dropbox工作，但他的名字像是荷兰人的。”<br>“你确定你很熟悉Python吗？”</p>
<p>所以为了雪耻，我花时间调查了Python的历史。我看到了Python中许多功能的来源和Python的设计理念，看到了一门编程语言的演化历史，看到了Python与开源运动的奇妙联系。从Python的历史中，我们可以一窥开源开发的理念和成就。</p>
<p>这也可以作为我写的Python快速教程的序篇。</p>
<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>Python的作者，Guido von Rossum，确实是荷兰人。1982年，Guido从阿姆斯特丹大学获得了数学和计算机硕士学位。然而，尽管他算得上是一位数学家，但他更加享受计算机带来的乐趣。用他的话说，尽管拥有数学和计算机双料资质，他总趋向于做计算机相关的工作，并热衷于做任何和编程相关的活儿。</p>
<p>在那个时候，Guido接触并使用过诸如Pascal、C、 Fortran等语言。这些语言的基本设计原则是让机器能更快运行。在80年代，虽然IBM和苹果已经掀起了个人电脑浪潮，但这些个人电脑的配置很低。比如早期的Macintosh，只有8MHz的CPU主频和128KB的RAM，一个大的数组就能占满内存。所有的编译器的核心是做优化，以便让程序能够运行。为了增进效率，语言也迫使程序员像计算机一样思考，以便能写出更符合机器口味的程序。在那个时代，程序员恨不得用手榨取计算机每一寸的能力。有人甚至认为C语言的指针是在浪费内存。至于动态类型，内存自动管理，面向对象…… 别想了，那会让你的电脑陷入瘫痪。</p>
<p>这种编程方式让Guido感到苦恼。Guido知道如何用C语言写出一个功能，但整个编写过程需要耗费大量的时间，即使他已经准确的知道了如何实现。他的另一个选择是shell。Bourne Shell作为UNIX系统的解释器已经长期存在。UNIX的管理员们常常用shell去写一些简单的脚本，以进行一些系统维护的工作，比如定期备份、文件系统管理等等。shell可以像胶水一样，将UNIX下的许多功能连接在一起。许多C语言下上百行的程序，在shell下只用几行就可以完成。然而，shell的本质是调用命令。它并不是一个真正的语言。比如说，shell没有数值型的数据类型，加法运算都很复杂。总之，shell不能全面的调动计算机的功能。</p>
<p>Guido希望有一种语言，这种语言能够像C语言那样，能够全面调用计算机的功能接口，又可以像shell那样，可以轻松的编程。ABC语言让Guido看到希望。ABC是由荷兰的数学和计算机研究所开发的。Guido在该研究所工作，并参与到ABC语言的开发。ABC语言以教学为目的。与当时的大部分语言不同，ABC语言的目标是“让用户感觉更好”。ABC语言希望让语言变得容易阅读，容易使用，容易记忆，容易学习，并以此来激发人们学习编程的兴趣。比如下面是一段来自Wikipedia的ABC程序，这个程序用于统计文本中出现的词的总数：  </p>
<pre><code>HOW TO RETURN words document:

    PUT {} IN collection

    FOR line IN document:

        FOR word IN split line:

        IF word not.in collection:

            INSERT word IN collection

    RETURN collection
</code></pre><p>HOW TO用于定义一个函数。一个Python程序员应该很容易理解这段程序。ABC语言使用冒号和缩进来表示程序块。行尾没有分号。for和if结构中也没有括号()。赋值采用的是PUT，而不是更常见的等号。这些改动让ABC程序读起来像一段文字。</p>
<p>尽管已经具备了良好的可读性和易用性，ABC语言最终没有流行起来。在当时，ABC语言编译器需要比较高配置的电脑才能运行。而这些电脑的使用者通常精通计算机，他们更多考虑程序的效率，而非它的学习难度。除了硬件上的困难外，ABC语言的设计也存在一些致命的问题：</p>
<ul>
<li><p>可拓展性差。ABC语言不是模块化语言。如果想在ABC语言中增加功能，比如对图形化的支持，就必须改动很多地方。</p>
</li>
<li><p>不能直接进行IO。ABC语言不能直接操作文件系统。尽管你可以通过诸如文本流的方式导入数据，但ABC无法直接读写文件。输入输出的困难对于计算机语言来说是致命的。你能想像一个打不开车门的跑车么？</p>
</li>
<li><p>过度革新。ABC用自然语言的方式来表达程序的意义，比如上面程序中的HOW TO 。然而对于程序员来说，他们更习惯用function或者define来定义一个函数。同样，程序员更习惯用等号来分配变量。尽管ABC语言很特别，但学习难度也很大。</p>
</li>
<li><p>传播困难。ABC编译器很大，必须被保存在磁带上。当时Guido在访问的时候，就必须有一个大磁带来给别人安装ABC编译器。 这样，ABC语言就很难快速传播。</p>
</li>
</ul>
<p>1989年，为了打发圣诞节假期，Guido开始写Python语言的编译器。Python这个名字，来自Guido所挚爱的电视剧Monty Python’s Flying Circus。他希望这个新的叫做Python的语言，能符合他的理想：创造一种C和shell之间，功能全面，易学易用，可拓展的语言。Guido作为一个语言设计爱好者，已经有过设计语言的尝试。这一次，也不过是一次纯粹的hacking行为。</p>
<h2 id="一门语言的诞生"><a href="#一门语言的诞生" class="headerlink" title="一门语言的诞生"></a>一门语言的诞生</h2><p>1991年，第一个Python编译器诞生。它是用C语言实现的，并能够调用C语言的库文件。从一出生，Python已经具有了：类，函数，异常处理，包含表和词典在内的核心数据类型，以及模块为基础的拓展系统。</p>
<p>Python语法很多来自C，但又受到ABC语言的强烈影响。来自ABC语言的一些规定直到今天还富有争议，比如强制缩进。但这些语法规定让Python容易读。另一方面，Python聪明的选择服从一些惯例，特别是C语言的惯例。比如使用等号赋值，使用def来定义函数。Guido认为，如果“常识”上确立的东西，没有必要过度纠结。</p>
<p>Python从一开始就特别在意可拓展性。Python可以在多个层次上拓展。从高层上，你可以直接引入.py文件。在底层，你可以引用C语言的库。Python程序员可以快速的使用Python写.py文件作为拓展模块。但当性能是考虑的重要因素时，Python程序员可以深入底层，写C程序，编译为.so文件引入到Python中使用。Python就好像是使用钢构建房一样，先规定好大的框架。而程序员可以在此框架下相当自由的拓展或更改。</p>
<p>最初的Python完全由Guido本人开发。Python得到Guido同事的欢迎。他们迅速的反馈使用意见，并参与到Python的改进。Guido和一些同事构成Python的核心团队。他们将自己大部分的业余时间用于hack Python。随后，Python拓展到研究所之外。Python将许多机器层面上的细节隐藏，交给编译器处理，并凸显出逻辑层面的编程思考。Python程序员可以花更多的时间用于思考程序的逻辑，而不是具体的实现细节。这一特征吸引了广大的程序员。Python开始流行。<br>人生苦短，我用python</p>
<p><img src="https://raw.githubusercontent.com/OfMicLee/img-hosting/master/python/001.jpg" alt=""></p>
<h2 id="时势造英雄"><a href="#时势造英雄" class="headerlink" title="时势造英雄"></a>时势造英雄</h2><p>我们不得不暂停我们的Python时间，转而看一看瞬息万变的计算机行业。1990年代初，个人计算机开始进入普通家庭。Intel发布了486处理器，windows发布window 3.0开始的一系列视窗系统。计算机的性能大大提高。程序员开始关注计算机的易用性  ，比如图形化界面。</p>
<p><img src="https://raw.githubusercontent.com/OfMicLee/img-hosting/master/python/002.png" alt=""></p>
<p>由于计算机性能的提高，软件的世界也开始随之改变。硬件足以满足许多个人电脑的需要。硬件厂商甚至渴望高需求软件的出现，以带动硬件的更新换代。C++和Java相继流行。C++和Java提供了面向对象的编程范式，以及丰富的对象库。在牺牲了一定的性能的代价下，C++和Java大大提高了程序的产量。语言的易用性被提到一个新的高度。我们还记得，ABC失败的一个重要原因是硬件的性能限制。从这方面说，Python要比ABC幸运许多。</p>
<p>另一个悄然发生的改变是Internet。1990年代还是个人电脑的时代，windows和Intel挟PC以令天下，盛极一时。尽管Internet为主体的信息革命尚未到来，但许多程序员以及资深计算机用户已经在频繁使用Internet进行交流，比如使用email和newsgroup。Internet让信息交流成本大大下降。一种新的软件开发模式开始流行：开源。程序员利用业余时间进行软件开发，并开放源代码。1991年，Linus在comp.os.minix新闻组上发布了Linux内核源代码，吸引大批hacker的加入。Linux和GNU相互合作，最终构成了一个充满活力的开源平台。</p>
<p>硬件性能不是瓶颈，Python又容易使用，所以许多人开始转向Python。Guido维护了一个maillist，Python用户就通过邮件进行交流。Python用户来自许多领域，有不同的背景，对Python也有不同的需求。Python相当的开放，又容易拓展，所以当用户不满足于现有功能，很容易对Python进行拓展或改造。随后，这些用户将改动发给Guido，并由Guido决定是否将新的特征加入到Python或者标准库中。如果代码能被纳入Python自身或者标准库，这将极大的荣誉。由于Guido至高无上的决定权，他因此被称为“终身的仁慈独裁者”。</p>
<p>Python被称为“Battery Included”，是说它以及其标准库的功能强大。这些是整个社区的贡献。Python的开发者来自不同领域，他们将不同领域的优点带给Python。比如Python标准库中的正则表达是参考Perl，而lambda, map, filter, reduce等函数参考了Lisp。Python本身的一些功能以及大部分的标准库来自于社区。Python的社区不断扩大，进而拥有了自己的newsgroup，网站，以及基金。从Python 2.0开始，Python也从maillist的开发方式，转为完全开源的开发方式。社区气氛已经形成，工作被整个社区分担，Python也获得了更加高速的发展。</p>
<p>到今天，Python的框架已经确立。Python语言以对象为核心组织代码，支持多种编程范式，采用动态类型，自动进行内存回收。Python支持解释运行，并能调用C库进行拓展。Python有强大的标准库。由于标准库的体系已经稳定，所以Python的生态系统开始拓展到第三方包。这些包，如Django、web.py、wxpython、numpy、matplotlib、PIL，将Python升级成了物种丰富的热带雨林。</p>
<h2 id="启示录"><a href="#启示录" class="headerlink" title="启示录"></a>启示录</h2><p>Python崇尚优美、清晰、简单，是一个优秀并广泛使用的语言。Python在TIOBE排行榜中排行第八，它是Google的第三大开发语言，Dropbox的基础语言，豆瓣的服务器语言。Python的发展史可以作为一个代表，带给我许多启示。</p>
<p>在Python的开发过程中，社区起到了重要的作用。Guido自认为自己不是全能型的程序员，所以他只负责制订框架。如果问题太复杂，他会选择绕过去，也就是cut the corner。这些问题最终由社区中的其他人解决。社区中的人才是异常丰富的，就连创建网站，筹集基金这样与开发稍远的事情，也有人乐意于处理。如今的项目开发越来越复杂，越来越庞大，合作以及开放的心态成为项目最终成功的关键。</p>
<p>Python从其他语言中学到了很多，无论是已经进入历史的ABC，还是依然在使用的C和Perl，以及许多没有列出的其他语言。可以说，Python的成功代表了它所有借鉴的语言的成功。同样，Ruby借鉴了Python，它的成功也代表了Python某些方面的成功。每个语言都是混合体，都有它优秀的地方，但也有各种各样的缺陷。同时，一个语言“好与不好”的评判，往往受制于平台、硬件、时代等等外部原因。程序员经历过许多语言之争。其实，以开放的心态来接受各个语言，说不定哪一天，程序员也可以如Guido那样，混合出自己的语言。</p>
<p>无论Python未来的命运如何，Python的历史已经是本很有趣的小说。</p>
]]></content>
    <summary type="html">
    <![CDATA[Python语言的发展简史。]]>
    
    </summary>
    
      <category term="Python" scheme="http://miclee.cn/tags/Python/"/>
    
      <category term="Python" scheme="http://miclee.cn/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[解决MAC系统上matplotlib无法使用问题]]></title>
    <link href="http://miclee.cn/2017/05/12/%E8%A7%A3%E5%86%B3matplotlib%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://miclee.cn/2017/05/12/解决matplotlib无法使用问题/</id>
    <published>2017-05-12T01:49:13.000Z</published>
    <updated>2017-05-12T01:58:20.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> 在 MAC 上运行Python时，如果涉及到matplotlib画图，小火箭总是弹不出界面，有的还会报RuntimeError。 </em></strong><br><a id="more"></a></p>
<hr>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">**RuntimeError**: Python <span class="keyword">is</span> <span class="keyword">not</span> installed <span class="keyword">as</span> a framework. The Mac OS X backend will <span class="keyword">not</span> be able <span class="keyword">to</span> function correctly <span class="keyword">if</span> Python <span class="keyword">is</span> <span class="keyword">not</span> installed <span class="keyword">as</span> a framework. See <span class="keyword">the</span> Python documentation <span class="keyword">for</span> more information <span class="keyword">on</span> installing Python <span class="keyword">as</span> a framework <span class="keyword">on</span> Mac OS X. Please either reinstall Python <span class="keyword">as</span> a framework, <span class="keyword">or</span> <span class="keyword">try</span> one <span class="keyword">of</span> <span class="keyword">the</span> other backends.</div></pre></td></tr></table></figure>
<p><strong>原因：</strong>  </p>
<p>Problem Cause In mac os image rendering back end of matplotlib (what-is-a-backend to render using the API of Cocoa by default). There is Qt4Agg and GTKAgg and as a back-end is not the default. Set the back end of macosx that is differ compare with other windows or linux os.</p>
<p><strong>解决方案：</strong></p>
<p>创建文件 ~/.matplotlib/matplotlibrc<br>增加内容:<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">backend: </span>TkAgg</div></pre></td></tr></table></figure></p>
<p>搞定收工！</p>
]]></content>
    <summary type="html">
    <![CDATA[在 MAC 上运行Python时，如果涉及到matplotlib画图，小火箭总是弹不出界面，有的还会报RuntimeError。]]>
    
    </summary>
    
      <category term="Python" scheme="http://miclee.cn/tags/Python/"/>
    
      <category term="Python" scheme="http://miclee.cn/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Numpy 矩阵乘法]]></title>
    <link href="http://miclee.cn/2017/05/10/py-dot-multiply/"/>
    <id>http://miclee.cn/2017/05/10/py-dot-multiply/</id>
    <published>2017-05-10T09:02:17.000Z</published>
    <updated>2017-05-10T09:19:27.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> 在NumPy中，array用于表示通用的N维数组，matrix则特定用于线性代数计算。array和matrix都可以用来表示矩阵，二者在进行乘法操作时，有一些不同之处。 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><p>使用array时，运算符 * 用于计算数量积（点乘），函数 dot() 用于计算矢量积（叉乘），例子如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import numpy as np</div><div class="line"></div><div class="line">a = np.array([[1, 2], [3, 4]])</div><div class="line">b = np.array([[5, 6], [7, 8]])</div><div class="line"></div><div class="line">print(&apos;a * b = \n&apos;, a * b)</div><div class="line">print(&apos;dot(a, b) = \n&apos;, np.dot(a, b))</div><div class="line">```  </div><div class="line">运行结果为：   </div><div class="line">```python3</div><div class="line">a * b =</div><div class="line">[[ 5 12]</div><div class="line"> [21 32]]</div><div class="line">dot(a, b) =</div><div class="line">[[19 22]</div><div class="line"> [43 50]]</div></pre></td></tr></table></figure></p>
<p>可见，当a和b为array时， a <em> b 计算了a和b的数量积（对应Matlab的 a .</em> b ）， dot(a, b) 计算了a和b的矢量积（对应Matlab的 a * b ）。</p>
<h2 id="matrix"><a href="#matrix" class="headerlink" title="matrix"></a>matrix</h2><p>与array不同的是，使用matrix时，运算符 * 用于计算矢量积，函数 multiply() 用于计算数量积，例子如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import numpy as np</div><div class="line"></div><div class="line">a = np.mat(&apos;1 2; 3 4&apos;)</div><div class="line">b = np.mat(&apos;5 6; 7 8&apos;);</div><div class="line"></div><div class="line">print &apos;a * b = \n&apos;, a * b</div><div class="line">print &apos;multiply(a, b) = \n&apos;, np.multiply(a, b)</div><div class="line">```  </div><div class="line">运行结果为：</div></pre></td></tr></table></figure></p>
<p>a * b =<br>[[19 22]<br> [43 50]]<br>multiply(a, b) =<br>[[ 5 12]<br> [21 32]]<br> ```</p>
<p>可见，当a和b为matrix时， a * b 计算了a和b的矢量积， multiply(a, b) 计算了a和b的数量积。当使用matrix时，无论是生成矩阵还是计算，Numpy的风格和Matlab更加贴近，降低了语言切换时的负担。</p>
]]></content>
    <summary type="html">
    <![CDATA[在NumPy中，array用于表示通用的N维数组，matrix则特定用于线性代数计算。array和matrix都可以用来表示矩阵，二者在进行乘法操作时，有一些不同之处。]]>
    
    </summary>
    
      <category term="Python" scheme="http://miclee.cn/tags/Python/"/>
    
      <category term="Python" scheme="http://miclee.cn/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[range、xrange、arange比较]]></title>
    <link href="http://miclee.cn/2017/05/10/python-range/"/>
    <id>http://miclee.cn/2017/05/10/python-range/</id>
    <published>2017-05-10T05:31:51.000Z</published>
    <updated>2017-05-11T10:56:41.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> range & xrange属于python的原生方法，arange属于numpy库的方法，具体区别如下。 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="range"><a href="#range" class="headerlink" title="range"></a>range</h2><p>官方文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">range(stop) -&gt; range object</div><div class="line">range(start, stop[, step]) -&gt; range object</div><div class="line"></div><div class="line">Return an object that produces a sequence of integers from start (inclusive)</div><div class="line">to stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.</div><div class="line">start defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.</div><div class="line">These are exactly the valid indices for a list of 4 elements.</div><div class="line">When step is given, it specifies the increment (or decrement).</div></pre></td></tr></table></figure></p>
<p><strong>函数说明：</strong><br>根据start与stop指定的范围以及step设定的步长，生成一个序列。<br>range示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; range(5)</div><div class="line">[0, 1, 2, 3, 4]</div><div class="line">&gt;&gt;&gt; range(1,5)</div><div class="line">[1, 2, 3, 4]</div><div class="line">&gt;&gt;&gt; range(0,6,2)</div><div class="line">[0, 2, 4]</div></pre></td></tr></table></figure></p>
<h2 id="xrange"><a href="#xrange" class="headerlink" title="xrange"></a>xrange</h2><p><strong>函数说明：</strong><br>用法与range完全相同，所不同的是生成的不是一个数组，而是一个生成器。<br>xrange示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; xrange(5)</div><div class="line">xrange(5)</div><div class="line">&gt;&gt;&gt; list(xrange(5))</div><div class="line">[0, 1, 2, 3, 4]</div><div class="line">&gt;&gt;&gt; xrange(1,5)</div><div class="line">xrange(1, 5)</div><div class="line">&gt;&gt;&gt; list(xrange(1,5))</div><div class="line">[1, 2, 3, 4]</div><div class="line">&gt;&gt;&gt; xrange(0,6,2)</div><div class="line">xrange(0, 6, 2)</div><div class="line">&gt;&gt;&gt; list(xrange(0,6,2))</div><div class="line">[0, 2, 4]</div></pre></td></tr></table></figure></p>
<p>要生成很大的数字序列的时候，用xrange会比range性能优很多，因为不需要一上来就开辟一块很大的内存空间，这两个基本上都是在循环的时候用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for i in range(0, 100):</div><div class="line">print i</div><div class="line">for i in xrange(0, 100):</div><div class="line">print i</div></pre></td></tr></table></figure></p>
<p><strong>在Python 3中，range()的实现方式与xrange()函数相同，所以就不存在专用的xrange()（在Python 3中使用xrange()会触发NameError）。</strong>  </p>
<h2 id="arange"><a href="#arange" class="headerlink" title="arange"></a>arange</h2><p><strong>官方文档：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">numpy.arange([start, ]stop, [step, ]dtype=None)</div><div class="line">Return evenly spaced values within a given interval.</div><div class="line"></div><div class="line">Values are generated within the half-open interval [start, stop) (in other words, the interval including start but excluding stop). For integer arguments the function is equivalent to the Python built-in range function, but returns an ndarray rather than a list.</div><div class="line">```   </div><div class="line">用法等同于range，区别在于返回的是ndarray而非list。</div><div class="line">```python3</div><div class="line">&gt;&gt;&gt; np.arange(3)</div><div class="line">array([0, 1, 2])</div><div class="line">&gt;&gt;&gt; np.arange(3.0)</div><div class="line">array([ 0.,  1.,  2.])</div><div class="line">&gt;&gt;&gt; np.arange(3,7)</div><div class="line">array([3, 4, 5, 6])</div><div class="line">&gt;&gt;&gt; np.arange(3,7,2)</div><div class="line">array([3, 5])</div></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[range & xrange属于python的原生方法，arange属于numpy库的方法，具体区别如下。]]>
    
    </summary>
    
      <category term="Python" scheme="http://miclee.cn/tags/Python/"/>
    
      <category term="Python" scheme="http://miclee.cn/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习里的常用数学概念]]></title>
    <link href="http://miclee.cn/2017/04/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%87%8C%E7%9A%84%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E6%A6%82%E5%BF%B5/"/>
    <id>http://miclee.cn/2017/04/26/机器学习里的常用数学概念/</id>
    <published>2017-04-26T08:26:40.000Z</published>
    <updated>2017-04-26T08:40:40.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> 机器学习是门数学强相关的学科，在学习过程中不得不回过头去复习很多大学甚至中学的数学概念，在此记录下，方便以后查询。会持续往里更新。。。 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="偏差（Bias）"><a href="#偏差（Bias）" class="headerlink" title="偏差（Bias）"></a>偏差（Bias）</h2><p>   偏差描述的是预测值和真实值的差距。<br>   偏差越大，越偏离真实数据。  </p>
<h2 id="方差（Variance）"><a href="#方差（Variance）" class="headerlink" title="方差（Variance）"></a>方差（Variance）</h2><p>   方差描述的是预测值的变化范围、离散程度。<br>   方差越大，数据的分布越分散。  </p>
<h2 id="标准差"><a href="#标准差" class="headerlink" title="标准差"></a>标准差</h2><p>   标准差是方差的算术平方根。<br>   标准差和均值的量纲是一致的，在描述一个波动范围时更方便。<br>   如，身高分布是 170cm ± 10cm，标准差为10，方差为100。   </p>
<h2 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h2><p>   协方差用于衡量两个变量的总体误差。<br>   方差是协方差的一种特殊情况，即当两个变量是相同的情况。  </p>
<hr>
<h2 id="中位数"><a href="#中位数" class="headerlink" title="中位数"></a>中位数</h2><p>   将一组数据按大小一次排列，把处在中间位置的一个数据（或最中间两位数的平均数）叫做这组数据的中位数。  </p>
<h2 id="众数"><a href="#众数" class="headerlink" title="众数"></a>众数</h2><p>   一组数据中出现次数最多的数。</p>
]]></content>
    <summary type="html">
    <![CDATA[机器学习是门数学强相关的学科，在学习过程中不得不回过头去复习很多大学甚至中学的数学概念，在此记录下，方便以后查询。会持续往里更新。。。]]>
    
    </summary>
    
      <category term="机器学习" scheme="http://miclee.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="机器学习" scheme="http://miclee.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据挖掘]]></title>
    <link href="http://miclee.cn/2017/04/26/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    <id>http://miclee.cn/2017/04/26/数据挖掘/</id>
    <published>2017-04-26T08:06:36.000Z</published>
    <updated>2017-04-26T08:42:37.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> 在机器学习那章提到过，数据挖掘就是“机器学习+数据库”。就是在大型数据存储库中自动发现有用信息的过程。数据库中的知识发现。 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="数据挖掘主要任务"><a href="#数据挖掘主要任务" class="headerlink" title="数据挖掘主要任务"></a>数据挖掘主要任务</h2><ul>
<li>预测建模  <ul>
<li>分类：预测离散的目标变量</li>
<li>回归：预测连续的目标变量</li>
</ul>
</li>
<li>关联分析<br>发现数据中强关联特征的模式，如购物篮分析。</li>
<li>聚类分析<br>发现紧密相关的观测值组群，如新闻分类聚合。  </li>
<li>异常检测<br>识别其特征显著不同于其他数据的观测值，这样的观测值称为 <em>异常点</em> 或 <em>利群点</em>。如信贷欺诈、网络攻击、疾病发现、生态系统扰动等。  </li>
</ul>
<h2 id="数据挖掘主要步骤"><a href="#数据挖掘主要步骤" class="headerlink" title="数据挖掘主要步骤"></a>数据挖掘主要步骤</h2><ol>
<li>业务理解  </li>
<li>数据理解  </li>
<li>数据准备<br>数据准备就是对数据预处理，包括抽样、缺失值&amp;异常值处理、变量选择、数据分箱、数据降维等。  </li>
<li>建模  </li>
<li>模型评估<br>常用评估方法：混淆矩阵、基尼系数、K-S曲线、ROC曲线等。</li>
<li>模型发布</li>
</ol>
<h2 id="常用分类算法"><a href="#常用分类算法" class="headerlink" title="常用分类算法"></a>常用分类算法</h2><ul>
<li>决策树</li>
<li>基于规则的分类器</li>
<li>K-最近邻分类器</li>
<li>支持向量机</li>
<li>贝叶斯分类</li>
<li>人工神经网络</li>
<li>Logistic回归</li>
<li>多分类器组合使用</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[在机器学习那章提到过，数据挖掘就是“机器学习+数据库”。就是在大型数据存储库中自动发现有用信息的过程。数据库中的知识发现。]]>
    
    </summary>
    
      <category term="数据挖掘" scheme="http://miclee.cn/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
      <category term="机器学习" scheme="http://miclee.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习]]></title>
    <link href="http://miclee.cn/2017/04/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://miclee.cn/2017/04/26/机器学习/</id>
    <published>2017-04-26T07:13:26.000Z</published>
    <updated>2017-04-26T08:14:55.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> 今年正式开始学习机器学习，记了很多笔记在小本子上（本人还是比较偏爱传统书写），缺点就是回头翻阅起来检索比较困难，So干脆花点时间整理到博客上吧，方便自己也方便他人。由于我目前的工作主要用到机器学习的分类算法，所以会先入手研究这方面，其他的以后再慢慢补充吧。 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>机器学习是人工智能的一个分支。<br>机器学习方法是指用某些算法指导计算机利用已有的数据，得出适当的模型，并利用此模型对新的情境给出判断（预测未来）的一种方法。  </p>
<p>人工智能 &gt; 机器学习 &gt; 深度学习（即多层神经网络）</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li><p><strong>监督学习</strong><br>从给定的训练数据集中学习出一个函数，当新的数据到来时，可以根据这个函数预测结果。<br>监督学习的训练集要求是包括输入和输出，也可以说是特征和目标。训练集中的目标是由人标注的。<br>常见的监督学习算法包括 <em>回归分析</em> 和 <em>统计分类</em>。  </p>
<ul>
<li><strong>回归分析（Regression）</strong><br>预测一个连续值的输出，比如房价。</li>
<li><strong>统计分类（Classification）</strong><br>预测一个离散值的输出。又细分为二元分类和多元分类。  </li>
</ul>
</li>
<li><p><strong>无监督学习</strong><br>它是一种学习机制，给算法大量的数据，自动找出数据中蕴含的数据结构。<br>无监督学习中，没有属性或标签这一概念，也就是说所有数据都是一样的，没有区别。<br>与监督学习相比，训练集没有人为标注的结果。<br>常见的无监督学习算法有 <em>聚类算法</em> 和 <em>鸡尾酒会算法</em>。  </p>
<ul>
<li><strong>聚类算法</strong><br>不同的个体归入不同的类。如谷歌新闻分类。</li>
<li><strong>鸡尾酒会算法</strong><br>分离出叠加在一起的分类。</li>
</ul>
</li>
<li><p><strong>半监督学习</strong><br>介于监督学习与无监督学习之间。</p>
</li>
<li><p><strong>增强学习</strong><br>强调如何基于环境而行动，以取得最大化的预期利益。其灵感来源于心理学中的行为主义理论，即有机体如何在环境给予的奖励或惩罚的刺激下，逐步形成对刺激的预期，产生能获得最大利益的习惯性行为。这个方法具有普适性，因此在其他许多领域都有研究，例如博弈论、控制论、运筹学、信息论、仿真优化、多主体系统学习、群体智能、统计学以及遗传算法。  </p>
<p>增强学习和标准的监督式学习之间的区别在于，它并不需要出现正确的输入/输出对，也不需要精确校正次优化的行为。强化学习更加专注于在线规划，需要在探索（在未知的领域）和遵从（现有知识）之间找到平衡。强化学习中的“探索-遵从”的交换，在“多臂老虎机问题”和“有限MDP”中研究得最多。</p>
<h2 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h2><ul>
<li><strong>模式识别</strong><br>模式识别 = 机器学习，前者是工业界的概念。  </li>
<li><strong>数据挖掘</strong><br>数据挖掘 = 机器学习 + 数据库   </li>
<li><strong>统计学习</strong><br>统计学习 ≈ 机器学习，前者偏数学，后者偏实践。</li>
<li><strong>语音识别</strong><br>语言处理 + 机器学习</li>
<li><strong>计算机视觉</strong><br>图像处理 + 机器学习</li>
<li><strong>自然语言处理</strong><br>文本处理 + 机器学习</li>
</ul>
</li>
</ul>
<h2 id="经典代表算法"><a href="#经典代表算法" class="headerlink" title="经典代表算法"></a>经典代表算法</h2><ul>
<li><strong>监督学习算法</strong>  <ul>
<li>线性回归</li>
<li>逻辑回归</li>
<li>神经网络</li>
<li>SVM  </li>
</ul>
</li>
<li><strong>无监督算法</strong>  <ul>
<li>聚类算法</li>
<li>降维算法</li>
</ul>
</li>
<li><strong>特殊</strong><ul>
<li>推荐算法</li>
</ul>
</li>
</ul>
<h2 id="开发机器学习应用程序的步骤"><a href="#开发机器学习应用程序的步骤" class="headerlink" title="开发机器学习应用程序的步骤"></a>开发机器学习应用程序的步骤</h2><ol>
<li>收集数据    </li>
<li>准备数据  </li>
<li>分析数据  </li>
<li>训练算法（无监督学习不需要这一步）  </li>
<li>测试算法  </li>
<li>使用算法  </li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[今年正式开始学习机器学习，记了很多笔记在小本子上（本人还是比较偏爱传统书写），缺点就是回头翻阅起来检索比较困难，So干脆花点时间整理到博客上吧，方便自己也方便他人。由于我目前的工作主要用到机器学习的分类算法，所以会先入手研究这方面，其他的以后再慢慢补充吧。]]>
    
    </summary>
    
      <category term="机器学习" scheme="http://miclee.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="机器学习" scheme="http://miclee.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[更改Hexo的Markdown解析]]></title>
    <link href="http://miclee.cn/2017/04/20/%E6%9B%B4%E6%94%B9Hexo%E7%9A%84Markdown%E8%A7%A3%E6%9E%90/"/>
    <id>http://miclee.cn/2017/04/20/更改Hexo的Markdown解析/</id>
    <published>2017-04-20T08:28:45.000Z</published>
    <updated>2017-04-20T09:23:58.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> Hexo默认使用marked.js去解析我们写的markdown，以前用的就很不爽，解析的效果跟atom里预览效果不一致，本来想换个引擎，无奈有一些老的博文需要调整，索性改一下marked.js的解析方法。 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在写博文<a href="http://miclee.cn/2017/04/20/Python下划线使用">Python下划线使用</a>时因为有一堆的下滑线要写，hexo默认使用marked.js去解析我们写的markdown，比如一些符号，_代表斜体，会被处理为<em>标签，比如x_i在开始被渲染的时候，处理为x<em>i</em>，比如__init__会被处理成<strong>init</strong>。</em></p>
<p>考虑到我后面会写机器学习相关的一些东西，里面会涉及到很多数学公式，会影响解析，SO趁现在动动手。</p>
<h2 id="利用MathJax来渲染LaTeX数学公式"><a href="#利用MathJax来渲染LaTeX数学公式" class="headerlink" title="利用MathJax来渲染LaTeX数学公式"></a>利用MathJax来渲染LaTeX数学公式</h2><p>题外一下，MathJax的hexo插件安装方法。<br>cd到博文目录：<br><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install hexo-<span class="built_in">math</span> <span class="comment">--save</span></div><div class="line">hexo <span class="built_in">math</span> install</div></pre></td></tr></table></figure></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi ./node_modules/marked/lib/marked.js</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//escape: /^\\([\\`*&#123;&#125;\[\]()#+\-.!_&gt;])/,</span></div><div class="line"><span class="built_in">escape</span>: <span class="regexp">/^\\([`*&#123;&#125;\[\]()# +\-.!_&gt;])/</span>,</div><div class="line"></div><div class="line"><span class="comment">//strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,</span></div><div class="line">strong: <span class="regexp">/^\*\*([\s\S]+?)\*\*(?!\*)/</span>,</div><div class="line"></div><div class="line"><span class="comment">//em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span></div><div class="line">em:<span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</div></pre></td></tr></table></figure>
<p>So以后写 <em>斜体</em> 和 <strong>粗体</strong> 只能用* 和 ** 了</p>
<h2 id="解决方案二：更换Markdown引擎"><a href="#解决方案二：更换Markdown引擎" class="headerlink" title="解决方案二：更换Markdown引擎"></a>解决方案二：更换Markdown引擎</h2><p>比如换成pandoc：</p>
<ol>
<li><p>安装pandoc</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">brew </span><span class="keyword">install </span>Pandoc</div></pre></td></tr></table></figure>
</li>
<li><p>安装 <a href="https://github.com/wzpan/hexo-renderer-pandoc" target="_blank" rel="external">hexo-renderer-pandoc</a></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">uninstall</span> hexo-renderer-marked <span class="comment">--save</span></div><div class="line">npm <span class="keyword">install</span> hexo-renderer-pandoc <span class="comment">--save</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="解决方案三：一个个用-转义吧"><a href="#解决方案三：一个个用-转义吧" class="headerlink" title="解决方案三：一个个用\\转义吧"></a>解决方案三：一个个用\\转义吧</h2>]]></content>
    <summary type="html">
    <![CDATA[Hexo默认使用marked.js去解析我们写的markdown，以前用的就很不爽，解析的效果跟atom里预览效果不一致，本来想换个引擎，无奈有一些老的博文需要调整，索性改一下marked.js的解析方法。]]>
    
    </summary>
    
      <category term="blog" scheme="http://miclee.cn/tags/blog/"/>
    
      <category term="blog" scheme="http://miclee.cn/categories/blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python下划线使用]]></title>
    <link href="http://miclee.cn/2017/04/20/Python%E4%B8%8B%E5%88%92%E7%BA%BF%E4%BD%BF%E7%94%A8/"/>
    <id>http://miclee.cn/2017/04/20/Python下划线使用/</id>
    <published>2017-04-20T05:43:52.000Z</published>
    <updated>2017-04-20T09:03:16.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> 在 python 中，下划线命名规则往往令初学者相当疑惑：单下划线、双下划线、双下划线还分前后...那它们的作用与使用场景到底有何区别呢？ </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="单下划线（-）"><a href="#单下划线（-）" class="headerlink" title="单下划线（_）"></a>单下划线（_）</h2><p>通常情况下，会在以下3种场景中使用：</p>
<ol>
<li><p>在解释器中：在这种情况下，‘_‘代表交互式解释器会话中上一条执行的语句的结果。这种用法首先被标准CPython解释器采用，然后其他类型的解释器也先后采用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>_ Traceback (most recent call last):</div><div class="line">File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">NameError: name <span class="string">'_'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">42</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>_</div><div class="line"><span class="number">42</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'alright!'</span> <span class="keyword">if</span> _ <span class="keyword">else</span> <span class="string">':('</span></div><div class="line"><span class="string">'alright!'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>_</div><div class="line"><span class="string">'alright!'</span></div></pre></td></tr></table></figure>
</li>
<li><p>作为一个名称：这与上面一点稍微有些联系，此时‘_‘作为临时性的名称使用。这样，当其他人阅读你的代码时将会知道，你分配了一个特定的名称，但是并不会在后面再次用到该名称。例如，下面的例子中，你可能对循环计数中的实际值并不感兴趣，此时就可以使用‘_‘。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">n = <span class="number">42</span></div><div class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</div><div class="line">    do_something()</div></pre></td></tr></table></figure>
</li>
<li><p>国际化：也许你也曾看到‘_‘会被作为一个函数来使用。这种情况下，它通常用于实现国际化和本地化字符串之间翻译查找的函数名称，这似乎源自并遵循相应的C约定。例如，在Django文档‘转换‘章节中，你将能看到如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> django.utils.translation <span class="keyword">import</span> ugettext <span class="keyword">as</span> _</div><div class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span><span class="params">(request)</span>:</span></div><div class="line">	output = _(<span class="string">"Welcome to my site."</span>)</div><div class="line">	<span class="keyword">return</span> HttpResponse(output)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>可以发现，场景二和场景三中的使用方法可能会相互冲突，所以我们需要避免在使用”_”作为国际化查找转换功能的代码块中同时使用‘_‘作为临时名称。</p>
<h2 id="名称前的单下划线（如：-shahriar）"><a href="#名称前的单下划线（如：-shahriar）" class="headerlink" title="名称前的单下划线（如：_shahriar）"></a>名称前的单下划线（如：_shahriar）</h2><p>程序员使用名称前的单下划线，用于指定该名称属性为‘私有‘。这有点类似于惯例，为了使其他人（或你自己）使用这些代码时将会知道以‘_‘开头的名称只供内部使用。正如Python文档中所述：</p>
<p>以下划线‘_‘为前缀的名称（如_spam）应该被视为API中非公开的部分（不管是函数、方法还是数据成员）。此时，应该将它们看作是一种实现细节，在修改它们时无需对外部通知。</p>
<p>正如上面所说，这确实类似一种惯例，因为它对解释器来说确实有一定的意义，如果你写了代码‘from &lt;模块/包名&gt; import *‘，那么以‘_‘开头的名称都不会被导入，除非模块或包中的‘__all__‘列表显式地包含了它们。了解更多请查看 <a href="https://shahriar.svbtle.com/importing-star-in-python" target="_blank" rel="external">Importing * in Python</a></p>
<h2 id="名称前的双下划线（如：-shahriar）"><a href="#名称前的双下划线（如：-shahriar）" class="headerlink" title="名称前的双下划线（如：__shahriar）"></a>名称前的双下划线（如：__shahriar）</h2><p>名称（具体为一个方法名）前双下划线（__）的用法并不是一种惯例，对解释器来说它有特定的意义。Python中的这种用法是为了避免与子类定义的名称冲突。Python文档指出，‘__spam‘这种形式（至少两个前导下划线，最多一个后续下划线）的任何标识符将会被‘_classname__spam‘这种形式原文取代，在这里‘classname‘是去掉前导下划线的当前类名。例如下面的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">_internal_use</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span><span class="keyword">pass</span></div><div class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">__method_name</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span><span class="keyword">pass</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dir(A())</div><div class="line">[<span class="string">'_A__method_name'</span>, ..., <span class="string">'_internal_use'</span>]</div></pre></td></tr></table></figure></p>
<p>正如所预料的，‘_internal_use‘并未改变，而‘__method_name‘却被变成了‘_ClassName__method_name‘。此时，如果你创建A的一个子类B，那么你将不能轻易地覆写A中的方法‘__method_name‘。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></div><div class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">__method_name</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span><span class="keyword">pass</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dir(B())</div><div class="line">[<span class="string">'_A__method_name'</span>, <span class="string">'_B__method_name'</span>, ..., <span class="string">'_internal_use'</span>]</div></pre></td></tr></table></figure>
<p>通常用作类的私有成员</p>
<h2 id="名称前后的双下划线（如：-init-）"><a href="#名称前后的双下划线（如：-init-）" class="headerlink" title="名称前后的双下划线（如：__init__）"></a>名称前后的双下划线（如：__init__）</h2><p>这种用法表示Python中特殊的方法名。其实，这只是一种惯例，对Python系统来说，这将确保不会与用户自定义的名称冲突。通常，你将会覆写这些方法，并在里面实现你所需要的功能，以便Python调用它们。例如，当定义一个类时，你经常会覆写‘__init__‘方法。</p>
<p>双下划线开头双下划线结尾的是一些 Python 的‘魔术‘对象，如类成员的 __init__、__del__、__add__、__getitem__ 等，以及全局的 __file__、__name__ 等。 Python 官方推荐永远不要将这样的命名方式应用于自己的变量或函数，而是按照文档说明来使用。虽然你也可以编写自己的特殊方法名，但不要这样做。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__mine__</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span>        <span class="keyword">pass</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dir(C)</div><div class="line"><span class="meta">... </span>[..., <span class="string">'__mine__'</span>, ...]</div></pre></td></tr></table></figure>
<h2 id="用-all-暴露接口"><a href="#用-all-暴露接口" class="headerlink" title="用 __all__ 暴露接口"></a>用 __all__ 暴露接口</h2><p>Python 可以在模块级别暴露接口：</p>
<p>__all__ = [“foo”, “bar”]</p>
<p>很多时候这么做还是很有好处的……</p>
<p>提供了哪些是公开接口的约定</p>
<p>不像 Ruby 或者 Java，Python 没有语言原生的可见性控制，而是靠一套需要大家自觉遵守的‘约定‘下工作。比如下划线开头的应该对外部不可见。同样，__all__ 也是对于模块公开接口的一种约定，比起下划线，__all__ 提供了暴露接口用的‘白名单‘。一些不以下划线开头的变量（比如从其他地方 import 到当前模块的成员）可以同样被排除出去。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Python 用下划线作为变量前缀和后缀指定特殊变量。</p>
<ul>
<li>_xxx     不能用’from module import *‘导入</li>
<li>__xxx__  系统定义名字</li>
<li>__xxx    类中的私有变量名</li>
</ul>
<p>_xxx 被看作是‘私有的‘，在模块或类外不可以使用。当变量是私有的时候，用_xxx 来表示变量是很好的习惯。</p>
<p>__xxx__ 对Python 来说有特殊含义，对于普通的变量应当避免这种命名风格。</p>
<p>__xxx 是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。</p>
<h2 id="PEP规范"><a href="#PEP规范" class="headerlink" title="PEP规范"></a>PEP规范</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">PEP-0008:</div><div class="line"></div><div class="line">In addition, the following special forms using leading or trailing underscores are recognized (these can generally be combined with any case convention):</div><div class="line"></div><div class="line"><span class="code">    - _single_leading_underscore: weak "internal use" indicator. E.g. "from M import \*" does not import objects whose name starts with an underscore.</span></div><div class="line"></div><div class="line"><span class="code">    - single_trailing_underscore_: used by convention to avoid conflicts with Python keyword, e.g.</span></div><div class="line"></div><div class="line"><span class="code">      Tkinter.Toplevel(master, class_='ClassName')</span></div><div class="line"></div><div class="line"><span class="code">    - __double_leading_underscore: when naming a class attribute, invokes name mangling (inside class FooBar, __boo becomes _FooBar__boo; see below).</span></div><div class="line"></div><div class="line"><span class="code">    - __double_leading_and_trailing_underscore__: "magic" objects or attributes that live in user-controlled namespaces. E.g. __init__,</span></div><div class="line"><span class="code">      __import__ or __file__. Never invent such names; only use them as documented.</span></div></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[在 python 中，下划线命名规则往往令初学者相当疑惑：单下划线、双下划线、双下划线还分前后...那它们的作用与使用场景到底有何区别呢？]]>
    
    </summary>
    
      <category term="Python" scheme="http://miclee.cn/tags/Python/"/>
    
      <category term="Python" scheme="http://miclee.cn/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java keytool]]></title>
    <link href="http://miclee.cn/2017/04/19/Java_keytool/"/>
    <id>http://miclee.cn/2017/04/19/Java_keytool/</id>
    <published>2017-04-19T09:47:51.000Z</published>
    <updated>2017-04-19T10:18:00.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> Keytool是一个Java数据证书的管理工具，它使用户能够管理自己的公钥/私钥对及相关证书，用于（通过数字签名）自我认证（用户向别的用户/服务认证自己）或数据完整性以及认证服务。它还允许用户储存他们的通信对等者的公钥（以证书形式）。Keytool将密钥（key）和证书（certificates）存在一个称为秘钥仓库(keystore)的文件中。 </em></strong><br><a id="more"></a></p>
<hr>
<p>在keystore里，包含两种数据：</p>
<ul>
<li><p>密钥实体（Key entity）<br>每项存放极为敏感的加密密钥信息，这种信息以一种受保护的格式储存以防止未授权的访问。通常，储存在这类项中的密钥是机密密钥，或是伴有用于认证相应公钥用的证书“链”的私钥。keytool 和 jarsigner 工具只处理后一类型的项，即私钥及其关联的证书链。</p>
</li>
<li><p>可信任的证书实体（trusted certificate entries）<br>每项包含一个属于另一团体的公钥证书。它之所以叫做“可信任的证书”，是因为密钥仓库的拥有者相信证书中的公钥确实属于证书“主体”（拥有者）识别的身份。证书签发人通过对证书签名来保证这点。</p>
</li>
</ul>
<h2 id="生成keystore"><a href="#生成keystore" class="headerlink" title="生成keystore"></a>生成keystore</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keytool -genkey -<span class="built_in">alias</span> miclee -keyalg RSA -validity <span class="number">1000</span> -keystore miclee.keystore</div></pre></td></tr></table></figure>
<h2 id="查看证书"><a href="#查看证书" class="headerlink" title="查看证书"></a>查看证书</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keytool -<span class="type">list</span> -keystore miclee.keystore -storepass <span class="number">123456</span> -v</div></pre></td></tr></table></figure>
<h2 id="导出证书（只能导出公钥）"><a href="#导出证书（只能导出公钥）" class="headerlink" title="导出证书（只能导出公钥）"></a>导出证书（只能导出公钥）</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keytool -exportcert -alias miclee -keystore miclee<span class="selector-class">.keystore</span> -file miclee<span class="selector-class">.crt</span> -storepass <span class="number">123456</span></div></pre></td></tr></table></figure>
<p>导出的miclee.crt为二进制格式，如果想要ASCII格式，请参考博文：<a href="http://miclee.cn/2017/04/19/certificate/">安全证书</a></p>
<h2 id="查看导出的证书"><a href="#查看导出的证书" class="headerlink" title="查看导出的证书"></a>查看导出的证书</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keytool -printcert -<span class="built_in">file</span> miclee.crt</div></pre></td></tr></table></figure>
<h2 id="证书条目的删除"><a href="#证书条目的删除" class="headerlink" title="证书条目的删除"></a>证书条目的删除</h2><figure class="highlight d"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keytool -<span class="keyword">delete</span> -<span class="keyword">alias</span> miclee -keystore miclee.keystore -storepass <span class="number">123456</span></div></pre></td></tr></table></figure>
<h2 id="证书条目口令的修改"><a href="#证书条目口令的修改" class="headerlink" title="证书条目口令的修改"></a>证书条目口令的修改</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keytool -keypasswd -alias miclee -keypass <span class="number">123456</span> -new <span class="number">654321</span> -keystore miclee.keystore -storepass <span class="number">123456</span></div></pre></td></tr></table></figure>
<h2 id="keystore口令的修改"><a href="#keystore口令的修改" class="headerlink" title="keystore口令的修改"></a>keystore口令的修改</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keytool -storepasswd -keystore miclee.keystore -storepass <span class="number">123456</span> -new <span class="number">654321</span></div></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[Keytool是一个Java数据证书的管理工具，它使用户能够管理自己的公钥/私钥对及相关证书，用于（通过数字签名）自我认证（用户向别的用户/服务认证自己）或数据完整性以及认证服务。它还允许用户储存他们的通信对等者的公钥（以证书形式）。Keytool将密钥（key）和证书（certificates）存在一个称为秘钥仓库(keystore)的文件中。]]>
    
    </summary>
    
      <category term="加密技术" scheme="http://miclee.cn/tags/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/"/>
    
      <category term="加密技术" scheme="http://miclee.cn/categories/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[安全证书]]></title>
    <link href="http://miclee.cn/2017/04/19/certificate/"/>
    <id>http://miclee.cn/2017/04/19/certificate/</id>
    <published>2017-04-19T09:09:27.000Z</published>
    <updated>2017-04-19T10:25:46.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> 证书、标准、格式、转换方式 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h2><p>SSL - Secure Sockets Layer，现在应该叫”TLS”，但由于习惯问题，我们还是叫”SSL”比较多.http协议默认情况下是不加密内容的，这样就很可能在内容传播的时候被别人监听到，对于安全性要求较高的场合，必须要加密，https就是带加密的http协议，而https的加密是基于SSL的，它执行的是一个比较下层的加密，也就是说，在加密前，你的服务器程序在干嘛，加密后也一样在干嘛，不用动，这个加密对用户和开发者来说都是透明的。</p>
<h2 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h2><p>OpenSSL - 简单地说，OpenSSL是SSL的一个实现，SSL只是一种规范.理论上来说，SSL这种规范是安全的，目前的技术水平很难破解，但SSL的实现就可能有些漏洞，如著名的”心脏出血”.OpenSSL还提供了一大堆强大的工具软件，强大到90%我们都用不到.</p>
<h2 id="证书标准-X-509"><a href="#证书标准-X-509" class="headerlink" title="证书标准-X.509"></a>证书标准-X.509</h2><p>X.509是常见通用的证书标准，主要定义了证书中应该包含哪些内容。所有的证书都符合为Public Key<br>Infrastructure (PKI) 制定的 ITU-T X509 国际标准。其详情可以参考RFC5280，SSL使用的就是这种证书标准。</p>
<h2 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h2><ul>
<li><strong>PEM - Privacy Enhanced Mail</strong><br>PEM格式通常用于数字证书认证机构（Certificate Authorities，CA）。内容为Base64编码的ASCII码文件，有类似”—–BEGIN CERTIFICATE—–” 和 “—–END CERTIFICATE—–”的头尾标记。服务器认证证书，中级认证证书和私钥都可以储存为PEM格式（认证证书其实就是公钥）。Apache和*NIX服务器偏向于使用这种编码格式。</li>
</ul>
<p>常用扩展名：.pem | .crt | .cer | .key</p>
<p>查看PEM格式证书的信息：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl x509 -<span class="keyword">in</span> certificate<span class="selector-class">.pem</span> -text -noout</div></pre></td></tr></table></figure></p>
<ul>
<li><strong>DER - Distinguished Encoding Rules</strong><br>DER格式与PEM不同之处在于其使用二进制而不是Base64编码的ASCII。所有类型的认证证书和私钥都可以存储为DER格式。Java和Windows服务器偏向于使用这种编码格式。</li>
</ul>
<p>常用扩展名：.der | .cer</p>
<p>查看DER格式证书的信息：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl x509 -<span class="keyword">in</span> certificate<span class="selector-class">.der</span> -inform der -text -noout</div></pre></td></tr></table></figure></p>
<ul>
<li><strong>PKCS - Public-Key Cryptography Standards</strong><br>PKCS是由 RSA 实验室与其它安全系统开发商为促进公钥密码的发展而制订的一系列标准，PKCS 目前共发布过 15 个标准。 常用的有：<ul>
<li>PKCS#7 Cryptographic Message Syntax Standard</li>
<li>PKCS#10 Certification Request Standard</li>
<li>PKCS#12 Personal Information Exchange Syntax Standard</li>
</ul>
</li>
</ul>
<h2 id="转换方式"><a href="#转换方式" class="headerlink" title="转换方式"></a>转换方式</h2><ul>
<li><p><strong>PEM &lt;-&gt; DER</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">openssl x509 -outform der -<span class="keyword">in</span> certificate<span class="selector-class">.pem</span> -out certificate<span class="selector-class">.der</span></div><div class="line"></div><div class="line">openssl x509 -inform der -<span class="keyword">in</span> certificate<span class="selector-class">.cer</span> -out certificate.pem</div></pre></td></tr></table></figure>
</li>
<li><p><strong>PEM &lt;-&gt; P7B</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">openssl crl2pkcs7 -nocrl -certfile certificate<span class="selector-class">.cer</span> -out certificate<span class="selector-class">.p7b</span> -certfile CACert<span class="selector-class">.cer</span></div><div class="line"></div><div class="line">openssl pkcs7 -print_certs -<span class="keyword">in</span> certificate<span class="selector-class">.p7b</span> -out certificate.cer</div></pre></td></tr></table></figure>
</li>
<li><p><strong>PEM &lt;-&gt; PFX</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">openssl pkcs12 -export -out certificate<span class="selector-class">.pfx</span> -inkey privateKey<span class="selector-class">.key</span> -<span class="keyword">in</span> certificate<span class="selector-class">.crt</span> -certfile CACert<span class="selector-class">.crt</span></div><div class="line"></div><div class="line">openssl pkcs12 -<span class="keyword">in</span> certificate<span class="selector-class">.pfx</span> -out certificate<span class="selector-class">.cer</span> -nodes</div></pre></td></tr></table></figure>
</li>
</ul>
<p>PXF转PEM后certificate.cer文件包含认证证书和私钥，需要把它们分开存储才能使用。</p>
<p>要转换KEY文件也类似，只不过把x509换成rsa，要转CSR的话，把x509换成req</p>
<h2 id="证书获取"><a href="#证书获取" class="headerlink" title="证书获取"></a>证书获取</h2><ul>
<li><strong>向权威证书颁发机构申请证书</strong><br>用这命令生成一个csr:<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">openssl</span> <span class="selector-tag">req</span> <span class="selector-tag">-newkey</span> <span class="selector-tag">rsa</span><span class="selector-pseudo">:2048</span> <span class="selector-tag">-new</span> <span class="selector-tag">-nodes</span> <span class="selector-tag">-keyout</span> <span class="selector-tag">my</span><span class="selector-class">.key</span> <span class="selector-tag">-out</span> <span class="selector-tag">my</span><span class="selector-class">.csr</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>把csr交给权威证书颁发机构，权威证书颁发机构对此进行签名，完成.保留好csr，当权威证书颁发机构颁发的证书过期的时候，你还可以用同样的csr来申请新的证书，key保持不变。</p>
<ul>
<li><strong>生成自签名的证书</strong><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">openssl</span> <span class="selector-tag">req</span> <span class="selector-tag">-newkey</span> <span class="selector-tag">rsa</span><span class="selector-pseudo">:2048</span> <span class="selector-tag">-new</span> <span class="selector-tag">-nodes</span> <span class="selector-tag">-x509</span> <span class="selector-tag">-days</span> 3650 <span class="selector-tag">-keyout</span> <span class="selector-tag">key</span><span class="selector-class">.pem</span> <span class="selector-tag">-out</span> <span class="selector-tag">cert</span><span class="selector-class">.pem</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>在生成证书的过程中会要你填一堆的东西，其实真正要填的只有Common Name，通常填写你服务器的域名，如”yourcompany.com”，或者你服务器的IP地址，其它都可以留空的.<br>生产环境中还是不要使用自签的证书，否则浏览器会不认，或者如果你是企业应用的话能够强制让用户的浏览器接受你的自签证书也行.向权威机构要证书通常是要钱的，但现在也有免费的，仅仅需要一个简单的域名验证即可。有兴趣的话查查”沃通数字证书”。</p>
]]></content>
    <summary type="html">
    <![CDATA[证书、标准、格式、转换方式]]>
    
    </summary>
    
      <category term="加密技术" scheme="http://miclee.cn/tags/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/"/>
    
      <category term="加密技术" scheme="http://miclee.cn/categories/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python之禅]]></title>
    <link href="http://miclee.cn/2017/04/19/Python%E4%B9%8B%E7%A6%85/"/>
    <id>http://miclee.cn/2017/04/19/Python之禅/</id>
    <published>2017-04-19T06:41:37.000Z</published>
    <updated>2017-05-12T09:49:39.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> 有人说，要想学好一门编程语言，你就需要接受这门语言的哲学。那么如果你想精通Python，就需要践行Python背后的设计哲学。 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="python哲学"><a href="#python哲学" class="headerlink" title="python哲学"></a>python哲学</h2><p>Python之所以与众不同，在于它强调一种哲学理念，用黑字表示强调吧：</p>
<p><strong>Python的设计哲学是“优雅”、“明确”、“简单”。</strong></p>
<p>Python开发者的哲学是“用一种方法，最好是只有一种方法来做一件事。在设计Python语言时，如果面临多种选择，Python开发者一般会拒绝花俏的语法，而选择明确没有或者很少有歧义的语法。由于这种设计观念的差异，Python源代码通常具备更好的可读性，并且能够支撑大规模的软件开发。这些准则被称为Python格言。  </p>
<h2 id="The-Zen-of-Python"><a href="#The-Zen-of-Python" class="headerlink" title="The Zen of Python"></a>The Zen of Python</h2><p>Python之父是荷兰人Guido van Rossum，被誉为历史上最伟大的12名程序员之一。他在设计Python时，目的是设计出一种优美而强大，提供给非专业程序设计师使用的语言，同时采取开放策略，使Python能够完美结合如C 、 C++和Java等其他语言。Guido对python设计之初提出了规范和风格，名为“Pythonic”，它指的是以Python的方式去编写代码、组织逻辑和对象行为。而对Python哲学的最好阐述，莫过于核心开发者Tim Peters所总结的“Python之禅”（The Zen of Python）了。启动Python解释器后，输入import this就可以看到全文了。</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import this</div><div class="line"></div><div class="line">The Zen <span class="keyword">of</span> Python, <span class="keyword">by</span> Tim Peters</div><div class="line"></div><div class="line">Beautiful <span class="keyword">is</span> better than ugly.</div><div class="line"><span class="keyword">Explicit</span> <span class="keyword">is</span> better than implicit.</div><div class="line">Simple <span class="keyword">is</span> better than complex.</div><div class="line">Complex <span class="keyword">is</span> better than complicated.</div><div class="line">Flat <span class="keyword">is</span> better than nested.</div><div class="line">Sparse <span class="keyword">is</span> better than dense.</div><div class="line">Readability counts.</div><div class="line">Special cases aren<span class="comment">'t special enough to break the rules.</span></div><div class="line">Although practicality beats purity.</div><div class="line">Errors should never pass silently.</div><div class="line">Unless explicitly silenced.</div><div class="line"><span class="keyword">In</span> the face <span class="keyword">of</span> ambiguity, refuse the temptation <span class="keyword">to</span> guess.</div><div class="line">There should be one-- <span class="keyword">and</span> preferably only one --obvious way <span class="keyword">to</span> <span class="keyword">do</span> it.</div><div class="line">Although that way may <span class="keyword">not</span> be obvious at first unless you<span class="comment">'re Dutch.</span></div><div class="line">Now <span class="keyword">is</span> better than never.</div><div class="line">Although never <span class="keyword">is</span> often better than *right* now.</div><div class="line"><span class="keyword">If</span> the implementation <span class="keyword">is</span> hard <span class="keyword">to</span> explain, it<span class="comment">'s a bad idea.</span></div><div class="line"><span class="keyword">If</span> the implementation <span class="keyword">is</span> easy <span class="keyword">to</span> explain, it may be a good idea.</div><div class="line">Namespaces are one honking great idea -- <span class="keyword">let</span><span class="comment">'s do more of those!</span></div></pre></td></tr></table></figure>
<h2 id="Python之禅"><a href="#Python之禅" class="headerlink" title="Python之禅"></a>Python之禅</h2><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">优美胜于丑陋，</div><div class="line">明了胜于晦涩。</div><div class="line">简洁胜于复杂，</div><div class="line">复杂胜于凌乱。</div><div class="line">扁平胜于嵌套，</div><div class="line">稀疏胜于密繁。</div><div class="line">可读性很重要！</div><div class="line">即便假借特例的实用性之名，也不可违背这些规则。</div><div class="line">不要放过一切错误，除非错误本身需要以忽略对待。</div><div class="line">不确定面前，我们应抵挡妄加猜测的引诱。</div><div class="line">应该有一种，也但愿只有这一种是显而易见的解决之道。</div><div class="line">万事开头难，除非荷兰人。</div><div class="line">做好过不做，而不假思索就动手还不如不做。</div><div class="line">如果某个实现无法很好阐释，那么它肯定是一个糟糕的办法；</div><div class="line">如果某个实现很容易说清楚，那么它可能就是个不错的方案。</div><div class="line">命名空间是个绝妙的发明——对此我们应多多益善！</div></pre></td></tr></table></figure>
<h2 id="蛇宗三字经"><a href="#蛇宗三字经" class="headerlink" title="蛇宗三字经"></a>蛇宗三字经</h2><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">美胜丑</div><div class="line">明胜暗</div><div class="line">简胜复</div><div class="line">复胜杂</div><div class="line">浅胜深</div><div class="line">疏胜密</div><div class="line">辞达意</div><div class="line">不逾矩</div><div class="line">弃至清</div><div class="line">无阴差</div><div class="line">有阳错</div><div class="line">拒疑数</div><div class="line">求完一</div><div class="line">虽不至，向往之</div><div class="line">敏于行</div><div class="line">戒莽撞</div><div class="line">差难言</div><div class="line">好易说</div><div class="line">每师出，多有名</div></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[有人说，要想学好一门编程语言，你就需要接受这门语言的哲学。那么如果你想精通Python，就需要践行Python背后的设计哲学。]]>
    
    </summary>
    
      <category term="Python" scheme="http://miclee.cn/tags/Python/"/>
    
      <category term="Python" scheme="http://miclee.cn/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[virtualenvwrapper设置]]></title>
    <link href="http://miclee.cn/2017/04/18/py_virtualenvwrapper/"/>
    <id>http://miclee.cn/2017/04/18/py_virtualenvwrapper/</id>
    <published>2017-04-18T11:16:24.000Z</published>
    <updated>2017-04-19T05:17:01.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> virtualenv 是一个可以在同一计算机中隔离多个python版本的工具。有时，两个不同的项目可能需要不同版本的python，如 python2.6.6 / python3.0 ，但是如果都装到一起，经常会导致问题。所以需要一个工具能够将这两种或几种不同版本的环境隔离开来，需要哪个版本就切换到哪个版本做为默认版本。virtualenv 既是满足这个需求的工具。它能够用于创建独立的Python环境，多个Python相互独立，互不影响。 </em></strong><br><a id="more"></a></p>
<hr>
<p>virtualenvwrapper是virtualenv的扩展管理包，用于更方便管理虚拟环境，它可以做：</p>
<ul>
<li>将所有虚拟环境整合在一个目录下</li>
<li>管理（新增，删除，复制）虚拟环境</li>
<li>切换虚拟环境</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pip <span class="keyword">install</span> virtualenv</div><div class="line">pip <span class="keyword">install</span> virtualenvwrapper</div></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在 ~/.bash_profile 文件里添加以下配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> WORKON_HOME=~/.virtualenvs</div><div class="line"><span class="built_in">source</span> /usr/<span class="built_in">local</span>/bin/virtualenvwrapper.sh</div></pre></td></tr></table></figure>
<p>别忘了执行 source .bash_profile</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>所有的命令可使用：virtualenvwrapper –help 进行查看，这里列出几个常用的：</p>
<ul>
<li>创建基本环境：mkvirtualenv [环境名]</li>
<li>删除环境：rmvirtualenv [环境名]</li>
<li>激活环境：workon [环境名]</li>
<li>退出环境：deactivate</li>
<li>列出所有环境：workon 或者 lsvirtualenv -b</li>
</ul>
<h2 id="安装Python3-环境"><a href="#安装Python3-环境" class="headerlink" title="安装Python3 环境"></a>安装Python3 环境</h2><p>先安装Python3：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">brew </span><span class="keyword">install </span>Python3</div></pre></td></tr></table></figure>
<p>创建环境：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkvirtualenv --python=<span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>python3 envname</div></pre></td></tr></table></figure>
<p>查看环境：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">workon</span></div></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[virtualenv 是一个可以在同一计算机中隔离多个python版本的工具。有时，两个不同的项目可能需要不同版本的python，如 python2.6.6 / python3.0 ，但是如果都装到一起，经常会导致问题。所以需要一个工具能够将这两种或几种不同版本的环境隔离开来，需要哪个版本就切换到哪个版本做为默认版本。virtualenv 既是满足这个需求的工具。它能够用于创建独立的Python环境，多个Python相互独立，互不影响。]]>
    
    </summary>
    
      <category term="Python" scheme="http://miclee.cn/tags/Python/"/>
    
      <category term="Python" scheme="http://miclee.cn/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Jupyter 安装]]></title>
    <link href="http://miclee.cn/2017/04/18/py_jurpyter/"/>
    <id>http://miclee.cn/2017/04/18/py_jurpyter/</id>
    <published>2017-04-18T11:09:03.000Z</published>
    <updated>2017-04-19T02:37:33.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> Jupyter NoteBook 支持python2和3 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="全新安装"><a href="#全新安装" class="headerlink" title="全新安装"></a>全新安装</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip3 <span class="keyword">install</span> jupyter</div></pre></td></tr></table></figure>
<h2 id="增加Python3的支持"><a href="#增加Python3的支持" class="headerlink" title="增加Python3的支持"></a>增加Python3的支持</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">python3 -m pip <span class="keyword">install</span> ipykernel</div><div class="line">python3 -m ipykernel <span class="keyword">install</span> <span class="comment">--user</span></div></pre></td></tr></table></figure>
<h2 id="增加Python2的支持"><a href="#增加Python2的支持" class="headerlink" title="增加Python2的支持"></a>增加Python2的支持</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">python -m pip <span class="keyword">install</span> ipykernel</div><div class="line">python -m ipykernel <span class="keyword">install</span> <span class="comment">--user</span></div></pre></td></tr></table></figure>
<h2 id="新的启动命令"><a href="#新的启动命令" class="headerlink" title="新的启动命令"></a>新的启动命令</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">jupyter notebook</span></div></pre></td></tr></table></figure>
<h2 id="页面支持内嵌图表"><a href="#页面支持内嵌图表" class="headerlink" title="页面支持内嵌图表"></a>页面支持内嵌图表</h2><p>在notebook页面执行：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">%<span class="selector-tag">pylab</span></span> inline</div></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[Jupyter NoteBook 支持python2和3]]>
    
    </summary>
    
      <category term="Python" scheme="http://miclee.cn/tags/Python/"/>
    
      <category term="Python" scheme="http://miclee.cn/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python模块 - collections]]></title>
    <link href="http://miclee.cn/2017/03/13/py_collections/"/>
    <id>http://miclee.cn/2017/03/13/py_collections/</id>
    <published>2017-03-13T06:54:36.000Z</published>
    <updated>2017-04-19T02:06:52.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> collections是Python内建的一个集合模块，提供了许多有用的集合类。 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="defaultdict-带有默认值的字典"><a href="#defaultdict-带有默认值的字典" class="headerlink" title="defaultdict 带有默认值的字典"></a>defaultdict 带有默认值的字典</h2><p>我们都知道，在使用Python原生的数据结构dict的时候，如果用 d[key] 这样的方式访问， 当指定的key不存在时，是会抛出KeyError异常的。</p>
<p>但是，如果使用defaultdict，只要你传入一个默认的类型或工厂方法，那么请求一个不存在的key时，便会调用这个工厂方法使用其结果来作为这个key的默认值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</div><div class="line"></div><div class="line">members = [</div><div class="line">    <span class="comment"># Age, name</span></div><div class="line">    [<span class="string">'male'</span>, <span class="string">'John'</span>],</div><div class="line">    [<span class="string">'male'</span>, <span class="string">'Jack'</span>],</div><div class="line">    [<span class="string">'female'</span>, <span class="string">'Lily'</span>],</div><div class="line">    [<span class="string">'male'</span>, <span class="string">'Pony'</span>],</div><div class="line">    [<span class="string">'female'</span>, <span class="string">'Lucy'</span>],</div><div class="line">]</div><div class="line"></div><div class="line">result = defaultdict(list)</div><div class="line"><span class="keyword">for</span> sex, name <span class="keyword">in</span> members:</div><div class="line">    result[sex].append(name)</div><div class="line"></div><div class="line"><span class="keyword">print</span> result</div><div class="line"></div><div class="line"><span class="comment"># Result:</span></div><div class="line"><span class="comment"># defaultdict(&lt;type 'list'&gt;, &#123;'male': ['John', 'Jack', 'Pony'], 'female': ['Lily', 'Lucy']&#125;)</span></div></pre></td></tr></table></figure>
<h3 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h3><p>namedtuple主要用来产生可以使用名称来访问元素的数据对象，通常用来增强代码的可读性， 在访问一些tuple类型的数据时尤其好用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</div><div class="line"></div><div class="line">websites = [</div><div class="line">    (<span class="string">'google'</span>, <span class="string">'http://www.google.com/'</span>, <span class="string">u'拉里·佩奇'</span>),</div><div class="line">    (<span class="string">'facebook'</span>, <span class="string">'http://www.facebook.com/'</span>, <span class="string">u'马克·扎克伯格'</span>),</div><div class="line">    (<span class="string">'taobao'</span>, <span class="string">'http://www.taobao.com'</span>, <span class="string">u'马云'</span>)</div><div class="line">]</div><div class="line"></div><div class="line">Website = namedtuple(<span class="string">'Website'</span>, [<span class="string">'name'</span>, <span class="string">'url'</span>, <span class="string">'founder'</span>])</div><div class="line"></div><div class="line"><span class="keyword">for</span> website <span class="keyword">in</span> websites:</div><div class="line">    website = Website._make(website)</div><div class="line">    print(website)</div><div class="line"></div><div class="line"><span class="comment"># Result:</span></div><div class="line"><span class="comment"># Website(name='google', url='http://www.google.com/', founder='拉里·佩奇')</span></div><div class="line"><span class="comment"># Website(name='facebook', url='http://www.facebook.com/', founder='马克·扎克伯格')</span></div><div class="line"><span class="comment"># Website(name='taobao', url='http://www.taobao.com', founder='马云')</span></div></pre></td></tr></table></figure>
<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>deque其实是 double-ended queue 的缩写，翻译过来就是双端队列，它最大的好处就是实现了从队列 头部快速增加和取出对象: .popleft(), .appendleft() 。</p>
<p>你可能会说，原生的list也可以从头部添加和取出对象啊？就像这样：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">l</span><span class="selector-class">.insert</span>(0, <span class="selector-tag">v</span>)</div><div class="line"><span class="selector-tag">l</span><span class="selector-class">.pop</span>(0)</div></pre></td></tr></table></figure>
<p>但是值得注意的是，list对象的这两种用法的时间复杂度是 O(n) ，也就是说随着元素数量的增加耗时呈 线性上升。而使用deque对象则是 O(1) 的复杂度，所以当你的代码有这样的需求的时候， 一定要记得使用deque。</p>
<p>作为一个双端队列，deque还提供了一些其他的好用方法，比如 rotate 等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</div><div class="line"></div><div class="line">fancy_loading = deque(<span class="string">'------&gt;---托--乐--嘉--花--园---&gt;------'</span>)</div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    <span class="keyword">print</span> <span class="string">'\r%s'</span> % <span class="string">''</span>.join(fancy_loading),</div><div class="line">    fancy_loading.rotate(<span class="number">1</span>)</div><div class="line">    sys.stdout.flush()</div><div class="line">    time.sleep(<span class="number">0.15</span>)</div></pre></td></tr></table></figure>
<h3 id="Counter-计时器"><a href="#Counter-计时器" class="headerlink" title="Counter 计时器"></a>Counter 计时器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</div><div class="line">c = Counter(time_zones)</div><div class="line"><span class="comment"># 最多的10个</span></div><div class="line"><span class="keyword">print</span> c.most_common(<span class="number">10</span>)</div></pre></td></tr></table></figure>
<h3 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h3><p>在Python中，dict这个数据结构由于hash的特性，是无序的，这在有的时候会给我们带来一些麻烦， 幸运的是，collections模块为我们提供了OrderedDict，当你要获得一个有序的字典对象时，用它就对了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</div><div class="line"></div><div class="line">items = (</div><div class="line">    (<span class="string">'A'</span>, <span class="number">1</span>),</div><div class="line">    (<span class="string">'B'</span>, <span class="number">2</span>),</div><div class="line">    (<span class="string">'C'</span>, <span class="number">3</span>)</div><div class="line">)</div><div class="line"></div><div class="line">regular_dict = dict(items)</div><div class="line">ordered_dict = OrderedDict(items)</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">'Regular Dict:'</span></div><div class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> regular_dict.items():</div><div class="line">    <span class="keyword">print</span> k, v</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">'Ordered Dict:'</span></div><div class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> ordered_dict.items():</div><div class="line">    <span class="keyword">print</span> k, v</div><div class="line"></div><div class="line"><span class="comment"># Result:</span></div><div class="line"><span class="comment"># Regular Dict:</span></div><div class="line"><span class="comment"># A 1</span></div><div class="line"><span class="comment"># C 3</span></div><div class="line"><span class="comment"># B 2</span></div><div class="line"><span class="comment"># Ordered Dict:</span></div><div class="line"><span class="comment"># A 1</span></div><div class="line"><span class="comment"># B 2</span></div><div class="line"><span class="comment"># C 3</span></div></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[collections是Python内建的一个集合模块，提供了许多有用的集合类。]]>
    
    </summary>
    
      <category term="Python" scheme="http://miclee.cn/tags/Python/"/>
    
      <category term="Python" scheme="http://miclee.cn/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JPA 对象关系模型之继承映射策略]]></title>
    <link href="http://miclee.cn/2016/05/25/jpa-inherit-type/"/>
    <id>http://miclee.cn/2016/05/25/jpa-inherit-type/</id>
    <published>2016-05-25T09:00:27.000Z</published>
    <updated>2017-05-11T10:56:56.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> Java 是一种面向对象的语言，面向对象的语言特的性之一就是继承。而关系型数据库中的表与表之间的关系，并没有这种继承关系，不能说一张表继承另一张表，它们之间的关系只是关联关系。那么现在 JPA 要将 POJO 的 Java 类映射到数据库中，对于 Java 类中的这种继承关系是如何映射到数据库中的呢。JPA 规范中现在提供了三种不同的策略来实现继承与关系之间的映射。 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><h3 id="一、Single-table-策略"><a href="#一、Single-table-策略" class="headerlink" title="一、Single-table 策略"></a>一、Single-table 策略</h3><p>这是继承映射中的缺省策略，在不特别指明的情况下，系统默认就是采用这种映射策略进行映射的。这个策略的映射原则就是父类包括子类中新添加的属性全部映射到一张数据库表中，数据库表中有一个自动生成的字段用来存储区分不同的子类的信息。</p>
<p><strong><em>就是不管有几张子实体，统统存在一张表里，父实体会为每个子实体冗余一条数据，通过自动生成的’DTYPE’字段来区分属于谁的数据。</em></strong></p>
<h3 id="二、Joined-subclass-策略"><a href="#二、Joined-subclass-策略" class="headerlink" title="二、Joined-subclass 策略"></a>二、Joined-subclass 策略</h3><p>这种映射策略中，继承关系中的每一个实体类，无论是具体类 (concrete entity) 或者抽象类 (abstract entity)，数据库中都有一个单独的表与他对应。子实体对应的表中不含有从根实体继承而来的属性，它们之间通过共享主键的方式进行关联。</p>
<p><strong><em>子实体会自动存入父实体的主键ID字段，父实体会为每个子实体存一条记录，通过自动生成的’DTYPE’字段来区分属于谁的数据。</em></strong></p>
<h3 id="三、Table-per-concrete-class-策略"><a href="#三、Table-per-concrete-class-策略" class="headerlink" title="三、Table-per-concrete-class 策略"></a>三、Table-per-concrete-class 策略</h3><p>这个策略就是将继承关系中的每一个实体映射到数据库中的一个单独的表中，与“Joined”策略不同的是，子实体对应的表中含有从根实体继承而来的属性。这种策略在 JPA2.0 中仍然是自由选取得，也就是说实现 JPA2.0 规范的持久化引擎，如 Toplink，Hibernate 等 , 仍然可以自由选取是否实现这种策略。</p>
<p><strong><em>每个子实体都有单独表冗余进父实体的字段</em></strong></p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>得益于注解 (annotation) 方式的使用，JPA 2.0 中实现继承关系的映射非常简单。当实体 (entity) 之间有继承关系的时候，一定有一个根实体 (root entity)，JPA2.0 中只需要在这个根实体 (root entity) 上标注 @Inheritance 注解并且指明想要采用的映射策略就可以了。如果是不用 @Inheritance 注解，或者使用了 @Inheritance 注解但是没有指明所要采用的映射策略的时候，默认就是采用单表策略 (Single-table strategy)。下面用图 1 这个继承关系分别说明这三种映射策略的使用。</p>
<h3 id="1、-Inheritance"><a href="#1、-Inheritance" class="headerlink" title="1、@Inheritance"></a>1、@Inheritance</h3><p>用于父，对应策略一</p>
<h3 id="2、-Inheritance-strategy-InheritanceType-JOINED"><a href="#2、-Inheritance-strategy-InheritanceType-JOINED" class="headerlink" title="2、@Inheritance(strategy=InheritanceType.JOINED)"></a>2、@Inheritance(strategy=InheritanceType.JOINED)</h3><p>用于父，对应策略二</p>
<h3 id="3、-Inheritance-strategy-InheritanceType-TABLE-PER-CLASS"><a href="#3、-Inheritance-strategy-InheritanceType-TABLE-PER-CLASS" class="headerlink" title="3、 @Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)"></a>3、 @Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)</h3><p>用于父，对应策略三</p>
<h3 id="4、用-MappedSuperclass来替代-Entity"><a href="#4、用-MappedSuperclass来替代-Entity" class="headerlink" title="4、用@MappedSuperclass来替代@Entity"></a>4、用@MappedSuperclass来替代@Entity</h3><p>用于父，父实体一般为抽象的不用被实例，数据库不会生成对应表，子实体会继承字段</p>
<h3 id="5、-Embeddable-和-Embedded"><a href="#5、-Embeddable-和-Embedded" class="headerlink" title="5、@Embeddable 和 @Embedded"></a>5、@Embeddable 和 @Embedded</h3><p>@Embeddable用于父，@Embedded用于子。嵌套映射，子实体里定义父实体的类型变量。</p>
<p><strong><em>需要注意的是，如有重复字段，需要用 @Transient 注解排除 </em></strong></p>
<p><strong><em>实际使用中可以用改良版 Joined-subclass 策略，父实体和子实体各自一张表，父实体只存储一份数据，由子实体通过父ID共享。</em></strong></p>
]]></content>
    <summary type="html">
    <![CDATA[Java 是一种面向对象的语言，面向对象的语言特的性之一就是继承。而关系型数据库中的表与表之间的关系，并没有这种继承关系，不能说一张表继承另一张表，它们之间的关系只是关联关系。那么现在 JPA 要将 POJO 的 Java 类映射到数据库中，对于 Java 类中的这种继承关系是如何映射到数据库中的呢。JPA 规范中现在提供了三种不同的策略来实现继承与关系之间的映射。]]>
    
    </summary>
    
      <category term="jpa" scheme="http://miclee.cn/tags/jpa/"/>
    
      <category term="spring" scheme="http://miclee.cn/categories/spring/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis 安装]]></title>
    <link href="http://miclee.cn/2016/05/12/redis-setup/"/>
    <id>http://miclee.cn/2016/05/12/redis-setup/</id>
    <published>2016-05-12T08:33:43.000Z</published>
    <updated>2016-05-12T13:02:19.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> Redis是一个开源、支持网络、基于内存、键值对存储数据库，使用ANSI C编写， redis中文官方网站：[http://redis.cn/](http://redis.cn/) </em></strong><br><a id="more"></a></p>
<hr>
<h3 id="一、下载"><a href="#一、下载" class="headerlink" title="一、下载"></a>一、下载</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ wget http:<span class="comment">//download.redis.io/releases/redis-3.2.0.tar.gz</span></div><div class="line">$ tar -xzf redis-<span class="number">3.2</span>.<span class="number">0</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></div></pre></td></tr></table></figure>
<h3 id="二、编译"><a href="#二、编译" class="headerlink" title="二、编译"></a>二、编译</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>cd redis-<span class="number">3.2</span>.<span class="number">0</span></div><div class="line"><span class="variable">$ </span>make</div></pre></td></tr></table></figure>
<h3 id="三、安装"><a href="#三、安装" class="headerlink" title="三、安装"></a>三、安装</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>make PREFIX=<span class="regexp">/usr/local</span><span class="regexp">/redis install</span></div></pre></td></tr></table></figure>
<p>这步完了之后，Redis就被安装到了/usr/local/redis/ 下面了</p>
<h3 id="四、测试"><a href="#四、测试" class="headerlink" title="四、测试"></a>四、测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ make <span class="built_in">test</span></div></pre></td></tr></table></figure>
<blockquote>
<p>如果没安装有tcl那么会包下面这错误：<br>    You need tcl 8.5 or newer in order to run the Redis test​<br>   【安装Tcl-8.6.3】<br>​     [root@localhost202 src]# wget <a href="http://downloads.sourceforge.net/tcl/tcl8.6.3-src.tar.gz" target="_blank" rel="external">http://downloads.sourceforge.net/tcl/tcl8.6.3-src.tar.gz</a><br>     [root@localhost202 src]# tar -zxf tcl8.6.3-src.tar.gz<br>     [root@localhost202 src]# cd ​tcl8.6.3/unix/<br>     [root@localhost202 src]# ./configure<br>     [root@localhost202 src]# make<br>     [root@localhost202 src]# make install</p>
</blockquote>
<h3 id="五、配置"><a href="#五、配置" class="headerlink" title="五、配置"></a>五、配置</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ cp src/redis-server src/redis-cli <span class="meta-keyword">/usr/</span>bin/bin</div><div class="line">$ cp ./redis.conf <span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/redis/</span></div><div class="line">$ vim <span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/redis/</span>redis.conf</div><div class="line"></div><div class="line">daemonize   yes      <span class="meta">#redis将以守护进程的方式运行，默认为no会暂用你的终端</span></div><div class="line">timeout <span class="number">300</span>​          <span class="meta">#当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</span></div><div class="line">requirepass password123</div></pre></td></tr></table></figure>
<h3 id="六、运行"><a href="#六、运行" class="headerlink" title="六、运行"></a>六、运行</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ redis-server <span class="regexp">/usr/</span>local<span class="regexp">/redis/</span>redis.conf</div></pre></td></tr></table></figure>
<h3 id="七、防火墙里开启6379端口"><a href="#七、防火墙里开启6379端口" class="headerlink" title="七、防火墙里开启6379端口"></a>七、防火墙里开启6379端口</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vi <span class="regexp">/etc/</span>sysconfig<span class="regexp">/iptables</span></div></pre></td></tr></table></figure>
<p>加入： -A INPUT -m state –state NEW -m tcp -p tcp –dport 6379 -j ACCEPT<br>重启防火墙<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>service iptables restart</div></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[Redis是一个开源、支持网络、基于内存、键值对存储数据库，使用ANSI C编写， redis中文官方网站：[http://redis.cn/](http://redis.cn/)]]>
    
    </summary>
    
      <category term="技术综合" scheme="http://miclee.cn/categories/%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[react-component]]></title>
    <link href="http://miclee.cn/2016/04/20/react-component/"/>
    <id>http://miclee.cn/2016/04/20/react-component/</id>
    <published>2016-04-20T11:01:42.000Z</published>
    <updated>2016-04-20T11:03:50.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> 可以这么说，一个 React 应用就是构建在 React 组件之上的。 </em></strong><br><a id="more"></a></p>
<hr>
<h1 id="React-组件"><a href="#React-组件" class="headerlink" title="React 组件"></a>React 组件</h1><p>组件有两个核心概念：</p>
<ul>
<li>props</li>
<li>state</li>
</ul>
<p>一个组件就是通过这两个属性的值在 <code>render</code> 方法里面生成这个组件对应的 HTML 结构。</p>
<p>_注意：组件生成的 HTML 结构只能有一个单一的根节点。_</p>
<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>前面也提到很多次了，<code>props</code> 就是组件的属性，由外部通过 JSX<br>属性传入设置，一旦初始设置完成，就可以认为 <code>this.props</code> 是不可更改的，所以<strong>不要</strong>轻易更改设置 <code>this.props</code> 里面的值（虽然对于一个 JS 对象你可以做任何事）。</p>
<h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p><code>state</code> 是组件的当前状态，可以把组件简单看成一个“状态机”，根据状态 <code>state</code><br>呈现不同的 UI 展示。</p>
<p>一旦状态（数据）更改，组件就会自动调用 <code>render</code> 重新渲染 UI，这个更改的动作会通过<br><code>this.setState</code> 方法来触发。</p>
<h2 id="划分状态数据"><a href="#划分状态数据" class="headerlink" title="划分状态数据"></a>划分状态数据</h2><p>一条原则：让组件尽可能地少状态。</p>
<p>这样组件逻辑就越容易维护。</p>
<p>什么样的数据属性可以当作状态？</p>
<p>当更改这个状态（数据）需要更新组件 UI 的就可以认为是 <code>state</code>，下面这些可以认为<strong>不是</strong>状态：</p>
<ul>
<li>可计算的数据：比如一个数组的长度</li>
<li>和 props 重复的数据：除非这个数据是要做变更的</li>
</ul>
<p>最后回过头来反复看几遍 <a href="http://facebook.github.io/react/docs/thinking-in-react.html" target="_blank" rel="external">Thinking in<br>React</a>，相信会对组件有更深刻的认识。</p>
<h2 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h2><p>你也可以用纯粹的函数来定义无状态的组件(stateless function)，这种组件没有状态，没有生命周期，只是简单的接受 props 渲染生成 DOM 结构。无状态组件非常简单，开销很低，如果可能的话尽量使用无状态组件。比如使用箭头函数定义：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const HelloMessage = (props) =&gt; &lt;div&gt; Hello &#123;props.name&#125;&lt;/div&gt;;</div><div class="line">render(&lt;HelloMessage name="John" /&gt;, mountNode);</div></pre></td></tr></table></figure>
<p>因为无状态组件只是函数，所以它没有实例返回，这点在想用 refs<br>获取无状态组件的时候要注意，参见<a href="dom.md">DOM 操作</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[可以这么说，一个 React 应用就是构建在 React 组件之上的。]]>
    
    </summary>
    
      <category term="react" scheme="http://miclee.cn/tags/react/"/>
    
      <category term="react" scheme="http://miclee.cn/categories/react/"/>
    
  </entry>
  
</feed>
