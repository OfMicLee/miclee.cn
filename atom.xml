<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MicLee&#39;s Bolg</title>
  
  <subtitle>道生一 一生二 二生三 三生万物</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://miclee.site/"/>
  <updated>2019-01-16T09:13:33.197Z</updated>
  <id>http://miclee.site/</id>
  
  <author>
    <name>射雕</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>演讲之禅</title>
    <link href="http://miclee.site/2019/01/16/%E6%BC%94%E8%AE%B2%E4%B9%8B%E7%A6%85/"/>
    <id>http://miclee.site/2019/01/16/演讲之禅/</id>
    <published>2019-01-16T08:51:03.000Z</published>
    <updated>2019-01-16T09:13:33.197Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 《演讲之禅：一位技术演讲家的自白》 </em></strong><br><a id="more"></a></p><hr><h2 id="第1章-其实我看不到裸露的你"><a href="#第1章-其实我看不到裸露的你" class="headerlink" title="第1章 其实我看不到裸露的你"></a>第1章 其实我看不到裸露的你</h2><p>要知道你怎么对待错误，听众就会怎样对待错误；<br>你可以泰然处之，大家也就一笑而过；如果你大惊失色，大家同样会将注意力集中到这件事上；</p><p>因此，如果我在费城的下一个演讲时鞋子着火了，或者上楼梯时摔倒了，还在走道上摔了个嘴啃泥，我就可以将这些变成机遇。<br>以后要是发生什么还不及这个故事尴尬的事情时，我就可以拿这个故事说事了。我可以以一个灾难作为逃脱另一个灾难的衔接点了：“你认为这很令人尴尬吗？呃，以前我在费城的时候……”然后，我就会再提起以前的糟糕事。</p><p>错误肯定会发生，然而重要的是你如何定位错误，以下有两种方法：  </p><ol><li>不要误以为错误是可以完全避免的。一方面要努力熟悉演讲材料，另一方面也要记住完美是不可能的。这样，当一些小错误发生时，你就不会猝不及防。  </li><li>要知道你怎么对待错误，听众就会怎样对待错误。  </li></ol><p>如果水栖到裤子上，你反应得像是泰坦尼克号撞到冰山上，那么观众就会看得清清楚楚，视之为惨剧。如果你坦然处之，甚至视之为趣事，听众也自然会照样学。</p><p>正如戴尔.卡耐基在《Public Speaking for Success》中所说： “演讲结束后，演讲大师常常会发现自己的演讲有4个版本：一个是他们所发表的，一个是他们准备要讲的，一个是报纸报道的，一个是讲完之后反思的。”</p><p>通常而言，困扰演讲者的事情和听众关注的事情总是相去甚远。<br><strong>听众期望享受娱乐，学到知识，最重要的是期待你精彩的表演，而你演讲中出的错并不会影响到这些。</strong>真正把事情弄糟的是你没来得及说一句话就出错了，包括没有一个吸引人的论点，没有认真地分析你要表述的观点，或没有让要讲的内容与听众关联起来，正是这些错误导致了演讲不成功。如果能处理好这些问题，那么其余的就都不重要了。</p><h2 id="第2章-演讲带来的胆怯心理"><a href="#第2章-演讲带来的胆怯心理" class="headerlink" title="第2章 演讲带来的胆怯心理"></a>第2章 演讲带来的胆怯心理</h2><p>我们的大脑认为以下4点会危及生命：  </p><ul><li>独自站立</li><li>在没有地方躲避的空旷地域</li><li>手无寸铁</li><li>在一群人的注视下<br>对于所有的生物而言，当以上4种情况并存时，的确会造成威胁，因为这意味着你被袭击或被生吃的可能性极大。<br>而站在讲台上演讲时，这4个条件都符合；最原始的生理特征告诉我们，需要紧张。  </li></ul><p><strong>重视练习的重要性</strong><br>幻灯片不能代表整个表演：演讲者本人才是表演的主体。<br>结果就是，关于演讲的书上所有的建议，包括教你如何做幻灯片，一且离开了练习，就都难以运用于实际操作。<br>练习最实用的好处就是允许犯错，并且在别人发现之前将其改正。可能我并不比别人更具有演讲天赋——我只是能更好地找出问题所在。</p><p>当我练习时，特别是练习新的演讲材料时，我会遇到很多困难。当我说错或者感到迷惑时，我会停下来，并且做出选择：  </p><ul><li>如果再来一次，我能行吗？</li><li>这个或者之前的那个幻灯片需要作出修改吗？</li><li>这些文字能用一张照片和一个故事代替吗？</li><li>从前一个观点到后一个观点有更好的衔接方式吗？</li><li>如果我直接删去这个观点、幻灯片或者想法，情况是否会好转？<br>当我真正开讲时，那绝对不是我的第一次演讲。其实，当我练习到第三四遍时，我已经能在没有幻灯片的情况下做好演讲了，因为我已经熟悉了如何凸显主题。练习带来的自信能让我自由应对（即兴发挥）一些意外的情况;</li></ul><p>虽然我尊重自己身体对恐惧难以遏制的反应，但我仍需要在演讲前努力保持镇静。我希望自己的身体能够在演讲当天的早晨尽量放松，由于紧张而产生的能量尽量多地释放出来。<strong>每次演讲的那天早上，我都会习惯性地去健身房运动，以期在上台前能消耗多余的能量。</strong></p><p>这是我所发现的唯一的一种方法，既能控制恐惧反应机制，又能避免由此产生的副作用。其他的方法还有：  </p><ul><li>提前到达演讲现场，以防匆忙上阵。</li><li>在开始之前测试技术和音响效果。</li><li>绕讲台走一圈，这样你的身体会在室内感觉安全。</li><li>在观众席上亲身感受一下，了解从观众的角度能看到什么。</li><li>早早吃点东西以防饥饿，但是不要在即将开讲之前吃。</li><li>在开始之前和听众聊聊天（如果方便的话），这样你就不会感觉是在给陌生人作讲座；<br>如果你在熟悉的人面前能谈吐自如，那么你就具备了给陌生人作演讲所需的技巧。下次再听著名演讲家的讲座时，请仔细观察。也许这位演讲家讲得自然而坦然，不论在座的有多少人，都会让人感觉他只是在给一小群人作演讲。</li></ul><h2 id="第3章-每小时30000美元"><a href="#第3章-每小时30000美元" class="headerlink" title="第3章 每小时30000美元"></a>第3章 每小时30000美元</h2><p>到现在为止，我平均年收入有10万美元，比我在微软工作时的收入少。但是，我现在的工作时间少了，也不用像以前那样朝九晚五，而且我现在完全独立了，这是无价的。我将自己每月的旅行限定在一两次之内，因此得以逃脱颠簸的生活。比起金钱来，我更重视时间，毕竟寸金难买寸光阴。</p><p>无论工资高低，世界上大约有一半的人口没有干净的自来水和稳定的供电。从全球来看，如果你能在室内的灯光下阅读此书，在几步之内还有一个装满食物的冰箱，还能随时叫来外卖，从未担心过自己患上疟疾或痢疾，那么你就是很幸运的。如果你还是郁郁寡欢，那么想想这个宇宙吧，其中有99.9%的地方都是死气沉沉的空地，而你现在活着，而且是作为人类这种高智慧的动物活着，而且你还接受了教育，能读懂书，这些都说明了生命是多么的可贵，这样一来，你是多么的富有，我们应该对此感到高兴、满意。</p><h2 id="第4章-如何应对条件恶劣的环境"><a href="#第4章-如何应对条件恶劣的环境" class="headerlink" title="第4章 如何应对条件恶劣的环境"></a>第4章 如何应对条件恶劣的环境</h2><p>你越是多疑，你所害怕的事情出现的概率越高，这样你就更加疑神疑鬼，形成恶性循环。<br>现在我知道了，要想感染观众，我首先得以身作则。如果我想让他们得到快乐，首先我自己要快乐；如果我想让他们笑，首先我自己要笑。但是，这些效果都必须通过交流来实现，而这也是最难达到的。醉汉在婚礼上致辞时，开心的只有他自己，其余的人则很不幸。真正优秀的演讲家能够让大家畅通无阻地交流，他们与听众；坦诚相见，让听众领略奇异而积极的听觉盛况。</p><p>从另外一个角度来看，不友善的听众即使讨厌你，他们也是在关注你的演讲后作出的这种反应。比起漠然的听众来，那些不友善的听众给予你的关注更多。如果你的听众是一屋昏迷不醒的病人，他们躺在病床上，戴着智能视频监控器，输着镇定剂，那么他们完全没有可能对你的话语感兴趣。然而，<strong>如果你的听众对你讲的内容感到气愤或者起哄，那么至少说明他们在意你所讲的话。</strong>至少他们对你的演讲有反应，虽然有好有坏。如果你越早发现他们在意的是什么，那你就越有可能和他们建立起沟通。</p><p>在经历过千百次演讲后，我发现<strong>听众最不能容忍的就是演讲者的不诚实。</strong>开诚布公地坦白让他们气愤的事情，或者和他们倾心交谈，这些都能给你加分。有勇气讲真话的演讲者还是不多的。</p><p>戴尔.卡耐基的《人性的弱点》（袖珍版）是史上最畅销的自助书之一，然而，很少有人知道，这本书在当时受到了出版界和文化精英的极大批判。作者本人被编辑和动画制作人讽刺挖苦，还被大学生模仿嘲笑，人们批评他的建议过于简单和啰嗦（就像是现在狄巴克.乔布拉和菲尔博士被我们嘲笑一样）。有人邀请他到纽约的公爵俱乐部（Dutch Treat Club)演讲，要知道这是一个荟萃出版界、编辑界、广告界及其他文人雅士的团体，这些人也是对卡耐基批评得最厉害的。尽管有人建议他不要去冒这个险，但他还是选择接受邀请。他是这么说的： 我知道对我这本书的批评很多，说我写得不够深刻，在心理学和人际关系 上毫无新意可言。我承认这些说法没错。在座的各位，我可从未说过我发表了什么新观点。当然，我只是讲出来一些常识性的 东西。我之所以将它提出来，一遍一遍地重申和强调它的重要性，因为人们需要的正是这些显而易见的道理。人们最需要的正是与人的相处之道。</p><p>如果你真的害怕听众会对你施加压力，那么，一些额外的工作能帮你减轻恐惧。向活动主办者询问到场观众的预计人数，这些观众一般会问怎样的问题。让主办方提供其中两三个听众的名字，并同这几个人交谈看法，因为他们就是听众的代表。反思自己的恐惧是真实的还是你自己臆想出来的。当你演讲的时候，你一定要提到：<strong>“我和泰勒、马拉、康奈利讨论之后，他们认为接下来我要讲的是人们最讨厌的三种情况。”将听众加入到演讲内容中，这能为你加分，</strong>但很少有演讲者会这么做。如果有听众不同意泰勒、马拉、康奈利的观点，他们也只能在你离去之后才发现。</p><h2 id="第5章-避免语塞"><a href="#第5章-避免语塞" class="headerlink" title="第5章 避免语塞"></a>第5章 避免语塞</h2><p>没有哪种培训能让天生愚笨的人变聪明。演讲者的问题不是说的能力，而是思考的能力。很少有人提起这些，但是有些人注定不能成为成功的演讲家，除非有人来帮他们思考。而他们自己最多只是拥有思考和说服他人这两件工具中的一件。</p><p>即使对许多思维敏捷的演讲者而言，他们也是过于关注形式，从而忽略了实质性的内容。<strong>他们把很多精力花费在幻灯片模板、图片、视颊、字体、衣着、发型以及其他的事情上，而忘记了要努力地去思考如何将自己的观点阐述清楚。</strong>成为一个口齿伶俐的演讲者并不难，这种人能做出含有漂亮的幻灯片、广阔的词汇量和大量的引言借鉴的讲稿，只是没有多少内容要说而已。</p><p>我所见到的槽糕演讲大多数不是因为语言、幻片、视觉效果或者其他的人们所担心的事情没有做好，而是因为缺乏思想和深度。</p><p><strong>无论你做何种演讲，人们之所以来听的原因只有几种。当你准备演讲内容的时候，应该以满足听众以下的这些需求为出发点。</strong><br>人们听演讲的原因有：</p><ol><li>希望能学到知识。</li><li>希望受到激励。</li><li>希望从中获得快乐。</li><li>希望你能满足他们的某种需要。</li><li>希望结识同样对某个主题感兴趣的人。</li><li>希望能与他人有共同的积极经历。</li><li>被他人所迫，如老板、父母、老师或者配偶。</li></ol><p><strong>如果有100位听众花1个小时来听你的讲座，那么他们就相当于将人类的100个小时花费在了你的演讲上。</strong>如果你准备的时间还不到5~10个小时，研究内容以及提炼语言来达到听众的要求的时间太少，那么你对听众时间的尊重又从何说起呢？要是你认为自己的5个小时比别人的100个小时还要；重要，那你简直自负得忘乎所以了。毫无疑问，你一登台，这种不尊重他人的态度就会暴露无遗。</p><p><strong>如果你的演讲不错，参照演讲稿也没有什么不对。</strong> 观众其实是很宽容的。他们期望演讲者能发挥出色，因此会忽略很多细微的不足之处。但是，如果演讲者根本就不去仔细地思考他要讲的内容，故意忽视演讲材料，最终导致演讲失败，那么你又如何要求听众原谅你呢？在许多专业场合，这种毫无准备的态度是人们所不能接受的。假设一位医生正在给你做脑部手术，他在手术中途停下，期望你提醒他手术的目的，那你一定难以接受。如果连你都不知道你自己上台是干什么的，那观众也帮不了你了。</p><p>我要强调的不仅仅是练习，虽然练习也很重要，但是仅仅是练习还不够，任何一个人都能够花上几个小时来准备。真正的目的是要利用准备时间来强化思想，研究更好的方法来满足听众的要求，这样一来，即使现场演讲时有一些小的瑕疵也不会影响大局。<br>为了做好准备，你要做好以下四件事：</p><p><strong>1）在题目下有一个鲜明的立场</strong><br>所有的演讲都有中心观点，你需要知道你的中心点是什么。<br>如果你没有明确的观点，那么你的演讲就可能像这样：“这些是我所能想到的，能在有限的时间内讲到的，但是由干我不知道你们在乎的是什么，也不知道如果时间不够我会讲到那些，你们听到的都是一些半成品，是一些难以理解、难以表述的垃圾。”毎当我听到一个糟糕的演讲，我都想问演讲者：“你的演讲到底要表达什么意思？”或者“你到底想说什么？”由于某些原因，他们似乎并不知道自己要演讲，不知道自己的演讲会有人来听。  </p><p><strong>2）认真了解你的听众</strong><br>要弄明白他们来听你讲座的原因、他们的需求、背景知识、兴趣爱好，以及他们渴望从你这里学到什么东西。如果你没有 足够的时间来将演讲主题研究透彻，那你至少要了解听众。结果可能是你发现自己对某个课题的理解并不是很透彻，但是你至少比你的听众要了解得多。</p><p><strong>3）让你的论点尽量简洁明了</strong><br>如果你要用10分钟才能讲清楚自己的论点，这可不是什么好事。你的论点就是一种声明，而论据则是用来论证观点的。论点必须是精炼、简明的，而论据则可能稍长，怛是绝不能让听众听得如坠云里雾里、不知所云。一个不算失败的演讲至少是立意鲜明的，又不会令观众听得稀里糊涂、毫无趣味，而一个槽糕的演讲总是让人找不到重点。<br>达到这些目标最快捷的方法就是<strong>选择一个提纲挈领的标题</strong>。演讲者往往对标题关注甚少，但是标题却会醒目地位于幻灯片的首页。在一次大型活动或者会议上，你的标题也是人们选择是否听你演讲的重要筹码。许多人的标题无趣而死板，这只会让机会悄悄溜走。一个标题的意义在于，它将所有的东西划为两类，一类是你所要讲的，另一类是你不会涉及的。选择标题，将事!物分门别类往往是一件无趣的事情，你要是不能找到一个合适的标题，那你往往也不会提出好的论点。如果整个演讲中你只能讲述一个论点，那会是什么？这唯一的论点显然正是标题应该表达的。</p><p>在这里有一个很好的例子。如果我的演讲题目是“创意入门法则”，那么从一开始我就失败了。我怎么可能将创意的入门法则概括完整、一一道来？观众又何必要事无巨细地了解全部的内容呢？这个主题一定是无趣而又道不尽的。出类拔萃的演讲家从不选择大而泛的主题，因为选择这样的主题本身就是错误的。我可能用6个小时熟读所有的入门法则宝典，但是这根本就没有什么用处。人们真正需要的是独到的见解，他们希望能有一个演讲者或者一个老师来指导他们从一个特定的角度来剖析问题。 比较而言，“在枯燥的工作中如何创新”或者“启示与头脑风暴：读苏士博士的书学习创新之法”等标题或许更好。</p><p>你可以参考以下标题，并以此将演讲做得更好：</p><ul><li>在……中遇到的问题及解决之道</li><li>……为何失败，如何补救</li><li>我在……中犯下的错误，以及我所学到的东西</li><li>关于……人们经常提起的问题及解决妙招</li><li>关于……的真相，及其对我们的启发</li><li>关于……只有专家才知道的捷径和窍门</li><li>关于……你成功的五个原因</li><li>为何……能永远改变你的生活，现在免费告诉你</li></ul><p><strong>4）拟定演讲提纲</strong><br>即使你在演讲中一时忘词，或者电脑死机，或者你的节奏让人难以理解，你都可以回到提纲上来。只要你依照提纲的顺序阐明自己的观点，你就能为听众提供有用的信息。<br>我在演讲中经常用到幻灯片，因为我喜欢通过图片和视频来表述我的观点，但是我从不担心这些工具坏掉。我在演讲前就很好地掌握了我所要讲的内容，即使不能按照我所期望的那样来演讲，我依然能把所有的内容传递给听众。如果对内容很熟练，我就能自然地表述。事实上，通过努力制作出一个清晰、深刻、有理有据的提纲，我已经想到了演讲的三种效果：预期的版本(标题）、五分钟版本（讲完所有的观点及简明的提纲）和拓展版本（由幻灯片、视频以及其他各种方法来支持每个论点）。</p><p>没有幻灯片的演讲者会用简明的提纲或者清单来帮助他们演讲。马克.吐温、温斯顿.丘吉尔、富兰克林.罗斯福都会用列有五六项内容的清单来提醒他们自己（每一项往往只有几个字），以此来完成1小时左右的演讲。只要你在演讲之前认真思考过，那么你只需要一个小小的清单，这样，几乎所有的演讲就基本上没有问题了</p><h2 id="第6章-不招人厌烦的学问"><a href="#第6章-不招人厌烦的学问" class="headerlink" title="第6章 不招人厌烦的学问"></a>第6章 不招人厌烦的学问</h2><p>在为《Whats the Use of Lectures》（Jossey-Bass出版社）这本书做研究时，唐纳.A.布莱教授曾测量过他的学生在不同的讲座中不同时段的心率。毫无悬念的是，他们的心率是逐渐降低的，而心率高峰正好处于开讲前听众精神高度集中的那个时期。而且，平均算下来，心率是稳定下降的（如图6-1所示）。这个现象颇为令人失望，却也表明了为何<strong>大多数讲座都是越往后越寂静。因为坐着的时候要做的事情很少，我们的身体于是逐渐转入休息状态，而身体的状态会决定思维的状态。</strong></p><p>西雅图太平洋大学大脑中心主任、分子生物学家约翰.梅狄娜认为，<strong>大多数人对许多事物的关注时间最长为10分钟。</strong> 其实，“10”并不是一个神奇的数字。只要演讲者很明白自己在做什么，并且深知如何保持听众的注意力，无论是8分钟、12分钟还是45分钟的演讲，都能博得观众的好评。但是实际情况往往不是如此。于是，我们也就不难理解为何现在很多深得人心的会议、TED会议（科技、娱乐、设计）都有8分钟或者20分钟的时间限制。</p><p>美国有100位参议员，50位执政官，而只有1位总统，每个人的权力都比他们所代表的平民百姓大。<strong>权力的不平均分配有助于更有效率地完成工作</strong>，这也是演讲中我们所需要的效果。也许你认为美国的现状并不好，但是当所有的3亿人口都享有平等的权力时，你会发现情况会更糟。</p><p>从政治学的思维来看，<strong>演讲绝不是权力平等共享，而是专权制盛行的地方。</strong>舞台上站着的只有一个人，欢迎的掌声也只献给那一个人，拿麦克风的也只有一个人。<strong>假设在TED会议上有外星人光临，他们一定会以为站在舞台上拿着话筒的那个人是星球的绝对统治者。</strong></p><p>在文明史中，演讲者都是那些首领、国王或者法老。然而，很少有演讲者用到他所拥有的这种力量。许多演讲者都不敢越过常规，因此他也浪费了观众陚予他的力量。<br>设定进度<br>要运用这种力量，最简单的方法就是设定演讲的速度。每个人都梦想成为自己最喜欢的乐队的吉他手或者主唱，但是他们忽略了真正的力量来自节奏部分。</p><p>我曾在大学和企业演讲，听众都是比我聪明得多的人，他们比我更有创意，更幽默，但是我依然能演讲成功，因为我给了他们一个清晰明了的节奏，以便于他们跟进。演讲前，我会说：“<strong>我演讲的时间是30分钟，要讲的内容一共有5条，每一条我将花5分钟来讲解，剩下的时间欢迎你们提问。</strong>”说这些话花费了我大概10秒钟的时间，但是我却能因此吸引他们的注意力，告诉了他们我的计划，这样他们就能知晓演讲的节奏。</p><p>引导注意力（“我来看的是什么，值得来看吗？”)<br>人们喜欢关注一些事情，包括：<br>. 我们喜欢吃的东西<br>. 可能吃掉我们的东西<br>. 与我们有关的问题<br>. 我们重视的人<br>. 我们关注的话题<br>. 我们想解开的疑问<br>. 闪亮的、移动的物体（如汽车广告）<br>. 我们想发生性关系的人（如所有的广告）<br>. 劲爆的事物（男人关注的）<br>. 漂亮的事物（女人关注的）<br>. 漂亮而且劲爆的事物（男人和女人共同关注的）<br>有了这张清单，最简单的方法就是依据它制定一些小策略，每演讲五六分钟就穿插一些这类事物，以博得听众的关注。</p><p>放上一些与讲座毫不相关的漂亮图片并不能长久地引起人们的兴趣。只有精心挑选的图片才有用，而且要给观众足够的时间将这幅图片和演讲结合起来。如果你能找到能很自然地吸引注意力的方法，那你可以将它运用于讲座中。</p><p>最简单的方法就是讲故事。坦白地说，一旦开口讲话，你就是在讲一个故事。所有的交流都是一段叙述：有开端、过程和结尾。引导观众注意力的最好方法就是讲述听众所关心的情况（情况也就是一个故事）。这样一来，就有两点能引起他们的注意：故事本身和故事的主人公。</p><p>如果你说：“这是新税法的第5行。”这只是一段对于事实平凡而又无聊的叙述，只会让听众转移注意力。但是，如果你说：“<em>在座的80%的听众都搞不清你们上次的纳税申报单中的第5行和第6行，而这会让你花费500美元，现在我来告诉大家如何避免此类事情。</em>”那么，观众的反应一定大不相同。<strong>只要演讲者将问题与受影响的人联系起来，即使是像税务这种枯燥乏味的讲座也能妙趣横生。</strong>一旦听众对你讲的故事产生兴趣，他们就会跟随你的步伐。好的演讲家就具有这种能力。</p><p>演好你的角色<br>你就是主角 人们总是对事物抱有期望。去一个高级酒店时，他们期望有出色的服务和可供取笑的酒店领班。看动作片时，他们期望有违反物理原理的大爆炸以及有漏洞的阴谋。当他们抽出1个小时的时间来听你演讲时，他们期望你对自己要讲的内容和要做的事情充满自信。如果你在演讲时还在摸索着连接电脑的投影仪，为自己的幻灯片而苦恼，或者向他们承认自己准备不足，希望得到谅解，那你肯定是不值得他们花费这1个小时的。你并没有扮演好他们期望中的角色——一个自信、目标明确、动力十足的可能精通于某些方面的专家。你并不需要是一个完美的人，但是你一定要演好自己的角色。</p><p>人们容易犯的一个通病就是临阵畏缩，当站在台上时，他们会显得过于礼貌和谨慎。他们说话轻声细语，不讲故事，也从不露出笑容，完全变成了一个毫无特色的平庸之辈。<br>虽然这样看起来很安全，不会出什么岔子，但这却会遭到听众的抛弃。</p><p><strong>学习表演并不是学习作假，而是学习如何在舞台上和生活中更好地表现自己。</strong><br>所有的交流能手都从戏剧学中受益匪浅。</p><p>. 针对演讲内容提出一些小问题，要求观众回答。演讲者问观众的最蠢的问题就是：“对我讲的这些你们还有什么问题吗？”这句话听起来像是一种威胁，似乎在看谁会挑战你的威信，而大多数观众是不会站出来提问的。但是，你还可以用一种更为积极而又互动的方式，比如，你问：“哪些方面还需要我解释一下吗？”</p><h2 id="第7章-从15分钟的电视节目录制中学到的"><a href="#第7章-从15分钟的电视节目录制中学到的" class="headerlink" title="第7章 从15分钟的电视节目录制中学到的"></a>第7章 从15分钟的电视节目录制中学到的</h2><p>借鉴在同一种媒介中成功人士的经历。例如，如果你参加的是视频会议，那你一定要观察一下别人的表现。这样，当轮到你发言时，你就掌握了一定的分寸</p><h2 id="第9章-他们是你的朋友"><a href="#第9章-他们是你的朋友" class="headerlink" title="第9章 他们是你的朋友"></a>第9章 他们是你的朋友</h2><p>在为数不多的专心听课的人当中，有多少人能真正理解我讲的内容？<br>第二天还有多少人记得这些内容？<br>又有多少人会将我讲的这些运用到生活实践中呢？</p><p>有一个好消息就是：当教学的效果达到时，教学本身将是一次很有价值的经历。当你看到有人听懂了你的观点，并将它成功地运用于生活中时，这种喜悦之情是生活中其他快乐所不能比拟的。</p><p>如果你高明的思想让听众厌烦了，那该怎么办呢？这时，解决教学困难的方法就是观察学生的反应，找出应对之策，调整演讲以适应学生的需求。<br>你要在演讲中不停问自己：<br>. 听众是否巳经了解这些知识？<br>. 听众是否需要我从另一个不同的角度去解释？<br>. 听众是否已经掌握了不少知识，需要休息或者放松？<br>. 听众是否太自傲了，需要给他们一点儿挑战？<br>. 当回到工作中时，他们会发现什么新问题吗？<br>. 他们在生活中用到过我讲的方法吗？效果如何？<br>. 现在，他们回到了工作和生活中，还希望你讲哪些主题？<br>. 对于如何将讲座变得更生动、更活泼和更吸引人，他们有什么建议？<br>如果你不分析听众的反馈，你就无法教好书。好的教师讲得多，听得也多，他们会时刻关注如何提高自己的课程素材水平，从而达到更好的授课效果。一个教师若是不愿从学生那里寻求意见，甚至连自己失败的原因都不在乎，那他就是一位失败的教师。</p><h2 id="第10章-自白"><a href="#第10章-自白" class="headerlink" title="第10章 自白"></a>第10章 自白</h2><p>有时，听众已经知道我要讲的知识，这时我的旨要任务就是提醒他们回忆那些知识，或者将这些知识运用到一个新的环境中。我深知，<strong>要想体现自我价值，我并不一定要是某项观点的首创者。</strong>通常，演讲者将古人的话运用到新的环境中，或者以业内人士无法传达的一种方式传授给听众，那么他们同样在创造价值。有时，从一个非业内人士那里得到的信息比从一个专业人士那里得到的信息还要有价值。</p><p>关注能让演讲更有趣。如果说我有给人带来乐趣的秘诀，我想应该是我学过即兴表演学。在那里，我学会了如何观察和如何倾听。幽默和独到的见解来自于关注，而非天资。<strong>当我学了即兴表演学之后，我的演讲技巧得到了很大的提高，我对生活的态度也发生了转变。我强烈推荐学习即兴表演学。</strong></p><p>要使演讲生动，最简单的方法就是坦诚相待。虽然听众不会告诉你，但是他们最希望看到的就是一位诚实的演讲者。如果你把许多人都不敢说的话说了出来，那你就是英雄。</p><p><strong>如果你喜欢收集思想，那么演讲和写书就是必然的结果。</strong>我们之所以能了解历史上的伟大思想家，就是因为有他们的演讲或者他们所著的书籍，或者有人在得到或未得到他们允许的情况下，将这些思想家的观点记录了下来。</p><h2 id="后台笔记"><a href="#后台笔记" class="headerlink" title="后台笔记"></a>后台笔记</h2><p>只要有一个遥控器在手，你就获得了完全的自由。你可以在任何时候做任何亊情，可以在舞台上乱逛、走到听众席间、站到讲台后，甚至到听众席后排，这些都不妨碍你演讲（但是一定要与技术人员核实信息，当你离开舞台时，无线麦克风有时会产生回音）。</p><p>我经常带来一些作品，准备在问答环节免费赠送。但如果前排没有人，我会把书赠给愿意移位到前排的人。这种方法总是很奏效，特别是对那些因为懒惰而不愿移动的人很管用，而且这样一来，听众对我而言就不那么恐怖了（即使我面对的是最恐怖的人，当我看到他们追逐免费礼品的表情时，也会觉得他们不那么吓人了）。越是担心演讲，我带的书就会越多。如果你没有自己写的书，那你也可以买一些别人写的相同话题的书来送给听众（<strong>如果100美元能减轻你的紧张情绪，让听众更具亲和力，倒也很值得</strong>），其效果都是一样的。</p><h2 id="如何立论"><a href="#如何立论" class="headerlink" title="如何立论"></a>如何立论</h2><p>许多演讲者都不太关注重音。有时，他们还把重音视为垃圾，置之不理。<strong>听众会因为演讲者的重读而给他加分，但是演讲者自己并不一定清楚为何要这么做。</strong>然而，无论如何，有重音的句子总比平淡单一的句子好，但是也好不了多少。我们的目的是要合理运用重读来表达你的思想。 我们可以分析一些著名演讲家的讲座，在他们强调的地方划分句子。他们可能会用到各种不同的强调方法，如重复词语、停顿、做手势，甚至是偶尔放轻语调等。一个好的演讲者会通过强调来传达不同的信息，但是大多数人却很容易忽视这些信息。这些信息并不是来源于幻灯片，也不是来源于演讲内容，而是来源于演讲者巧妙构思的语调。</p><p>寂静为演讲者能量的传输营造了一个很好的基线。<strong>有时候，当演讲厅静下来时，听众反而会投入更多的关注力</strong>（这个事实并非广为人知，因为演讲者总是想尽办法不在演讲中出现沉默）。如果你不断地说话，听众的耳朵和大脑都无法得到短暂的休息。如果你在讲一些有趣的东西，或者想要证明你的某个观点，听众就更需要一些时间来消化你所讲的内容。而且，很多人会相应地做一些笔记，有的只是在脑海里记下某些要点，但是这些都是需要时间来完成的。要是看一些杰出戏剧家的表演，你就会发现，在其中20%~30%的时间里，他们会安静下来，留给听众思考、消化以及大笑的时间，或者只是为他们的下—个表演做准备。</p><p>教师在授课时，中间的停顿是很重要的。这段时间能给学生留下思考和总结的空间。停顿的时间长短需要一些技巧。</p><h2 id="演讲失败了怎么办"><a href="#演讲失败了怎么办" class="headerlink" title="演讲失败了怎么办"></a>演讲失败了怎么办</h2><h3 id="表现的像新手"><a href="#表现的像新手" class="headerlink" title="表现的像新手"></a>表现的像新手</h3><p>如果是做脑部手术，一定没有人希望自己的主刀医生是一个新手。同理，听众也是同样的心理。<strong>当你站到演讲台上的时候，你一定不要表现得像是第一次登台演讲一样，即使这确实是你的首次演讲，你也不能表现出来。</strong>演讲者若是被自己的笔记本电脑、笔记弄糊涂了，或者在大多数时间里都背对着听众，他的这些行为都会说明他是一个新手。</p><p>解决方法：练习，直到能够达到不错的效果为止。你准备在演讲中说的内容都需要练习。<br>你还要在转换幻灯片和话题时，做好衔接，这也是最容易出错的地方。</p><h3 id="你让话题枯燥无味"><a href="#你让话题枯燥无味" class="headerlink" title="你让话题枯燥无味"></a>你让话题枯燥无味</h3><p>如果我们语调单一、表情木然、举一些没有意思的例子、表现得像是自己都不喜欢这个话题，那么无论什么样的话题都会索然无味。如果演讲者本人都对自己要传达的信息毫无兴趣，那么他又能期望听众有怎么样的反应呢？</p><p>解决方法：从一开始就找到激发听众兴趣的切入点。如果你要选择演讲话题和论点，那一定要找一些有意思的话题。找到一个立论点，将主题插人到演讲题目中，然后按照自己的观点来展开思路。即使只有你对这个话题感兴趣，但只要你能把自己的热情表达得当，听众也会被你的激情所感动，从而追随你的脚步</p><h3 id="你的幻灯片惹人讨厌"><a href="#你的幻灯片惹人讨厌" class="headerlink" title="你的幻灯片惹人讨厌"></a>你的幻灯片惹人讨厌</h3><p>使用幻灯片是有风险的，它可能因为各方面的原因而给听众带来困扰。幻灯片往往不能传达足够的内容，也会给演讲者带来干扰。</p><p>解决方法：不要首先就想到运用幻灯片，首先应该了解你的听众。想要找到支持你的论点的依据，你可以用图片。如果你想将自己的笔记加到幻灯片中，以减小自己的恐惧感，那么一定不能给听众带来困扰。</p><h3 id="害怕听众"><a href="#害怕听众" class="headerlink" title="害怕听众"></a>害怕听众</h3><p>害怕听众是很正常的。但如果你在演讲时被这种恐惧感占了上风，那你的听众就不会得到满足，也不会学到知识。</p><p>解决方法：找到一个放松的方法。带上一些小礼品来吸引听众，面带笑容也能减轻恐惧感，从而让你放松。提前到达现场，这样你就能见到一些听众，进而觉得他们不那么恐怖了。找一些你感兴趣的话题，这样一来，分亨的快乐就能给你积极的力量，从而平衡你的恐惧感。</p><h3 id="缺乏眼神沟通"><a href="#缺乏眼神沟通" class="headerlink" title="缺乏眼神沟通"></a>缺乏眼神沟通</h3><p>你的眼睛看着哪里？如果演讲者是新手，那么他会看着自己的鞋子，盯着某一位观众，或者看着空旷的地方。其实，你至少可以看着观众席的后排，这样观众就会认为你正在看着其他的观众。最好的眼神交流是在不同的时间看不同的地方，扫视观众以达到自然的效果，即使你只是装出来的自然，那也比不自然好。</p><h3 id="缺乏激情"><a href="#缺乏激情" class="headerlink" title="缺乏激情"></a>缺乏激情</h3><p>激情在演讲中很重要。尽管你的演讲毫无依据，但是你表现得越是在意，就有越多的观众想要倾听你的思想。然而，很少有人能讲得富有激情。演讲者自以为讲得很有激情，但在观众看来，他们只是表现平平。你可以观看那些富有激情的演讲视颊（马丁.路德.金的《我有一个梦想》的演讲就是不错的例子），然后对比自己的演讲视频。想想如何在保持自己特色的基础上，再加入更多的激情。</p><h3 id="所有的观众都盯着自己的电脑"><a href="#所有的观众都盯着自己的电脑" class="headerlink" title="所有的观众都盯着自己的电脑"></a>所有的观众都盯着自己的电脑</h3><p>每位观众都有自己的文化理念，在某些文化中，观众大多不会盯着演讲者，这样会让演讲者感觉很气馁。对演讲者而言，和观众的眼神交流越多越好。有时，观众只是在做笔记，或者和他人分享你的演讲，这些都是对你有利的。</p><p>你可以请求观众关掉他们的笔记本电脑，但是不要强求。你也要尊重他们的选择，特別是当他们付费前来的时候。但是你可以告诉他们，如果他们聚精会神听演讲，你会表现得更好。<br>有时我会跟他们说：“现在我们来做个交易。如果你们在5分钟内全神贯注地听我演讲，完了之后还是认为我讲得很烂，是在浪费你们的时间，你们宁愿上网，那么我就不会再管了。事实上，5分钟之后，你们要起身离开我都不介意。但是，在接下来的300秒内，请全神贯注地听演讲。”这时，大多数人都会关上他们的电脑。</p><h3 id="演讲超时"><a href="#演讲超时" class="headerlink" title="演讲超时"></a>演讲超时</h3><p>如果你的演讲内容结构合理，那么演讲的节奏必然是平稳和谐的，你会为每一个步骤设计好时间。这样一来，你就不会在只剩下一分钟的时候发现自己还有一半的内容没有讲。<br>. 练习在比正式演讲更短的时间内做完演讲。<br>. 计划抽出20%~30%的时间用于问答环节。如果演讲的时间超过预期，你还可以通过减少问答环节的时间作为缓冲。<br>. 不要用你事先准备的幻灯片。当观众人数很少时，成功的几率很小。调整到非正式模式，像之前我在“将幻灯片遗忘在家”的情况中介绍的那样，让观众提一些问题，你针对这些问题一一作答。</p><h2 id="调査和推荐"><a href="#调査和推荐" class="headerlink" title="调査和推荐"></a>调査和推荐</h2><h3 id="如何战胜焦虑和恐惧"><a href="#如何战胜焦虑和恐惧" class="headerlink" title="如何战胜焦虑和恐惧"></a>如何战胜焦虑和恐惧</h3><p>最好的建议就是找到你们当地的演讲社团，这些人都很乐意帮助你。<br>克伦.康格斯.迪尔所著的《Conquer Your Speech Anxiety》（Wadsworth出版社），它改变了我对恐惧的想法。这本书和关于这个主题的其他书籍（如M.F.芬硕特的《The Francis Effect》等）不同，它是一个练习手册。每一章都针对不同的恐惧布置不同的训练，让你认识、接受并战胜这些恐惧。随书还附送一张CD，可帮助你练习。</p><h3 id="如何讲好故事"><a href="#如何讲好故事" class="headerlink" title="如何讲好故事"></a>如何讲好故事</h3><p>我在书中没有提到讲故事的重要性，<strong>讲故事其实是所有演讲和写作的基础</strong>。我选择用行动而不是说话来证明这个事实，我也希望读者认为这本书里的故事实用，能给你留下深刻的印象。 安东尼.博丹的《Kitchen Confidential》（Harper Perennial出版社）和乔治.奥威尔的《Down and Out in Parisand London》(Mariner Books)都给了我很大的启发。最主要的是，这两本书让我决定用自己的经历作为本书的主要内容（同时还有威廉.梓泽的《Inventing the Truth》[Mariner Books])。我相信，第一人称的叙述最能引起读者的共鸣，这些是第三人称叙述所不能达到的效果。<br>安妮特.西门所著的《The Story Factor))(Perseus Books Group)是一本独特的书。这本书为我们展现了日常生活中我们是如何讲故事的，也为如何提高讲故事的水平，及其在生活工作中的效用给出了明确的指导。</p><h3 id="演讲设计"><a href="#演讲设计" class="headerlink" title="演讲设计"></a>演讲设计</h3><p>我在本书中故意避开演讲设计不谈，一方面是因为关于这个主题的书已经很全了。格尔.雷诺兹的《Presentation Zen》（NewRiders出版社）和南希.德瓦安蒂的《Slide: ology》（奥莱利出版社）都能为你做演讲设计提供参考。这两本书中都引用了许多经验丰富的演讲家的例子，告诉你他们是如何将幻灯片串联起来的。 雷诺兹建议我们先在纸上描绘出自己演讲的内容和演讲方式，我对此很赞同。若是一开始就用这些演讲软件，你只会以幻灯片为中心，而不是以故事、观点或观众为中心。</p><p>由杰瑞.森菲尔德主演的纪录片《戏剧演员》对演讲者来说，也许是最棒的90分钟电影了，它能很好地帮助演讲者理解喜剧演员付出的努力。就算你不喜欢杰瑞.森菲尔德的幽默，你也可以听克里斯.洛克、卡琳.奎因、比尔.科斯比等知名喜剧演员讲他们是如何搜集材料、准备表演的。这部电影的亮点是森菲尔德丢弃了他所有的旧材料后，如何运用创新、练习创造新材料，将表演提升到一个新的境界。</p><h3 id="专业演讲"><a href="#专业演讲" class="headerlink" title="专业演讲"></a>专业演讲</h3><p>现在有许多书都声称能让你成为年薪10万、100万美元的演讲家。但是我认为，<strong>演讲的主要用途不是为了积累财富，因为更好地思考和沟通能增进你与他人的关系，也包括你和白己的关系。</strong></p><p>当你有一定的主题演讲经验时，你就有可能获得薪水。演讲的证书和学位有很多，但如果你看一下世界上排名前500位的演讲家，我打赌你会发现没有人会有这些证书。如果你在某一个主题上有演讲经验，那你就可以去找那些活动组织者，他们如果正好需要人来做这个主题演讲，就可能聘请你。像我一样，你也许会在开始几年免费给他们演讲，直到你的技术和名声能够给你带来价值。</p><p>我所看过的书中，艾伦.维斯的《Money Talks: How to Make a Million As a Speaker》（麦格劳.希尔出版社）是对如何以演讲为生最好的专业参考书。这本书中的错误很少，作者在书中真诚得近乎无情地教给我们如何找到潜在的雇主，雇主眼中的价值比例，以及如何让这些为你所用。</p><p>亚马逊链接：<a href="http://www.amazon.cn/%E6%BC%94%E8%AE%B2%E4%B9%8B%E7%A6%85-%E4%B8%80%E4%BD%8D%E6%8A%80%E6%9C%AF%E6%BC%94%E8%AE%B2%E5%AE%B6%E7%9A%84%E8%87%AA%E7%99%BD-%E6%96%AF%E7%A7%91%E7%89%B9%E2%80%A2%E5%8D%9A%E5%85%8B%E9%A1%BF/dp/B006NS2OUW?SubscriptionId=AKIAJOMEZLLKFEWYT4PQ&amp;tag=z08-23&amp;linkCode=xm2&amp;camp=2025&amp;creative=165953&amp;creativeASIN=B006NS2OUW" target="_blank" rel="noopener">《演讲之禅:一位技术演讲家的自白》</a></p>]]></content>
    
    <summary type="html">
    
      《演讲之禅：一位技术演讲家的自白》
    
    </summary>
    
      <category term="Blog" scheme="http://miclee.site/categories/Blog/"/>
    
    
      <category term="读书笔记" scheme="http://miclee.site/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>设计模式趣解</title>
    <link href="http://miclee.site/2019/01/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%B6%A3%E8%A7%A3/"/>
    <id>http://miclee.site/2019/01/16/设计模式趣解/</id>
    <published>2019-01-16T08:23:35.000Z</published>
    <updated>2019-01-16T08:59:26.450Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 在网络上流畅很广的一篇旧文，暂时没找到原作者，作者用轻松的语言，形象解释了 23 种模式，有很好的启发作用。 </em></strong><br><a id="more"></a></p><hr><h2 id="一、创建型模式"><a href="#一、创建型模式" class="headerlink" title="一、创建型模式"></a>一、创建型模式</h2><h3 id="1-FACTORY"><a href="#1-FACTORY" class="headerlink" title="1. FACTORY"></a>1. FACTORY</h3><p>追MM少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是MM爱吃的东西，虽然口味有所不同，但不管你带MM去麦当劳或肯德基，只管向服务员说“来四个鸡翅”就行了。麦当劳和肯德基就是生产鸡翅的Factory。</p><p><strong>工厂模式：</strong><br>客户类和工厂类分开。消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。</p><h3 id="2-BUILDER"><a href="#2-BUILDER" class="headerlink" title="2. BUILDER"></a>2. BUILDER</h3><p>MM最爱听的就是“我爱你”这句话了，见到不同地方的MM,要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到MM我只要按对应的键，它就能够用相应的语言说出“我爱你”这句话了，国外的MM也可以轻松搞掂，这就是我的“我爱你”builder。（这一定比美军在伊拉克用的翻译机好卖）</p><p><strong>建造模式：</strong><br>将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。</p><h3 id="3-FACTORY-METHOD"><a href="#3-FACTORY-METHOD" class="headerlink" title="3. FACTORY METHOD"></a>3. FACTORY METHOD</h3><p>请MM去麦当劳吃汉堡，不同的MM有不同的口味，要每个都记住是一件烦人的事情，我一般采用Factory Method模式，带着MM到服务员那儿，说“要一个汉堡”，具体要什么样的汉堡呢，让MM直接跟服务员说就行了。</p><p><strong>工厂方法模式：</strong><br>核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。</p><h3 id="4-PROTOTYPE"><a href="#4-PROTOTYPE" class="headerlink" title="4. PROTOTYPE"></a>4. PROTOTYPE</h3><p>跟MM用QQ聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要copy出来放到QQ里面就行了，这就是我的情话prototype了。（100块钱一份，你要不要）</p><p><strong>原始模型模式：</strong><br>通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。</p><h3 id="5-SINGLETON"><a href="#5-SINGLETON" class="headerlink" title="5. SINGLETON"></a>5. SINGLETON</h3><p>俺有6个漂亮的老婆，她们的老公都是我，我就是我们家里的老公Sigleton，她们只要说道“老公”，都是指的同一个人，那就是我(刚才做了个梦啦，哪有这么好的事)</p><p><strong>单例模式：</strong><br>单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的“单一实例”的需求时才可使用。</p><h2 id="二、结构型模式"><a href="#二、结构型模式" class="headerlink" title="二、结构型模式"></a>二、结构型模式</h2><h3 id="6-ADAPTER"><a href="#6-ADAPTER" class="headerlink" title="6. ADAPTER"></a>6. ADAPTER</h3><p>在朋友聚会上碰到了一个美女Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友kent了，他作为我和Sarah之间的Adapter，让我和Sarah可以相互交谈了(也不知道他会不会耍我)</p><p><strong>适配器（变压器）模式：</strong><br>把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。</p><h3 id="7-BRIDGE"><a href="#7-BRIDGE" class="headerlink" title="7. BRIDGE"></a>7. BRIDGE</h3><p>早上碰到MM，要说早上好，晚上碰到MM，要说晚上好；碰到MM穿了件新衣服，要说你的衣服好漂亮哦，碰到MM新做的发型，要说你的头发好漂亮哦。不要问我“早上碰到MM新做了个发型怎么说”这种问题，自己用BRIDGE组合一下不就行了</p><p><strong>桥梁模式：</strong><br>将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合/聚合关系而不是继承关系，从而使两者可以独立的变化。</p><h3 id="8-COMPOSITE"><a href="#8-COMPOSITE" class="headerlink" title="8. COMPOSITE"></a>8. COMPOSITE</h3><p>Mary今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件T恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM都会用Composite模式了，你会了没有？</p><p><strong>合成模式：</strong><br>合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。</p><h3 id="9-DECORATOR"><a href="#9-DECORATOR" class="headerlink" title="9. DECORATOR"></a>9. DECORATOR</h3><p>Mary过完轮到Sarly过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上“最好的的礼物，就是爱你的Fita”，再到街上礼品店买了个像框（卖礼品的MM也很漂亮哦），再找隔壁搞美术设计的Mike设计了一个漂亮的盒子装起来……，我们都是Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？</p><p><strong>装饰模式：</strong><br>装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。</p><h3 id="10-FACADE"><a href="#10-FACADE" class="headerlink" title="10. FACADE"></a>10. FACADE</h3><p>我有一个专业的Nikon相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但MM可不懂这些，教了半天也不会。幸好相机有Facade设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样MM也可以用这个相机给我拍张照片了。</p><p><strong>门面模式：</strong><br>外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。</p><h3 id="11-FLYWEIGHT"><a href="#11-FLYWEIGHT" class="headerlink" title="11. FLYWEIGHT"></a>11. FLYWEIGHT</h3><p>每天跟MM发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上MM的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是Flyweight，MM的名字就是提取出来的外部特征，根据上下文情况使用。</p><p><strong>享元模式：</strong><br>FLYWEIGHT在拳击比赛中指最轻量级。享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。</p><h3 id="12-PROXY"><a href="#12-PROXY" class="headerlink" title="12. PROXY"></a>12. PROXY</h3><p>跟MM在网上聊天，一开头总是“hi,你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？”这些话，真烦人，写个程序做为我的Proxy吧，凡是接收到这些话都设置好了自动的回答，接收到其他的话时再通知我回答，怎么样，酷吧。</p><p><strong>代理模式：</strong><br>代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。</p><h2 id="三、行为模式"><a href="#三、行为模式" class="headerlink" title="三、行为模式"></a>三、行为模式</h2><h3 id="13-CHAIN-OF-RESPONSIBLEITY"><a href="#13-CHAIN-OF-RESPONSIBLEITY" class="headerlink" title="13. CHAIN OF RESPONSIBLEITY"></a>13. CHAIN OF RESPONSIBLEITY</h3><p>晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的MM哎，找张纸条，写上“Hi,可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的MM把纸条传给老师了，听说是个老处女呀，快跑!</p><p><strong>责任链模式：</strong><br>在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。</p><h3 id="14-COMMAND"><a href="#14-COMMAND" class="headerlink" title="14. COMMAND"></a>14. COMMAND</h3><p>俺有一个MM家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送COMMAND，就数你最小气，才请我吃面。”，:-(</p><p><strong>命令模式：</strong><br>命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。</p><h3 id="15-INTERPRETER"><a href="#15-INTERPRETER" class="headerlink" title="15. INTERPRETER"></a>15. INTERPRETER</h3><p>俺有一个《泡MM真经》，上面有各种泡MM的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟MM约会时，只要做一个Interpreter，照着上面的脚本执行就可以了。</p><p><strong>解释器模式：</strong><br>给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。</p><h3 id="16-ITERATOR"><a href="#16-ITERATOR" class="headerlink" title="16. ITERATOR"></a>16. ITERATOR</h3><p>我爱上了Mary，不顾一切的向她求婚。<br>Mary：“想要我跟你结婚，得答应我的条件”<br>我：“什么条件我都答应，你说吧”<br>Mary：“我看上了那个一克拉的钻石”<br>我：“我买，我买，还有吗？”<br>Mary：“我看上了湖边的那栋别墅”<br>我：“我买，我买，还有吗？”<br>Mary：“你的小弟弟必须要有50cm长”<br>我脑袋嗡的一声，坐在椅子上，一咬牙：“我剪，我剪，还有吗？”<br>……</p><p><strong>迭代子模式：</strong><br>迭代子模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。迭代子模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。</p><h3 id="17-MEDIATOR"><a href="#17-MEDIATOR" class="headerlink" title="17. MEDIATOR"></a>17. MEDIATOR</h3><p>四个MM打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就OK啦，俺得到了四个MM的电话。</p><p><strong>调停者模式：</strong><br>调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。</p><h3 id="18-MEMENTO"><a href="#18-MEMENTO" class="headerlink" title="18. MEMENTO"></a>18. MEMENTO</h3><p>同时跟几个MM聊天时，一定要记清楚刚才跟MM说了些什么话，不然MM发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个MM说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。</p><p><strong>备忘录模式：</strong><br>备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。</p><h3 id="19-OBSERVER"><a href="#19-OBSERVER" class="headerlink" title="19. OBSERVER"></a>19. OBSERVER</h3><p>想知道咱们公司最新MM情报吗？加入公司的MM情报邮件组就行了，tom负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦</p><p><strong>观察者模式：</strong><br>观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。</p><h3 id="20-STATE"><a href="#20-STATE" class="headerlink" title="20. STATE"></a>20. STATE</h3><p>跟MM交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的MM就会说“有事情啦”，对你不讨厌但还没喜欢上的MM就会说“好啊，不过可以带上我同事么？”，已经喜欢上你的MM就会说“几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把MM的状态从不讨厌不喜欢变成喜欢哦。</p><p><strong>状态模式：</strong><br>状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。</p><h3 id="21-STRATEGY"><a href="#21-STRATEGY" class="headerlink" title="21. STRATEGY"></a>21. STRATEGY</h3><p>跟不同类型的MM约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到MM的芳心，我的追MM锦囊中有好多Strategy哦。</p><p><strong>策略模式：</strong><br>策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模式把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。</p><h3 id="22-TEMPLATE-METHOD"><a href="#22-TEMPLATE-METHOD" class="headerlink" title="22. TEMPLATE METHOD"></a>22. TEMPLATE METHOD</h3><p>看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤(Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦(具体实现)；</p><p><strong>模板方法模式：</strong><br>模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。</p><h3 id="23-VISITOR"><a href="#23-VISITOR" class="headerlink" title="23. VISITOR"></a>23. VISITOR</h3><p>情人节到了，要给每个MM送一束鲜花和一张卡片，可是每个MM送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下Visitor，让花店老板根据MM的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了。</p><p><strong>访问者模式：</strong><br>访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。</p>]]></content>
    
    <summary type="html">
    
      在网络上流畅很广的一篇旧文，暂时没找到原作者，作者用轻松的语言，形象解释了 23 种模式，有很好的启发作用。
    
    </summary>
    
      <category term="java" scheme="http://miclee.site/categories/java/"/>
    
    
      <category term="设计模式" scheme="http://miclee.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件比较</title>
    <link href="http://miclee.site/2019/01/14/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%BE%83/"/>
    <id>http://miclee.site/2019/01/14/消息中间件比较/</id>
    <published>2019-01-14T09:56:49.000Z</published>
    <updated>2019-01-14T10:37:33.489Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 一发一存一消费，没有最好的消息队列中间件(简称消息中间件)，只有最合适的消息中间件。 </em></strong><br><a id="more"></a></p><hr><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>非实时性<br>当不需要立即获得结果，但是并发量又需要进行控制的时候，差不多就是需要使用消息队列的时候。主要解决了应用耦合、异步处理、流量削锋等问题。</li><li>应用耦合<br>多应用间通过消息队列对同一消息进行处理，避免调用接口失败导致整个过程失败；（如：订单-&gt;库存）</li><li>异步处理<br>多应用对消息队列中同一消息进行处理，应用间并发处理消息，相比串行处理，减少处理时间；(点对多场景，广播场景(注册发短信，发邮件)等等)</li><li>限流削峰<br>应用于秒杀或抢购活动中，避免流量过大导致应用系统挂掉的情况；</li><li>消息驱动的系统<br>系统分为消息队列、消息生产者、消息消费者，生产者负责产生消息，消费者(可能有多个)负责对消息进行处理；分工处理(各自对应相应的队列)，灵活应用(收到就处理/定时处理)</li></ul><h3 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h3><ul><li>点对点<br>每个消息只有一个消费者（Consumer），不可重复消费(一旦被消费，消息就不再在消息队列中)</li><li><p>发布/订阅<br>微信公众号(Topic)，大伙(订阅者)订阅关注之后，微信公众号运营平台(发布者)发布信息后，大伙微信就都收到信息了，这里其实还分pull/push的。一个是主动推送，一个是被动拉取<br>基于发布/订阅模式做扩展就是横向扩展，多个队列及消费分组订阅(提高消费能力)</p></li><li><p>pull<br>主动权在于消费方，优点是按需消费(吃自助餐，能吃多少拿多少)，而且服务端队列堆积的消息处理也相对简单(不用记录状态啊，状态都消费端)；缺点就是消息延迟(不知道啥时候去拉取更新)，这时候有小伙伴会问，那为啥不叫服务端通知一下呢(有句话叫不在其位不谋其政，服务端通知必然要记录通知状态和增加之间的通信带宽；当然也可以根据实际情况来选择和push组合起来用(男女搭配干活不累嘛)来提高消息的实时性)</p></li><li>push<br>主动权就在服务方了，优点是实时性高，服务端可以统一管理来进行负载，不过也容易导致慢消费(就得考虑消费方受不受得了，毕竟你说你了解，但也只有对方才清楚你有多了解)；缺点就是发送消息的状态是集中式管理，压力大啊(要分发消息还要记录状态还要做备份，又当爹来又当妈，你说累不累)<br>对于顺序消息，这种场景有限且成本太高的方式就得慎重考虑了，对那种全局有序但允许出现小误差的场景(日志推送)，pull模式就非常适合了(所以说kafka为啥常用于日志处理、大数据等方面)，要问为什么？自己去领悟</li></ul><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><ol><li>功能<br>这个就多了，优先级队列、延迟队列(划分不同的延迟队列来避免重新排序消耗性能，缺点嘛自己悟)、死信队列(放没有推送成功的)、消费模式(pull/push)、广播消费、消息回溯(可追溯嘛，不然被卖了都不知道是谁)、消息堆积+持久化、消息追踪(链路条，方便定位)、消息过滤(根据规则过滤啊，不同类别消息发送到不同topic)、多协议支持(通用性)、跨语言支持(流行程度)、流量控制(嘿嘿嘿，上面有)、消息顺序性(还要再说一遍？)、安全机制(身份认证，权限认证(读写))、消息幂等性(承诺知道不，答应人家的事就一定要做到)、事务性消息(不想说)等</li><li>性能<br>一般是指其吞吐量(统一大小的消息体和不同大小的消息体生产和消耗能力)，性能和功能很多时候是相悖的，鱼和熊掌不可兼得。</li><li>高可靠、高可用<br>先说可靠，主要在于消息的持久化这一块(消息只要写入就一定会被消费，不会因为故障导致数据丢失(这个就很好测试出来了吧))。如果是从系统的角度来看就得从整体的维度去衡量了(不能单单只靠消息中间件本身，要从生产端、服务端、消费端三个维度去保障)。<br>再说可用，主要在于一个是对外部服务的依赖性(像kafka依赖zookeeper)，依赖也分强依赖和弱依赖，一个在于本身的备份机制所带来的保障性(像主从复制这种备份啊，增加多个slave来加强保障同时也会存在资源浪费，大部分时候Slave可能是空闲的)。</li><li>运维<br>通常有审核评估啊、监控啊、报警提醒啊、容灾啊、扩容啊、升级部署等等，一方面看中间件支撑的维度，一方面就看结合自动化运维的难易度<br>社区力度及生态发展：这个好理解吧，使用开源框架最开始基本上愉快的奔跑，但时不时的总会掉坑里，能不能爬出来一方面看自身的实力，一方面就看社区的力度了</li><li>成本<br>尽量贴合团队自身的技术栈体系，让一个C栈的团队去深挖zeroMQ总比scala编写kafka要容易的多<br><img src="https://raw.githubusercontent.com/ofmiclee/img-hosting/master/distributed/MQvs1.png" alt="">    </li></ol><h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p>基于erlang开发，是采用Erlang语言实现的AMQP协议的消息中间件，最初起源于金融系统，用于在分布式系统中存储转发消息。RabbitMQ发展到今天，被越来越多的人认可，这和它在可靠性、可用性、扩展性、功能丰富等方面的卓越表现是分不开的。</p><ul><li><p>优点：<br>由于erlang语言的特性，mq性能较好，高并发；<br>健壮、稳定、易用、跨平台、支持多种语言、文档齐全；<br>有消息确认机制和持久化机制，可靠性高；<br>高度可定制的路由；<br>管理界面较丰富，在互联网公司也有较大规模的应用；<br>社区活跃度高；  </p></li><li><p>缺点：<br>尽管结合erlang语言本身的并发优势，性能较好，但是不利于做二次开发和维护；<br>实现了代理架构，意味着消息在发送到客户端之前可以在中央节点上排队。此特性使得RabbitMQ易于使用和部署，但是使得其运行速度较慢，因为中央节点增加了延迟，消息封装后也比较大；<br>需要学习比较复杂的接口和协议，学习和维护成本较高；  </p></li></ul><h4 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h4><p>基于java开发，是Apache出品的、采用Java语言编写的完全基于JMS1.1规范的面向消息的中间件，为应用程序提供高效的、可扩展的、稳定的和安全的企业级消息通信。不过由于历史原因包袱太重，目前市场份额没有后面三种消息中间件多，其最新架构被命名为Apollo,(京东的消息中间件就是基于activeMQ开发的)</p><ul><li><p>优点：<br>跨平台(JAVA编写与平台无关有，ActiveMQ几乎可以运行在任何的JVM上)<br>可以用JDBC：可以将数据持久化到数据库<br>支持JMS ：支持JMS的统一接口;<br>支持自动重连；<br>有安全机制：支持基于shiro，jaas等多种安全配置机制，可以对Queue/Topic进行认证和授权<br>监控完善：拥有完善的监控，包括Web Console，JMX，Shell命令行，Jolokia的REST API；<br>界面友善：提供的Web Console可以满足大部分情况，还有很多第三方的组件可以使用，如hawtio；  </p></li><li><p>缺点：<br>社区活跃度不及RabbitMQ高；<br>会出莫名其妙的问题，会丢失消息；<br>不适合用于上千个队列的应用场景；  </p></li></ul><h4 id="zeroMQ"><a href="#zeroMQ" class="headerlink" title="zeroMQ"></a>zeroMQ</h4><p>基于C开发，号称史上最快的消息队列，基于C语言开发。ZeroMQ是一个消息处理队列库，可在多线程、多内核和主机之间弹性伸缩，虽然大多数时候我们习惯将其归入消息队列家族之中，但是其和前面的几款有着本质的区别，ZeroMQ本身就不是一个消息队列服务器，更像是一组底层网络通讯库，对原有的Socket API上加上一层封装而已。</p><ul><li><p>优点：<br>号称最快的消息队列系统，尤其针对大吞吐量的需求场景<br>单独部署或集成到应用中使用，不需要安装和运行一个消息服务器或中间件，因为你的应用程序将扮演了这个服务角色<br>能够实现高级/复杂的队列，但是开发人员需要自己组合多种技术框架<br>跨平台，多语言支持<br>可作为Socket通信库使用  </p></li><li><p>缺点：<br>仅提供非持久性的队列，也就是说如果down机，数据将会丢失</p></li></ul><h4 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h4><p>基于java开发（阿里消息中间件），是阿里开源的消息中间件，目前已经捐献个Apache基金会，它是由Java语言开发的，具备高吞吐量、高可用性、适合大规模分布式系统应用等特点，经历过双11的洗礼，实力不容小觑。</p><p><strong>几个重要概念：</strong>  </p><ul><li>Broker：简单来说就是消息队列服务器实体。  </li><li>Exchange：消息交换机，它指定消息按什么规则，路由到哪个队列。</li><li>Queue：消息队列载体，每个消息都会被投入到一个或多个队列。</li><li>Binding：绑定，它的作用就是把exchange和queue按照路由规则绑定起来。</li><li>Routing Key：路由关键字，exchange根据这个关键字进行消息投递。</li><li>vhost：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。</li><li>producer：消息生产者，就是投递消息的程序。</li><li>consumer：消息消费者，就是接受消息的程序。  </li><li><p>channel：消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。         </p></li><li><p>优点：<br>单机支持 1 万以上持久化队列<br>RocketMQ 的所有消息都是持久化的，先写入系统 pagecache(页高速缓冲存储器)，然后刷盘，可以保证内存与磁盘都有一份数据，访问时，直接从内存读取；<br>模型简单，接口易用（JMS 的接口很多场合并不太实用）；<br>性能非常好，可以大量堆积消息在broker(集群中包含一个或多个服务器，这些服务器被称为broker)中；<br>支持多种消费，包括集群消费、广播消费等；<br>各个环节分布式扩展设计，主从HA(高可用性集群)；<br>开发度较活跃，版本更新很快；  </p></li><li><p>缺点：<br>支持的客户端语言不多，目前是java及c++，其中c++不成熟；<br>RocketMQ社区关注度及成熟度也不及前两者；<br>没有web管理界面，提供了一个CLI(命令行界面)管理工具带来查询、管理和诊断各种问题；<br>没有在 mq 核心中去实现JMS等接口；  </p></li></ul><h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><p>基于Scala和Java开发，起初是由LinkedIn公司采用Scala语言开发的一个分布式、多分区、多副本且基于zookeeper协调的分布式消息系统，现已捐献给Apache基金会。它是一种高吞吐量的分布式发布订阅消息系统，以可水平扩展和高吞吐率而被广泛使用。目前越来越多的开源分布式处理系统如Cloudera、Apache Storm、Spark、Flink等都支持与Kafka集成。  </p><p><strong>几个重要概念：</strong></p><ul><li>Broker：Kafka集群包含一个或多个服务器，这种服务器被称为broker</li><li>Topic：每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。</li><li>Partition：Parition是物理上的概念，每个Topic包含一个或多个Partition.</li><li>Producer：负责发布消息到Kafka broker</li><li>Consumer：消息消费者，向Kafka broker读取消息的客户端。  </li><li><p>Consumer Group：每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）                </p></li><li><p>优点：<br>客户端语言丰富，支持java、.net、php、ruby、python、go等多种语言；<br>性能卓越，单机写入TPS约在百万条/秒，消息大小10个字节；<br>提供完全分布式架构, 并有replica机制, 拥有较高的可用性和可靠性, 理论上支持消息无限堆积；<br>支持批量操作；<br>消费者采用Pull方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;<br>有优秀的第三方Kafka Web管理界面Kafka-Manager；<br>在日志领域比较成熟，被多家公司和多个开源项目使用；  </p></li><li><p>缺点：<br>Kafka单机超过64个队列/分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间变长；<br>使用短轮询方式，实时性取决于轮询间隔时间；<br>消费失败不支持重试；<br>支持消息顺序，但是一台代理宕机后，就会产生消息乱序；<br>社区更新较慢；  </p></li></ul><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><p>Redis的PUB/SUB机制，即发布-订阅模式。利用的Redis的列表(lists)数据结构。比较好的使用模式是，生产者lpush消息，消费者brpop消息，并设定超时时间，可以减少redis的压力。只有在Redis宕机且数据没有持久化的情况下丢失数据，可以根据业务通过AOF和缩短持久化间隔来保证很高的可靠性，而且也可以通过多个client来提高消费速度。但相对于专业的消息队列来说，该方案消息的状态过于简单(没有状态)，且没有ack机制，消息取出后消费失败依赖于client记录日志或者重新push到队列里面。<br>redis不支持分组(这点很重要，在做负载均衡的时候劣势就体现出来)，不过可以完全当做一个轻量级的队列使用，但redis他爹做了disque，可以去试一试。</p><h3 id="RabbitMQ-vs-Kafka"><a href="#RabbitMQ-vs-Kafka" class="headerlink" title="RabbitMQ vs Kafka"></a>RabbitMQ vs Kafka</h3><ul><li><p>功能对比：<br><img src="https://raw.githubusercontent.com/ofmiclee/img-hosting/master/distributed/MQvs2.png" alt=""><br><img src="https://raw.githubusercontent.com/ofmiclee/img-hosting/master/distributed/MQvs3.png" alt=""><br><img src="https://raw.githubusercontent.com/ofmiclee/img-hosting/master/distributed/MQvs4.png" alt="">    </p></li><li><p>应用方面：<br>RabbitMQ,遵循AMQP协议，由内在高并发的erlanng语言开发，用在实时的对可靠性要求比较高的消息传递上。<br>kafka它主要用于处理活跃的流式数据,大数据量的数据处理上。</p></li><li><p>架构模型方面：<br>RabbitMQ遵循AMQP协议，RabbitMQ的broker由Exchange,Binding,queue组成，其中exchange和binding组成了消息的路由键；客户端Producer通过连接channel和server进行通信，Consumer从queue获取消息进行消费（长连接，queue有消息会推送到consumer端，consumer循环从输入流读取数据）。rabbitMQ以broker为中心；有消息的确认机制。<br>kafka遵从一般的MQ结构，producer，broker，consumer，以consumer为中心，消息的消费信息保存的客户端consumer上，consumer根据消费的点，从broker上批量pull数据；无消息确认机制。</p></li><li><p>吞吐量：<br>rabbitMQ在吞吐量方面稍逊于kafka，他们的出发点不一样，rabbitMQ支持对消息的可靠的传递，支持事务，不支持批量的操作；基于存储的可靠性的要求存储可以采用内存或者硬盘。<br>kafka具有高的吞吐量，内部采用消息的批量处理，zero-copy机制，数据的存储和获取是本地磁盘顺序批量操作，具有O(1)的复杂度，消息处理的效率很高。</p></li><li><p>可用性方面：<br>rabbitMQ支持miror(镜像)的queue，主queue失效，miror queue接管。<br>kafka的broker支持主备模式。</p></li><li><p>集群负载均衡方面：<br>rabbitMQ的负载均衡需要单独的loadbalancer进行支持。<br>kafka采用zookeeper对集群中的broker、consumer进行管理，可以注册topic到zookeeper上；通过zookeeper的协调机制，producer保存对应topic的broker信息，可以随机或者轮询发送到broker上；并且producer可以基于语义指定分片，消息发送到broker的某分片上。</p></li></ul><p>参考链接：<a href="https://juejin.im/post/5b32044ef265da59654c3027" target="_blank" rel="noopener">https://juejin.im/post/5b32044ef265da59654c3027</a></p>]]></content>
    
    <summary type="html">
    
      一发一存一消费，没有最好的消息队列中间件(简称消息中间件)，只有最合适的消息中间件。
    
    </summary>
    
      <category term="Spring Cloud" scheme="http://miclee.site/categories/Spring-Cloud/"/>
    
    
      <category term="分布式" scheme="http://miclee.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务</title>
    <link href="http://miclee.site/2019/01/11/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <id>http://miclee.site/2019/01/11/分布式事务/</id>
    <published>2019-01-11T10:33:31.000Z</published>
    <updated>2019-01-11T12:27:19.296Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 现今互联网界，分布式系统和微服务架构盛行。一个简单操作，在服务端非常可能是由多个服务和数据库实例协同完成的。在互联网金融等一致性要求较高的场景下，多个独立操作之间的一致性问题显得格外棘手。基于水平扩容能力和成本考虑，传统的强一致的解决方案（e.g.单机事务）纷纷被抛弃。其理论依据就是响当当的CAP原理。我们往往为了可用性和分区容错性，忍痛放弃强一致支持，转而追求最终一致性。大部分业务场景下，我们是可以接受短暂的不一致的。 </em></strong><br><a id="more"></a></p><hr><h3 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h3><p>关于分布式理论可以参考另一篇博文：<a href="http://miclee.site/2018/12/24/%E5%88%86%E5%B8%83%E5%BC%8F%E9%A2%86%E5%9F%9FCAP%E7%90%86%E8%AE%BA/">分布式领域CAP理论</a>  </p><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><h4 id="一、两阶段提交-2PC"><a href="#一、两阶段提交-2PC" class="headerlink" title="一、两阶段提交 2PC"></a>一、两阶段提交 2PC</h4><p><img src="https://raw.githubusercontent.com/ofmiclee/img-hosting/master/distributed/2PC.png" alt=""><br>两阶段提交这种解决方案属于牺牲了一部分可用性来换取的一致性。在实现方面，在 .NET 中，可以借助 TransactionScop 提供的 API 来编程实现分布式系统中的两阶段提交，比如WCF中就有实现这部分功能。不过在多服务器之间，需要依赖于DTC来完成事务一致性，Windows下微软搞的有MSDTC服务，Linux下就比较悲剧了。</p><p>另外说一句，TransactionScop 默认不能用于异步方法之间事务一致，因为事务上下文是存储于当前线程中的，所以如果是在异步方法，需要显式的传递事务上下文。</p><p>优点： 尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能100%保证强一致）<br>缺点： 实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景，如果分布式系统跨接口调用，目前 .NET 界还没有实现方案。  </p><h4 id="二、补偿事务-TCC"><a href="#二、补偿事务-TCC" class="headerlink" title="二、补偿事务 TCC"></a>二、补偿事务 TCC</h4><p>TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：</p><p>Try 阶段主要是对业务系统做检测及资源预留<br>Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。<br>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。</p><p>举个例子，假入 Bob 要向 Smith 转账，思路大概是：<br>我们有一个本地方法，里面依次调用<br>1、首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。<br>2、在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。<br>3、如果第2步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。</p><p>优点： 跟2PC比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些<br>缺点： 缺点还是比较明显的，在2,3步中都有可能失败。TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理。</p><h4 id="三、本地消息表"><a href="#三、本地消息表" class="headerlink" title="三、本地消息表"></a>三、本地消息表</h4><p><img src="https://raw.githubusercontent.com/ofmiclee/img-hosting/master/distributed/%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8.png" alt=""><br>基本思路就是：</p><p>消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。</p><p>消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。</p><p>生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。如果有靠谱的自动对账补账逻辑，这种方案还是非常实用的。</p><p>这种方案遵循BASE理论，采用的是最终一致性，笔者认为是这几种方案里面比较适合实际业务场景的，即不会出现像2PC那样复杂的实现(当调用链很长的时候，2PC的可用性是非常低的)，也不会像TCC那样可能出现确认或者回滚不了的情况。</p><p>优点： 一种非常经典的实现，避免了分布式事务，实现了最终一致性。在 .NET中 有现成的解决方案。<br>缺点： 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。  </p><h4 id="四、MQ-事务消息"><a href="#四、MQ-事务消息" class="headerlink" title="四、MQ 事务消息"></a>四、MQ 事务消息</h4><p><img src="https://raw.githubusercontent.com/ofmiclee/img-hosting/master/distributed/MQ%20%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF.png" alt=""><br>有一些第三方的MQ是支持事务消息的，比如RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交，但是市面上一些主流的MQ都是不支持事务消息的，比如 RabbitMQ 和 Kafka 都不支持。</p><p>以阿里的 RocketMQ 中间件为例，其思路大致为：</p><p>第一阶段Prepared消息，会拿到消息的地址。<br>第二阶段执行本地事务，第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。</p><p>也就是说在业务方法内要想消息队列提交两次请求，一次发送消息和一次确认消息。如果确认消息发送失败了RocketMQ会定期扫描消息集群中的事务消息，这时候发现了Prepared消息，它会向消息发送者确认，所以生产方需要实现一个check接口，RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。  </p><p>优点： 实现了最终一致性，不需要依赖本地数据库事务。<br>缺点： 实现难度大，主流MQ不支持，RocketMQ事务消息部分代码也未开源。  </p><h4 id="五、Sagas-事务模型"><a href="#五、Sagas-事务模型" class="headerlink" title="五、Sagas 事务模型"></a>五、Sagas 事务模型</h4><p>Saga事务模型又叫做长时间运行的事务（Long-running-transaction）, 它是由普林斯顿大学的H.Garcia-Molina等人提出，它描述的是另外一种在没有两阶段提交的的情况下解决分布式系统中复杂的业务事务问题。你可以在这里看到 Sagas 相关论文。</p><p>我们这里说的是一种基于 Sagas 机制的工作流事务模型，这个模型的相关理论目前来说还是比较新的，以至于百度上几乎没有什么相关资料。</p><p>该模型其核心思想就是拆分分布式系统中的长事务为多个短事务，或者叫多个本地事务，然后由 Sagas 工作流引擎负责协调，如果整个流程正常结束，那么就算是业务成功完成，如果在这过程中实现失败，那么Sagas工作流引擎就会以相反的顺序调用补偿操作，重新进行业务回滚。</p><p>比如我们一次关于购买旅游套餐业务操作涉及到三个操作，他们分别是预定车辆，预定宾馆，预定机票，他们分别属于三个不同的远程接口。可能从我们程序的角度来说他们不属于一个事务，但是从业务角度来说是属于同一个事务的。<br><img src="https://raw.githubusercontent.com/ofmiclee/img-hosting/master/distributed/Sagas%20%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%9E%8B.png" alt=""><br>他们的执行顺序如上图所示，所以当发生失败时，会依次进行取消的补偿操作。</p><p>因为长事务被拆分了很多个业务流，所以 Sagas 事务模型最重要的一个部件就是工作流或者你也可以叫流程管理器（Process Manager），工作流引擎和Process Manager虽然不是同一个东西，但是在这里，他们的职责是相同的。在选择工作流引擎之后，最终的代码也许看起来是这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SagaBuilder saga = SagaBuilder.newSaga(&quot;trip&quot;)</span><br><span class="line">        .activity(&quot;Reserve car&quot;, ReserveCarAdapter.class)</span><br><span class="line">        .compensationActivity(&quot;Cancel car&quot;, CancelCarAdapter.class)</span><br><span class="line">        .activity(&quot;Book hotel&quot;, BookHotelAdapter.class)</span><br><span class="line">        .compensationActivity(&quot;Cancel hotel&quot;, CancelHotelAdapter.class)</span><br><span class="line">        .activity(&quot;Book flight&quot;, BookFlightAdapter.class)</span><br><span class="line">        .compensationActivity(&quot;Cancel flight&quot;, CancelFlightAdapter.class)</span><br><span class="line">        .end()</span><br><span class="line">        .triggerCompensationOnAnyError();</span><br><span class="line"></span><br><span class="line">camunda.getRepositoryService().createDeployment()</span><br><span class="line">        .addModelInstance(saga.getModel())</span><br><span class="line">        .deploy();</span><br></pre></td></tr></table></figure></p><p>一个.NET版本的开源框架：<a href="https://github.com/dotnetcore/CAP" target="_blank" rel="noopener">https://github.com/dotnetcore/CAP</a></p>]]></content>
    
    <summary type="html">
    
      现今互联网界，分布式系统和微服务架构盛行。一个简单操作，在服务端非常可能是由多个服务和数据库实例协同完成的。在互联网金融等一致性要求较高的场景下，多个独立操作之间的一致性问题显得格外棘手。基于水平扩容能力和成本考虑，传统的强一致的解决方案（e.g.单机事务）纷纷被抛弃。其理论依据就是响当当的CAP原理。我们往往为了可用性和分区容错性，忍痛放弃强一致支持，转而追求最终一致性。大部分业务场景下，我们是可以接受短暂的不一致的。
    
    </summary>
    
      <category term="Spring cloud" scheme="http://miclee.site/categories/Spring-cloud/"/>
    
    
      <category term="分布式" scheme="http://miclee.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>基于sharding-sphere无需数据迁移的弹性扩容分片算法</title>
    <link href="http://miclee.site/2018/12/30/%E6%97%A0%E9%9C%80%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E7%9A%84%E5%BC%B9%E6%80%A7%E6%89%A9%E5%AE%B9%E5%88%86%E7%89%87%E7%AE%97%E6%B3%95/"/>
    <id>http://miclee.site/2018/12/30/无需数据迁移的弹性扩容分片算法/</id>
    <published>2018-12-30T08:39:06.000Z</published>
    <updated>2018-12-30T09:11:25.091Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 常见的分库分表方案大都用主键mod一个数（如分为8个库，则 id % 8 根据余数决定落到哪个分片）。此种方案中，如果要拓展数据库将是十分复杂的事情（例如拓展为10个，则代码需要改为 id % 10 之前的旧数据也要做迁移）。我们希望有一种支持自由规划无须数据迁移和修改路由代码的Sharding扩容方案。 </em></strong><br><a id="more"></a></p><hr><h3 id="Sharding-sphere介绍"><a href="#Sharding-sphere介绍" class="headerlink" title="Sharding-sphere介绍"></a>Sharding-sphere介绍</h3><p>sharding-sphere是基于当当的开源框架sharding-jdbc，团队加入京东后，现在成为Apache的项目。整个集合包含三个产品：  </p><h4 id="1-Sharding-jdbc"><a href="#1-Sharding-jdbc" class="headerlink" title="1. Sharding-jdbc"></a>1. Sharding-jdbc</h4><p>Sharding-JDBC是Sharding-Sphere的第一个产品，也是Sharding-Sphere的前身。 它定位为轻量级Java框架，在Java的JDBC层提供分库分表、读写分离、数据库治理、柔性事务等服务。它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。</p><h4 id="2-Sharding-Proxy"><a href="#2-Sharding-Proxy" class="headerlink" title="2. Sharding-Proxy"></a>2. Sharding-Proxy</h4><p>Sharding-Proxy是Sharding-Sphere的第二个产品。 定位为透明化的数据库代理端，提供封装了数据库二进制协议的服务端版本，用于完成对异构语言的支持。 目前先提供MySQL版本，它可以使用任何兼容MySQL协议的访问客户端(如：MySQL Command Client, MySQL Workbench等)操作数据，对DBA更加友好。</p><h4 id="3-Sharding-Sidecar"><a href="#3-Sharding-Sidecar" class="headerlink" title="3. Sharding-Sidecar"></a>3. Sharding-Sidecar</h4><p>Sharding-Sidecar定位为Kubernetes或Mesos的云原生数据库代理，以DaemonSet的形式代理所有对数据库的访问。 通过无中心、零侵入的方案提供与数据库交互的的啮合层，即Database Mesh，又可称数据网格。<br>Database Mesh的关注重点在于如何将分布式的数据访问应用与数据库有机串联起来，它更加关注的是交互，是将杂乱无章的应用与数据库之间的交互有效的梳理。使用Database Mesh，访问数据库的应用和数据库终将形成一个巨大的网格体系，应用和数据库只需在网格体系中对号入座即可，它们都是被啮合层所治理的对象。</p><h4 id="4-Mixed-scheme-of-Sharding-JDBC-amp-Sharding-Proxy"><a href="#4-Mixed-scheme-of-Sharding-JDBC-amp-Sharding-Proxy" class="headerlink" title="4. Mixed scheme of Sharding-JDBC &amp; Sharding-Proxy"></a>4. Mixed scheme of Sharding-JDBC &amp; Sharding-Proxy</h4><p><strong>混合架构</strong><br>Sharding-JDBC采用无中心化架构，适用于Java开发的高性能的轻量级OLTP应用；Sharding-Proxy提供静态入口以及异构语言的支持，适用于OLAP应用以及对分片数据库进行管理和运维的场景。</p><p>ShardingSphere是多接入端共同组成的生态圈。 通过混合使用Sharding-JDBC和Sharding-Proxy，并采用同一注册中心统一配置分片策略，能够灵活的搭建适用于各种场景的应用系统，使得架构师更加自由的调整适合与当前业务的最佳系统架构。  </p><p><img src="http://cdn.processon.com/5c0f6316e4b0c87510c92820?e=1544515878&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:TJvZtqEh2px8v3TebojfI6HHuGU=" alt=""></p><h3 id="分片方案设计"><a href="#分片方案设计" class="headerlink" title="分片方案设计"></a>分片方案设计</h3><p>前面了解了Twitter-Snowflake分库分表算法的实现，而Snowflake主键算法本身就带时间戳，我们可以基于它实现无需数据迁移的扩容方案。<br>　　Snowflake生成的ID是一个64位的Long值，通过主键可以算出两个维度的值：</p><ul><li>时间维度<br>主键的前42位就是一个以毫秒为单位的时间戳。  </li><li>分片维度<br>对主键做Hash运算（为了得到的hash值尽可能散，使用MurmurHash算法），可以得到一个32位的hash值，我们以它的前16位作为数据库分片值，后16位作为表分片值。</li></ul><p>如此一来，只需根据时间戳，指定某一时间戳后使用新的分片规则，即可不迁移数据对数据库进行扩容。  </p><p><strong>具体实现</strong><br>这只是个算法和框架无关，你可以基于各种分库分表中间件实现它，此处基于当当网的Sharding-JDBC写了实现（修改中，未Merge），<a href="https://github.com/sharding-sphere/sharding-sphere/issues/186" target="_blank" rel="noopener">Issue地址</a>，<a href="https://github.com/xydonne/sharding-jdbc/tree/hash-sharding/186" target="_blank" rel="noopener">Branch地址</a></p><hr><p>参考：<a href="http://www.jianshu.com/p/d296fa2bf61b" target="_blank" rel="noopener">http://www.jianshu.com/p/d296fa2bf61b</a></p>]]></content>
    
    <summary type="html">
    
      常见的分库分表方案大都用主键mod一个数（如分为8个库，则 id % 8 根据余数决定落到哪个分片）。此种方案中，如果要拓展数据库将是十分复杂的事情（例如拓展为10个，则代码需要改为 id % 10 之前的旧数据也要做迁移）。我们希望有一种支持自由规划无须数据迁移和修改路由代码的Sharding扩容方案。
    
    </summary>
    
      <category term="电商交易" scheme="http://miclee.site/categories/%E7%94%B5%E5%95%86%E4%BA%A4%E6%98%93/"/>
    
    
      <category term="分布式" scheme="http://miclee.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式ID</title>
    <link href="http://miclee.site/2018/12/30/%E5%88%86%E5%B8%83%E5%BC%8FID/"/>
    <id>http://miclee.site/2018/12/30/分布式ID/</id>
    <published>2018-12-30T08:38:18.000Z</published>
    <updated>2019-01-11T11:18:25.540Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 分布式系统下典型的一个场景就是分布式ID的设计，会有哪些可用方案呢？ </em></strong><br><a id="more"></a></p><hr><h3 id="主键生成策略"><a href="#主键生成策略" class="headerlink" title="主键生成策略"></a>主键生成策略</h3><p>系统唯一ID是我们在设计一个系统的时候常常会遇见的问题，下面介绍一些常见的ID生成策略。  </p><ul><li>Sequence ID</li><li>UUID</li><li>GUID</li><li>COMB</li><li>Snowflake</li></ul><p>最开始的自增ID为了实现分库分别的需求，会在自增的前提下，使用不同步长(例如DB1 生成1,4,7,10，DB2生成2,5,8,11，DB3生成3,6,9,12)，但需要做数据库拓展时，极其麻烦。<br>相比自增ID，UUID生成唯一主键更加方便（数据量非常大的情况下，存在重复的可能），但由于UUID的无序性，性能不如自增ID，字符串储存，储存空间大，查询效率低。<br>COMB相对于UUID，增加了生成ID的有序性，插入与查询效率都有所提高。<br>Sonwflake是Twitter主键生成策略，可以看做是COMB的一种改进，用64位的长整型代替128位的字符串。ID构成：第一位0 + 41位的时间前缀 + 10位的节点标识 + 12位的sequence避免并发的数字。  </p><h4 id="1-Sequence-ID"><a href="#1-Sequence-ID" class="headerlink" title="1. Sequence ID"></a>1. Sequence ID</h4><p>数据库自增长序列或字段，最常见的方式。由数据库维护，数据库唯一。<br><strong>优点：</strong><br>简单，代码方便，性能可以接受。<br>数字ID天然排序，对分页或者需要排序的结果很有帮助。</p><p><strong>缺点：</strong><br>不同数据库语法和实现不同，数据库迁移的时候或多数据库版本支持的时候需要处理。<br>在单个数据库或读写分离或一主多从的情况下，只有一个主库可以生成。有单点故障的风险。<br>在性能达不到要求的情况下，比较难于扩展。<br>如果遇见多个系统需要合并或者涉及到数据迁移会相当痛苦。<br>分表分库的时候会有麻烦。</p><p><strong>优化方案：</strong><br>针对主库单点，如果有多个Master库，则每个Master库设置的起始数字不一样，步长一样，可以是Master的个数。<br>比如：Master1 生成的是 1，4，7，10，Master2生成的是2,5,8,11 Master3生成的是 3,6,9,12。这样就可以有效生成集群中的唯一ID，也可以大大降低ID生成数据库操作的负载。</p><h4 id="2-UUID"><a href="#2-UUID" class="headerlink" title="2. UUID"></a>2. UUID</h4><p>常见的方式,128位。可以利用数据库也可以利用程序生成，一般来说全球唯一。<br><strong>优点：</strong><br>简单，代码方便。<br>全球唯一，在遇见数据迁移，系统数据合并，或者数据库变更等情况下，可以从容应对。</p><p><strong>缺点：</strong><br>没有排序，无法保证趋势递增。<br>UUID往往是使用字符串存储，查询的效率比较低。<br>存储空间比较大，如果是海量数据库，就需要考虑存储量的问题。<br>传输数据量大<br>不可读。</p><p><strong>优化方案：</strong><br>为了解决UUID不可读，可以使用UUID to Int64的方法。</p><h4 id="3-GUID"><a href="#3-GUID" class="headerlink" title="3. GUID"></a>3. GUID</h4><p>GUID：是微软对UUID这个标准的实现。UUID还有其它各种实现，不止GUID一种。优缺点同UUID。</p><h4 id="4-COMB"><a href="#4-COMB" class="headerlink" title="4. COMB"></a>4. COMB</h4><p>COMB（combine）型是数据库特有的一种设计思想，可以理解为一种改进的GUID，它通过组合GUID和系统时间，以使其在索引和检索事有更优的性能。<br>数据库中没有COMB类型，它是Jimmy Nilsson在他的“The Cost of GUIDs as Primary Keys”一文中设计出来的。<br>COMB数据类型的基本设计思路是这样的：既然UniqueIdentifier数据因毫无规律可言造成索引效率低下，影响了系统的性能，那么我们能不能通过组合的方式，保留UniqueIdentifier的前10个字节，用后6个字节表示GUID生成的时间（DateTime），这样我们将时间信息与UniqueIdentifier组合起来，在保留UniqueIdentifier的唯一性的同时增加了有序性，以此来提高索引效率。</p><p><strong>优点：</strong><br>解决UUID无序的问题，在其主键生成方式中提供了Comb算法(combined guid/timestamp)。保留GUID的10个字节，用另6个字节表示GUID生成的时间(DateTime)。<br>性能优于UUID。</p><h4 id="5-Twitter的snowflake算法"><a href="#5-Twitter的snowflake算法" class="headerlink" title="5. Twitter的snowflake算法"></a>5. Twitter的snowflake算法</h4><p>snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。snowflake算法可以根据自身项目的需要进行一定的修改。比如估算未来的数据中心个数，每个数据中心的机器数以及统一毫秒可以能的并发数来调整在算法中所需要的bit数。  </p><p><strong>优点：</strong><br>不依赖于数据库，灵活方便，且性能优于数据库。<br>ID按照时间在单机上是递增的。</p><p><strong>缺点：</strong><br>在单机上是递增的，但是由于涉及到分布式环境，每台机器上的时钟不可能完全同步，也许有时候也会出现不是全局递增的情况。</p><hr><p><a href="http://www.jianshu.com/p/a0a3aa888a49" target="_blank" rel="noopener">From Donney Young -&gt;</a></p>]]></content>
    
    <summary type="html">
    
      分布式系统下典型的一个场景就是分布式ID的设计，会有哪些可用方案呢？
    
    </summary>
    
      <category term="Spring cloud" scheme="http://miclee.site/categories/Spring-cloud/"/>
    
    
      <category term="分布式" scheme="http://miclee.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>电商秒杀场景实现方案</title>
    <link href="http://miclee.site/2018/12/26/%E7%94%B5%E5%95%86%E7%A7%92%E6%9D%80%E5%9C%BA%E6%99%AF%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"/>
    <id>http://miclee.site/2018/12/26/电商秒杀场景实现方案/</id>
    <published>2018-12-26T03:27:01.000Z</published>
    <updated>2018-12-26T07:02:20.449Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 秒杀属于电商的常见业务场景，特点是时间短、瞬时并发量高。针对这样的场景我们需要怎样的技术方案来应对呢？ </em></strong><br><a id="more"></a></p><hr><p><strong>场景特点：</strong></p><ol><li>瞬时大访问量，流量波峰</li><li>用户不断刷新页面导致高并发</li><li>控制不能提前下单</li><li>下单防止超卖</li><li>单用户购买限制</li><li>页面更新为活动结束</li></ol><p><strong>解决方案：</strong></p><ol><li>如果同时秒杀商品较多，需要做服务隔离，单独部署甚至使用独立域名，避免对主应用影响；</li><li>单独设计秒杀商品页面，不使用网站原来的商品详细页面，页面内容静态化，上CDN，用户请求不需要经过应用服务；</li><li>设计单独控制秒杀按钮的JS文件（文件要非常小）放在js服务器上，由另外一台服务器写 定时任务 来控制js 推送；<br>可以使用xxx.js?v=随机数 的方式来避免js被浏览器缓存；<br>后端同时要做开始控制，避免跳过页面的接口访问；</li><li>商品秒杀库存提前放入redis。活动开始后利用redis decby原子命令或者watch乐观锁模式扣减库存；<br>扣减成功后异步通知消息到队列，可以用有界非阻塞队列，每个商品单独队列，界点为活动库存值（也可以用MQ）；<br>队列消费端连接商城正常下单逻辑；</li><li>用户进入秒杀接口立即在redis 注入标记，下单成功后用户标记保留（不能再下单），下单失败清除标记，用户可再次尝试</li><li>后台定时轮询读取redis活动库存，库存为0后推送新的js，将页面展现为“活动结束”，方案同第3点</li></ol><p><strong>防刷场景：</strong></p><ol><li>同一账号刷单<br>就是单用户购买限制，上面已经解决了</li><li>僵尸号刷单<br>通过检测指定机器IP请求频率解决，如果发现某个IP请求频率很高，可以给它弹出一个验证码或者直接禁止IP</li><li>僵尸号不同代理IP刷单<br>这种场景下的请求，和真实用户的行为，已经基本相同了，想做分辨很困难。再做进一步的限制很容易“误伤“真实用户，这个时候，通常只能通过设置业务门槛高来限制这种请求了，或者通过账号行为的”数据挖掘“来提前清理掉它们。<br>现在有专门的数据公司专业做这个业务，帮助电商的活动资源有效用在真实客户身上。但是进攻和防守，是一场永远不会停止的战争。</li></ol>]]></content>
    
    <summary type="html">
    
      秒杀属于电商的常见业务场景，特点是时间短、瞬时并发量高。针对这样的场景我们需要怎样的技术方案来应对呢？
    
    </summary>
    
      <category term="电商交易" scheme="http://miclee.site/categories/%E7%94%B5%E5%95%86%E4%BA%A4%E6%98%93/"/>
    
    
      <category term="高并发" scheme="http://miclee.site/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>分布式领域CAP理论</title>
    <link href="http://miclee.site/2018/12/24/%E5%88%86%E5%B8%83%E5%BC%8F%E9%A2%86%E5%9F%9FCAP%E7%90%86%E8%AE%BA/"/>
    <id>http://miclee.site/2018/12/24/分布式领域CAP理论/</id>
    <published>2018-12-24T08:03:56.000Z</published>
    <updated>2019-01-11T12:27:52.642Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 上篇文章讲到各注册中心设计中CAP的取舍，究竟什么是CAP呢？ </em></strong><br><a id="more"></a></p><hr><h3 id="分布式领域CAP理论"><a href="#分布式领域CAP理论" class="headerlink" title="分布式领域CAP理论"></a>分布式领域CAP理论</h3><p>CAP定理是由加州大学伯克利分校Eric Brewer教授提出来的，他指出WEB服务无法同时满足一下3个属性：</p><ul><li>一致性(Consistency) ： 客户端知道一系列的操作都会同时发生(生效)</li><li>可用性(Availability) ： 每个操作都必须以可预期的响应结束</li><li>分区容错性(Partition tolerance) ： 即使出现单个组件无法可用，操作依然可以完成<br>具体地讲在分布式系统中，在任何数据库设计中，一个Web应用至多只能同时支持上面的两个属性。显然，任何横向扩展策略都要依赖于数据分区。因此，设计人员必须在一致性与可用性之间做出选择。  </li></ul><h3 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h3><p>关系数据库的ACID模型拥有高一致性和高可用性：</p><ul><li>Atomicity 原子性：一个事务中所有操作都必须全部完成，要么全部不完成。</li><li>Consistency 一致性：在事务开始或结束时，数据库应该在一致状态。</li><li>Isolation 隔离性：事务将假定只有它自己在操作数据库，彼此不知晓。</li><li>Durability 持久性：一旦事务完成，就不能返回。</li><li>跨数据库事务：2PC (two-phase commit)， 2PC is the anti-scalability pattern (Pat Helland) 是反可伸缩模式的，JavaEE中的JTA事务可以支持2PC。因为2PC是反模式，尽量不要使用2PC，使用BASE来回避。</li></ul><p>比如本地事务数据库断电的这种情况，它是怎么保证数据一致性的呢？我们使用SQL Server来举例，我们知道我们在使用 SQL Server 数据库是由两个文件组成的，一个数据库文件和一个日志文件，通常情况下，日志文件都要比数据库文件大很多。数据库进行任何写入操作的时候都是要先写日志的，同样的道理，我们在执行事务的时候数据库首先会记录下这个事务的redo操作日志，然后才开始真正操作数据库，在操作之前首先会把日志文件写入磁盘，那么当突然断电的时候，即使操作没有完成，在重新启动数据库时候，数据库会根据当前数据的情况进行undo回滚或者是redo前滚，这样就保证了数据的强一致性。</p><h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><p>对数据库分布式事务有了解的同学一定知道数据库支持的2PC，又叫做 XA Transactions。<br>(MySQL从5.5版本开始支持，SQL Server 2005 开始支持，Oracle 7 开始支持。)  </p><p>其中，XA 是一个两阶段提交协议，该协议分为以下两个阶段：<br>第一阶段：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.<br>第二阶段：事务协调器要求每个数据库提交数据。<br>其中，如果有任何一个数据库否决此次提交，那么所有数据库都会被要求回滚它们在此事务中的那部分信息。这样做的缺陷是什么呢? 咋看之下我们可以在数据库分区之间获得一致性。</p><h3 id="BASE模型"><a href="#BASE模型" class="headerlink" title="BASE模型"></a>BASE模型</h3><p>在分布式系统中，我们往往追求的是可用性，它的重要程度比一致性要高，那么如何实现高可用性呢？前人已经给我们提出来了另外一个理论，就是BASE理论，它是用来对CAP定理进行进一步扩充的。BASE理论指的是：</p><ul><li>Basically Available：基本可用。支持分区失败(e.g. sharding碎片划分数据库)</li><li>Soft state：软状态，状态可以有一段时间不同步，异步。</li><li>Eventually consistent：最终一致性，最终数据是一致的就可以了，而不是时时高一致。</li></ul><p>BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。BASE思想主要强调基本的可用性，如果你需要High 可用性，也就是纯粹的高性能，那么就要以一致性或容错性为牺牲，BASE思想的方案在性能上还是有潜力可挖的。主要实现有：<strong>按功能划分数据库 &amp; sharding碎片</strong></p><p>现在NOSQL运动丰富了拓展了BASE思想，可按照具体情况定制特别方案，比如忽视一致性，获得高可用性等等，NOSQL应该有下面两个流派：</p><ol><li>Key-Value存储，如Amaze Dynamo等，可根据CAP三原则灵活选择不同倾向的数据库产品。</li><li>领域模型 + 分布式缓存 + 存储 （Qi4j和NoSql运动），可根据CAP三原则结合自己项目定制灵活的分布式方案，难度高。</li></ol><p>这两者共同点：都是关系数据库SQL以外的可选方案，逻辑随着数据分布，任何模型都可以自己持久化，将数据处理和数据存储分离，将读和写分离，存储可以是异步或同步，取决于对一致性的要求程度。<br>不同点：NOSQL之类的Key-Value存储产品是和关系数据库头碰头的产品BOX，可以适合非Java如PHP RUBY等领域，是一种可以拿来就用的产品，而领域模型 + 分布式缓存 + 存储是一种复杂的架构解决方案，不是产品，但这种方式更灵活，更应该是架构师必须掌握的。</p>]]></content>
    
    <summary type="html">
    
      上篇文章讲到各注册中心设计中CAP的取舍，究竟什么是CAP呢？
    
    </summary>
    
      <category term="Spring cloud" scheme="http://miclee.site/categories/Spring-cloud/"/>
    
    
      <category term="分布式" scheme="http://miclee.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Spring cloud注册中心</title>
    <link href="http://miclee.site/2018/12/24/ConsulvsZookeepervsEtcdvsEureka/"/>
    <id>http://miclee.site/2018/12/24/ConsulvsZookeepervsEtcdvsEureka/</id>
    <published>2018-12-24T07:20:09.000Z</published>
    <updated>2018-12-24T08:03:41.716Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> eureka官方已经正式宣布：自2.0起不再维护该项目，并在github 项目wiki上放出了一段吓唬人的话，大意就是：从2.x起，官方不会继续开发了，如果需要使用2.x，风险自负。 </em></strong><br><a id="more"></a></p><hr><p>但其实我觉得问题并不大，eureka目前的功能已经非常稳定，就算不升级，服务注册/发现这些功能已经够用。如果想寻找替代方案的话，建议采用功能更为丰富的consul，除了服务注册、发现，consul还提供了k-v存储等其它功能，consul的官网针对其它同类软件也做了详细比较，详见 <a href="https://www.consul.io/intro/vs/index.html" target="_blank" rel="noopener">consul vs other software</a>，有兴趣的可以看看，特别是有一句话，翻译成大白话就是：我不是针对在座的各位，我想说除我之外其它的都是渣渣（足见其相当的自信！）</p><p>OK，回归正题，这里我们来对比下四个常用的注册中心解决方案Consul、Zookeeper、Etcd、Eureka：  </p><h3 id="特性对比"><a href="#特性对比" class="headerlink" title="特性对比"></a>特性对比</h3><table><thead><tr><th>Feature</th><th>Consul</th><th>zookeeper</th><th>etcd</th><th>euerka</th></tr></thead><tbody><tr><td>服务健康检查</td><td>服务状态，内存，硬盘等</td><td>(弱)长连接，keepalive</td><td>连接心跳</td><td>可配支持</td></tr><tr><td>多数据中心</td><td>支持</td><td>—</td><td>—</td><td>—</td></tr><tr><td>kv存储服务</td><td>支持</td><td>支持</td><td>支持</td><td>—</td></tr><tr><td>一致性</td><td>raft</td><td>paxos</td><td>raft</td><td>—</td></tr><tr><td>cap</td><td>ca</td><td>cp</td><td>cp</td><td>ap</td></tr><tr><td>使用接口(多语言能力)</td><td>支持http和dns</td><td>客户端</td><td>http/grpc</td><td>http（sidecar）</td></tr><tr><td>watch支持</td><td>全量/支持long polling</td><td>支持</td><td>支持 long polling</td><td>支持 long polling/大部分增量</td></tr><tr><td>自身监控</td><td>metrics</td><td>—</td><td>metrics</td><td>metrics</td></tr><tr><td>安全</td><td>acl/https</td><td>acl</td><td>https支持（弱）</td><td>—</td></tr><tr><td>spring cloud集成</td><td>已支持</td><td>已支持</td><td>已支持</td><td>已支持</td></tr></tbody></table><ul><li><h4 id="服务的健康检查"><a href="#服务的健康检查" class="headerlink" title="服务的健康检查"></a>服务的健康检查</h4><p>Euraka 使用时需要显式配置健康检查支持；Zookeeper,Etcd 则在失去了和服务进程的连接情况下任务不健康，而 Consul 相对更为详细点，比如内存是否已使用了90%，文件系统的空间是不是快不足了。</p></li><li><h4 id="多数据中心支持"><a href="#多数据中心支持" class="headerlink" title="多数据中心支持"></a>多数据中心支持</h4><p>Consul 通过 WAN 的 Gossip 协议，完成跨数据中心的同步；而且其他的产品则需要额外的开发工作来实现；</p></li><li><h4 id="KV-存储服务"><a href="#KV-存储服务" class="headerlink" title="KV 存储服务"></a>KV 存储服务</h4><p>除了 Eureka ,其他几款都能够对外支持 k-v 的存储服务，所以后面会讲到这几款产品追求高一致性的重要原因。而提供存储服务，也能够较好的转化为动态配置服务哦。</p></li><li><h4 id="产品设计中-CAP-理论的取舍"><a href="#产品设计中-CAP-理论的取舍" class="headerlink" title="产品设计中 CAP 理论的取舍"></a>产品设计中 CAP 理论的取舍</h4><p>Eureka 典型的 AP,作为分布式场景下的服务发现的产品较为合适，服务发现场景的可用性优先级较高，一致性并不是特别致命。其次 CA 类型的场景 Consul,也能提供较高的可用性，并能 k-v store 服务保证一致性。 而Zookeeper,Etcd则是CP类型 牺牲可用性，在服务发现场景并没太大优势。  </p><p>Eureka提供了一个弱一致的服务视图，使用尽力而为复制。当客户端向服务器注册时，该服务器将尝试复制到其他服务器，但不提供保证。服务注册的生存时间（TTL）较短，要求客户端对服务器心存感激。不健康的服务或节点将停止心跳，导致它们超时并从注册表中删除。发现请求可以路由到任何服务，由于尽力而为的复制，这些服务可能会导致陈旧或丢失数据。这个简化的模型允许简单的群集管理和高可扩展性。  </p><p>Consul提供强大的一致性保证，因为服务器使用Raft协议复制状态（<a href="http://www.cnblogs.com/mindwind/p/5231986.html" target="_blank" rel="noopener">Raft 协议的易理解性描述</a>）。Consul支持丰富的健康检查，包括TCP，HTTP，Nagios / Sensu兼容脚本或基于Eureka的TTL。客户端节点参与基于八卦的健康检查，该检查分发健康检查工作，而不像集中式心跳检测那样成为可扩展性挑战。发现请求被路由到选举出来的领事领导，这使他们默认情况下强烈一致。允许陈旧读取的客户端使任何服务器都可以处理他们的请求，从而实现像Eureka这样的线性可伸缩性。Consul强烈的一致性意味着它可以作为领导选举和集群协调的锁定服务。Eureka不提供类似的保证，并且通常需要为需要执行协调或具有更强一致性需求的服务运行ZooKeeper.  </p></li><li><h4 id="多语言能力与对外提供服务的接入协议"><a href="#多语言能力与对外提供服务的接入协议" class="headerlink" title="多语言能力与对外提供服务的接入协议"></a>多语言能力与对外提供服务的接入协议</h4><p>Zookeeper的跨语言支持较弱，其他几款支持 http11 提供接入的可能。Euraka 一般通过 sidecar的方式提供多语言客户端的接入支持。Etcd 还提供了Grpc的支持。 Consul除了标准的Rest服务api,还提供了DNS的支持。</p></li><li><h4 id="Watch的支持（客户端观察到服务提供者变化）"><a href="#Watch的支持（客户端观察到服务提供者变化）" class="headerlink" title="Watch的支持（客户端观察到服务提供者变化）"></a>Watch的支持（客户端观察到服务提供者变化）</h4><p>Zookeeper 支持服务器端推送变化，Eureka 2.0(正在开发中)也计划支持。 Eureka 1,Consul,Etcd则都通过长轮询的方式来实现变化的感知；</p></li><li><h4 id="自身集群的监控"><a href="#自身集群的监控" class="headerlink" title="自身集群的监控"></a>自身集群的监控</h4><p>除了 Zookeeper ,其他几款都默认支持 metrics，运维者可以搜集并报警这些度量信息达到监控目的；</p></li><li><h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><p>Consul,Zookeeper 支持ACL，另外 Consul,Etcd 支持安全通道https.</p></li><li><h4 id="Spring-Cloud的集成"><a href="#Spring-Cloud的集成" class="headerlink" title="Spring Cloud的集成"></a>Spring Cloud的集成</h4><p>目前都有相对应的 boot starter，提供了集成能力。</p></li></ul>]]></content>
    
    <summary type="html">
    
      eureka官方已经正式宣布：自2.0起不再维护该项目，并在github 项目wiki上放出了一段吓唬人的话，大意就是：从2.x起，官方不会继续开发了，如果需要使用2.x，风险自负。
    
    </summary>
    
      <category term="Spring cloud" scheme="http://miclee.site/categories/Spring-cloud/"/>
    
    
      <category term="Spring cloud" scheme="http://miclee.site/tags/Spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>Web本地存储</title>
    <link href="http://miclee.site/2018/12/22/Web%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"/>
    <id>http://miclee.site/2018/12/22/Web本地存储/</id>
    <published>2018-12-22T12:39:12.000Z</published>
    <updated>2018-12-22T13:01:42.229Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> WEB 浏览器端本地存储的常规策略。 </em></strong><br><a id="more"></a></p><hr><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ul><li>cookie数据始终在同源的http请求中携带（即使不需要）</li><li>cookie数据存储大小限制为4K</li><li>在设置的cookie过期时间之前永远有效，即使窗口关闭或浏览器关闭</li><li>cookie在所有同源窗口中都是共享的  </li></ul><h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h2><ul><li>请求中不携带，与服务端无关</li><li>存储大小限制5M</li><li>始终有效，窗口或浏览器关闭也一直保存，除非手动删除，因此用作持久数据</li><li>localstorage在所有同源窗口中都是共享的  </li></ul><h2 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h2><ul><li>请求中不携带，与服务端无关</li><li>存储大小限制5M</li><li>浏览器窗口关闭后立刻销毁</li><li>sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面  </li></ul><h2 id="Web-SQL"><a href="#Web-SQL" class="headerlink" title="Web SQL"></a>Web SQL</h2><p>关系数据库，通过SQL语句访问<br>Web SQL 数据库 API 并不是 HTML5 规范的一部分，但是它是一个独立的规范，引入了一组使用 SQL 操作客户端数据库的 APIs。</p><p>浏览器支持：<br>Web SQL 数据库可以在最新版的 Safari, Chrome 和 Opera 浏览器中工作。  </p><h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><p>IndexedDB 是一种更复杂和全面地客户端数据存储方案，它是基于 JavaScript、面向对象的和数据库的，能非常容易地存储数据和检索已经建立关键字索引的数据。</p><p>IndexedDB 的优点：</p><ul><li>能够处理更复杂和结构化的数据</li><li>每个’database’中可以有多个’databases’和’tables’</li><li>更大的存储空间</li><li>对其有更多的交互控制  </li></ul><p>IndexedDB 的缺点</p><ul><li>比 Web Storage API 更难于应用  </li></ul><p>浏览器支持：<br>IE10+/Edge12+/Firefox 4+/Chrome 11+/Safari 7.1+/Opera 15+(caniuse)  </p><h2 id="离线缓存-application-cache"><a href="#离线缓存-application-cache" class="headerlink" title="离线缓存 application cache"></a>离线缓存 application cache</h2><p>应用程序缓存，是从浏览器的缓存中分出来的一块缓存区，要想在这个缓存中保存数据，可以使用一个描述文件（manifest file），列出要下载和缓存的资源。<br>application cache通过mainfest文件指定了缓存的资源，可以使我们的应用在断网的时候也能够使用。  </p><p>浏览器支持：<br>IE10+、Firefox3+、Safari4+、Opera10.6、Chrome、iOS3.2+、Android Webkit  </p><p>application cache的使用比较简单，只需要两步<br>1、服务器端需要维护一个manifest清单<br>2、Html标签用属性manifest引入文件即可</p>]]></content>
    
    <summary type="html">
    
      WEB 浏览器端本地存储的常规策略。
    
    </summary>
    
      <category term="Http" scheme="http://miclee.site/categories/Http/"/>
    
    
      <category term="Http" scheme="http://miclee.site/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>python 应用部署</title>
    <link href="http://miclee.site/2017/05/18/python-deploy/"/>
    <id>http://miclee.site/2017/05/18/python-deploy/</id>
    <published>2017-05-18T06:49:09.000Z</published>
    <updated>2017-05-20T08:56:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> flask 自带的服务器，能够完成了 web 服务的启动，但在生产环境下，无法满足性能要求。我们这里采用 gunicorn 做 wsgi容器，用来部署 python。 </em></strong><br><a id="more"></a></p><hr><p>web的部署，一般都是 nginx 做前端代理，中间 webservice 调用程序脚本。大概方式：nginx + webservice + script</p><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p>nginx，高性能的web服务器，通常用来在前端做反向代理服务器。<br>一个请求经过代理服务器从局域网发出，然后到达互联网上服务器，这个过程的代理为 <strong>正向代理</strong>。<br>如果一个请求，从互联网过来，先进入代理服务器，再由代理服务器转发给局域网的目标服务器，这个时候，代理服务器为 <strong>反向代理</strong>（相对正向而言）。</p><h2 id="webservice"><a href="#webservice" class="headerlink" title="webservice"></a>webservice</h2><p>webservice 也有很多方式。常见的有FastCGI，WSGI等。我们采用gunicorn为 wsgi容器，python为服务器script，采用flask框架。<br>最终的部署方式为：<br>nginx + gunicorn + flask</p><h2 id="gunicorn-使用"><a href="#gunicorn-使用" class="headerlink" title="gunicorn 使用"></a>gunicorn 使用</h2><ul><li><strong>安装</strong>  </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install gunicorn</span><br></pre></td></tr></table></figure><ul><li><strong>运行</strong>  </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunicorn -w4 -b0.0.0.0:8080 run:app</span><br></pre></td></tr></table></figure><p>-w 表示开启多少个 worker，-b 表示 gunicorn 开发的访问地址</p><p>为了在后台运行这个服务器（也即使它变成守护进程），可以传递-D选项给Gunicorn。这下它会持续运行，即使你关闭了当前的终端会话。</p><p>如果这么做了，当想要关闭服务器时就会困惑于到底应该关闭哪个进程。我们可以让Gunicorn把进程ID储存到文件中，这样如果想要停止或者重启服务器时，我们可以不用在一大串运行中的进程中搜索它。我们使用-p <file>选项来这么做。现在，我们的Gunicorn部署命令是这样：</file></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunicorn -w4 -b0.0.0.0:8080 run:app -p run.pid -D</span><br></pre></td></tr></table></figure><ul><li><strong>重启</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -HUP `cat run.pid` # 发送一个SIGHUP信号，终止进程</span><br></pre></td></tr></table></figure><ul><li><strong>关闭</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill `cat run.pid`</span><br></pre></td></tr></table></figure><ul><li><strong>访问地址的设置</strong><br>Gunicorn应该隐藏于反向代理之后。如果你直接让它监听来自外网的请求，它很容易成为拒绝服务攻击的目标。<br>只有在debug的情况下你才能把Gunicorn摆上前台，而且完工之后，切记把它重新隐藏到幕后。</li></ul><p>Gunicorn绑定在 127.0.0.1 上时，它仅仅监听来自服务器自身的连接。所以通常使用一个反向代理来作为外网和Gunicorn服务器的中介。<br>Gunicorn绑定在 0.0.0.0 上时，它就会监听所有请求，这样可以直接从外网发送请求给Gunicorn。debug的时候可以这么做。</p><h2 id="nginx的配置"><a href="#nginx的配置" class="headerlink" title="nginx的配置"></a>nginx的配置</h2><p>交给运维去管吧</p>]]></content>
    
    <summary type="html">
    
      flask 自带的服务器，能够完成了 web 服务的启动，但在生产环境下，无法满足性能要求。我们这里采用 gunicorn 做 wsgi容器，用来部署 python。
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>解决 ImportError cannot import name &#39;db&#39;</title>
    <link href="http://miclee.site/2017/05/17/ImportError/"/>
    <id>http://miclee.site/2017/05/17/ImportError/</id>
    <published>2017-05-17T03:19:14.000Z</published>
    <updated>2017-05-17T03:41:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 在使用 flask_sqlalchemy 的时候启动项目总是报错ImportError cannot import name 'db'，解决方案如此。 </em></strong><br><a id="more"></a></p><hr><h2 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "/Users/MicLee/WorkSpace/risk-model/pandora/pandora/__main__.py", line 28, in &lt;module&gt;</span><br><span class="line">    from pandora import get_app</span><br><span class="line">  File "/Users/MicLee/WorkSpace/risk-model/pandora/pandora/__init__.py", line 16, in &lt;module&gt;</span><br><span class="line">    import pandora.web.views</span><br><span class="line">  File "/Users/MicLee/WorkSpace/risk-model/pandora/pandora/web/views.py", line 8, in &lt;module&gt;</span><br><span class="line">    from pandora.dao import theta as ta</span><br><span class="line">  File "/Users/MicLee/WorkSpace/risk-model/pandora/pandora/dao/theta.py", line 8, in &lt;module&gt;</span><br><span class="line">    from pandora import db</span><br><span class="line">ImportError: cannot import name 'db'</span><br></pre></td></tr></table></figure><h2 id="错误相关项目结构"><a href="#错误相关项目结构" class="headerlink" title="错误相关项目结构"></a>错误相关项目结构</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pandora</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── __main__.py</span><br><span class="line">│   └── web</span><br><span class="line">│       ├── __init__.py</span><br><span class="line">│       └── views.py</span><br></pre></td></tr></table></figure><h2 id="错误相关代码"><a href="#错误相关代码" class="headerlink" title="错误相关代码"></a>错误相关代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">#</span><br><span class="line"># @Author  : MicLee</span><br><span class="line"># @Date    : 2017/4/5 17:55</span><br><span class="line"># @File    : __init__.py</span><br><span class="line"></span><br><span class="line">from flask import Flask</span><br><span class="line">from flask_sqlalchemy import SQLAlchemy</span><br><span class="line">from flask_cors import CORS, cross_origin</span><br><span class="line">from pandora import config</span><br><span class="line">import pandora.web.views</span><br><span class="line"></span><br><span class="line">__version__ = &quot;0.1&quot;</span><br><span class="line">__description__ = &quot;NFQ Risk Model.&quot;</span><br><span class="line"></span><br><span class="line">db = SQLAlchemy()</span><br><span class="line">_app = None</span><br><span class="line"></span><br><span class="line">def _create_app():</span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    app.config.from_object(config)</span><br><span class="line"></span><br><span class="line">    CORS(app)</span><br><span class="line">    db.init_app(app)</span><br><span class="line">    return app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_app():</span><br><span class="line">    global _app</span><br><span class="line">    if _app is None:</span><br><span class="line">        _app = _create_app()</span><br><span class="line">    return _app</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">#</span><br><span class="line"># @Author  : MicLee</span><br><span class="line"># @Date    : 2017/5/16 15:28</span><br><span class="line"># @File    : views.py</span><br><span class="line"></span><br><span class="line">from pandora import db</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>1、开始以为是import的路径错误，仔细研究了下python的import机制，并木有发现问题。<br>2、考虑到Python顺序执行的特点，在执行 “import pandora.web.views” 时加载views.py，执行“from pandora import db”，而“db = SQLAlchemy()”语句还没执行，db对象还没有被创建，所以发生ImportError!</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>将 “import pandora.web.views” 放到 <strong>init.py</strong> 的最后。</p>]]></content>
    
    <summary type="html">
    
      在使用 flask_sqlalchemy 的时候启动项目总是报错ImportError cannot import name &#39;db&#39;，解决方案如此。
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python字符串格式符</title>
    <link href="http://miclee.site/2017/05/16/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E7%AC%A6/"/>
    <id>http://miclee.site/2017/05/16/python字符串格式符/</id>
    <published>2017-05-16T06:28:00.000Z</published>
    <updated>2017-05-16T07:01:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 格式化字符串时，Python使用一个字符串作为模板。模板中有格式符，这些格式符为真实值预留位置，并说明真实数值应该呈现的格式。Python用一个 tuple 或者 字典 将多个值传递给模板，每个值对应一个格式符。 </em></strong><br><a id="more"></a></p><hr><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;I&apos;m %s. I&apos;m %d year old&quot; % (&apos;MicLee&apos;, 30))</span><br><span class="line"></span><br><span class="line">print(&quot;I&apos;m %(name)s. I&apos;m %(age)d year old&quot; % &#123;&apos;name&apos;:&apos;MicLee&apos;, &apos;age&apos;:30&#125;)</span><br></pre></td></tr></table></figure><h2 id="格式符"><a href="#格式符" class="headerlink" title="格式符"></a>格式符</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">%</span><span class="bash">s    字符串 (采用str()的显示)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">r    字符串 (采用repr()的显示)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">c    单个字符</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">b    二进制整数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">d    十进制整数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">i    十进制整数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">o    八进制整数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">x    十六进制整数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">e    指数 (基底写为e)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">E    指数 (基底写为E)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">f    浮点数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">F    浮点数，与上相同</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">g    指数(e)或浮点数 (根据显示长度)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">G    指数(E)或浮点数 (根据显示长度)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">%    字符<span class="string">"%"</span></span></span><br></pre></td></tr></table></figure><h2 id="高级格式符"><a href="#高级格式符" class="headerlink" title="高级格式符"></a>高级格式符</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[<span class="string">(name)</span>][<span class="symbol">flags</span>][<span class="string">width</span>].[precision]typecode</span><br></pre></td></tr></table></figure><p>(name)为命名</p><p>flags可以有+,-,’ ‘或0。+表示右对齐。-表示左对齐。’ ‘为一个空格，表示在正数的左侧填充一个空格，从而与负数对齐。0表示使用0填充。</p><p>width表示显示宽度</p><p>precision表示小数点后精度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&quot;%+10x&quot; % 10)</span><br><span class="line">        +a</span><br><span class="line">&gt;&gt;&gt; print(&quot;%04d&quot; % 5)</span><br><span class="line">0005</span><br><span class="line">&gt;&gt;&gt; print(&quot;%6.3f&quot; % 2.3)</span><br><span class="line"> 2.300</span><br></pre></td></tr></table></figure><p>上面的width, precision为两个整数。我们可以利用*，来动态代入这两个量。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&quot;%.*f&quot; % (4, 1.2))</span><br><span class="line">1.2000</span><br></pre></td></tr></table></figure><p>Python实际上用4来替换*，所以实际的模板为”%.4f”。</p><h2 id="r和-s的区别"><a href="#r和-s的区别" class="headerlink" title="%r和%s的区别"></a>%r和%s的区别</h2><p>%r用rper()方法处理对象<br>%s用str()方法处理对象</p><p>有些情况下，两者处理的结果是一样的，比如int型对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&quot;I&apos;m %s year old&quot; % 30)</span><br><span class="line">I&apos;m 30 year old</span><br><span class="line">&gt;&gt;&gt; print(&quot;I&apos;m %r year old&quot; % 30)</span><br><span class="line">I&apos;m 30 year old</span><br></pre></td></tr></table></figure></p><p>有些情况下是不一样的，比如str对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&quot;I&apos;m %s.&quot; % &apos;MicLee&apos;)</span><br><span class="line">I&apos;m MicLee.</span><br><span class="line">&gt;&gt;&gt; print(&quot;I&apos;m %r.&quot; % &apos;MicLee&apos;)</span><br><span class="line">I&apos;m &apos;MicLee&apos;.</span><br></pre></td></tr></table></figure></p><p>还有一种情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import datetime</span><br><span class="line">&gt;&gt;&gt; d = datetime.date.today()</span><br><span class="line">&gt;&gt;&gt; str(d)</span><br><span class="line">&apos;2011-05-14&apos;</span><br><span class="line">&gt;&gt;&gt; repr(d)</span><br><span class="line">&apos;datetime.date(2011, 5, 14)&apos;</span><br></pre></td></tr></table></figure></p><p>%r(也就是repr()方法)打印时能够重现它所代表的对象</p>]]></content>
    
    <summary type="html">
    
      格式化字符串时，Python使用一个字符串作为模板。模板中有格式符，这些格式符为真实值预留位置，并说明真实数值应该呈现的格式。Python用一个 tuple 或者 字典 将多个值传递给模板，每个值对应一个格式符。
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>SQLAlchemy</title>
    <link href="http://miclee.site/2017/05/16/SQLAlchemy/"/>
    <id>http://miclee.site/2017/05/16/SQLAlchemy/</id>
    <published>2017-05-16T06:10:26.000Z</published>
    <updated>2017-05-16T08:23:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 在上一章对比了Python几款ORM框架，决定在我的项目里使用SQLAlchemy，这里简单介绍下SQLAlchemy的使用。 </em></strong><br><a id="more"></a></p><hr><h2 id="一、单独使用SQLAlchemy"><a href="#一、单独使用SQLAlchemy" class="headerlink" title="一、单独使用SQLAlchemy"></a>一、单独使用SQLAlchemy</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1) 安装"></a>1) 安装</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">workon py3</span><br><span class="line">pip <span class="keyword">install</span> sqlalchemy</span><br></pre></td></tr></table></figure><h3 id="2-初始化DBSession"><a href="#2-初始化DBSession" class="headerlink" title="2) 初始化DBSession"></a>2) 初始化DBSession</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from sqlalchemy import Column, String, create_engine  </span><br><span class="line">from sqlalchemy.orm import sessionmaker  </span><br><span class="line">from sqlalchemy.ext.declarative import declarative_base  </span><br><span class="line"></span><br><span class="line"># 创建对象的基类:  </span><br><span class="line">Base = declarative_base()  </span><br><span class="line"></span><br><span class="line"># 定义User对象:  </span><br><span class="line">class User(Base):  </span><br><span class="line">    # 表的名字:  </span><br><span class="line">    __tablename__ = &apos;user&apos;  </span><br><span class="line"></span><br><span class="line">    # 表的结构:  </span><br><span class="line">    id = Column(String(20), primary_key=True)  </span><br><span class="line">    name = Column(String(20))  </span><br><span class="line"></span><br><span class="line"># 初始化数据库连接:  </span><br><span class="line"># &apos;数据库类型+数据库驱动名称://用户名:口令@机器地址:端口号/数据库名&apos;  </span><br><span class="line">engine = create_engine(&apos;mysql+mysqlconnector://root:root@localhost:3306/test&apos;)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 创建DBSession类型:  </span><br><span class="line">DBSession = sessionmaker(bind=engine)</span><br></pre></td></tr></table></figure><h3 id="3-添加一行记录"><a href="#3-添加一行记录" class="headerlink" title="3) 添加一行记录"></a>3) 添加一行记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 创建session对象:  </span><br><span class="line">session = DBSession()  </span><br><span class="line"># 创建新User对象:  </span><br><span class="line">new_user = User(id=&apos;5&apos;, name=&apos;Bob&apos;)  </span><br><span class="line"># 添加到session:  </span><br><span class="line">session.add(new_user)  </span><br><span class="line"># 提交即保存到数据库:  </span><br><span class="line">session.commit()  </span><br><span class="line"># 关闭session:  </span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure><h3 id="4-查询数据"><a href="#4-查询数据" class="headerlink" title="4) 查询数据"></a>4) 查询数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 创建Session:  </span><br><span class="line">session = DBSession()  </span><br><span class="line"># 创建Query查询，filter是where条件，最后调用one()返回唯一行，如果调用all()则返回所有行:  </span><br><span class="line">user = session.query(User).filter(User.id==&apos;5&apos;).one()  </span><br><span class="line"># 打印类型和对象的name属性:  </span><br><span class="line">print &apos;type:&apos;, type(user)  </span><br><span class="line">print &apos;name:&apos;, user.name  </span><br><span class="line"># 关闭Session:  </span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure><h3 id="5-创建一个一对多的关系"><a href="#5-创建一个一对多的关系" class="headerlink" title="5) 创建一个一对多的关系"></a>5) 创建一个一对多的关系</h3><p>一个人有多本书：当我们查询一个User对象时，该对象的books属性将返回一个包含若干个Book对象的list。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class User(Base):  </span><br><span class="line">    __tablename__ = &apos;user&apos;  </span><br><span class="line"></span><br><span class="line">    id = Column(String(20), primary_key=True)  </span><br><span class="line">    name = Column(String(20))  </span><br><span class="line">    # 一对多:  </span><br><span class="line">    books = relationship(&apos;Book&apos;)  </span><br><span class="line"></span><br><span class="line">class Book(Base):  </span><br><span class="line">    __tablename__ = &apos;book&apos;  </span><br><span class="line"></span><br><span class="line">    id = Column(String(20), primary_key=True)  </span><br><span class="line">    name = Column(String(20))  </span><br><span class="line">    # “多”的一方的book表是通过外键关联到user表的:  </span><br><span class="line">    user_id = Column(String(20), ForeignKey(&apos;user.id&apos;))</span><br></pre></td></tr></table></figure><h2 id="二、Flask-SQLAlchemy"><a href="#二、Flask-SQLAlchemy" class="headerlink" title="二、Flask-SQLAlchemy"></a>二、Flask-SQLAlchemy</h2><p>常见情况下对于只有一个 Flask 应用，所有您需要做的事情就是创建 Flask 应用，选择加载配置接着创建 SQLAlchemy 对象时候把 Flask 应用传递给它作为参数。</p><p>一旦创建，这个对象就包含 sqlalchemy 和 sqlalchemy.orm 中的所有函数和助手。此外它还提供一个名为 Model 的类，用于作为声明模型时的 delarative 基类:</p><h3 id="1）安装"><a href="#1）安装" class="headerlink" title="1）安装"></a>1）安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">workon py3</span><br><span class="line">pip install Flask-SQLAlchemy</span><br></pre></td></tr></table></figure><p>会附带安装 SQLAlchemy</p><h3 id="2）初始化"><a href="#2）初始化" class="headerlink" title="2）初始化"></a>2）初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># myapp.py</span><br><span class="line">from flask import Flask</span><br><span class="line">from flask.ext.sqlalchemy import SQLAlchemy</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[&apos;SQLALCHEMY_DATABASE_URI&apos;] = &apos;mysql://username:password@server/db&apos;</span><br><span class="line">db = SQLAlchemy(app)</span><br><span class="line"></span><br><span class="line"># 有一些部分在 SQLAlchemy 上是必选的，但是在 Flask-SQLAlchemy 上是可选的。 比如表名是自动地为您设置好的，除非您想要覆盖它。它是从转成小写的类名派生出来的，即 “CamelCase” 转换为 “camel_case”。</span><br><span class="line">class User(db.Model):</span><br><span class="line">    id = db.Column(db.Integer, primary_key=True)</span><br><span class="line">    username = db.Column(db.String(80), unique=True)</span><br><span class="line">    email = db.Column(db.String(120), unique=True)</span><br><span class="line"></span><br><span class="line">    def __init__(self, username, email):</span><br><span class="line">        self.username = username</span><br><span class="line">        self.email = email</span><br><span class="line"></span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &apos;&lt;User %r&gt;&apos; % self.username</span><br></pre></td></tr></table></figure><p><strong>常用类型：</strong></p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>Integer</td><td>一个整数</td></tr><tr><td>String(size)</td><td>有长度限制的字符串</td></tr><tr><td>Text</td><td>一些较长的 unicode 文本</td></tr><tr><td>DateTime</td><td>表示为 Python datetime 对象的 时间和日期</td></tr><tr><td>Float</td><td>存储浮点值</td></tr><tr><td>Boolean</td><td>存储布尔值</td></tr><tr><td>PickleType</td><td>存储为一个持久化的 Python 对象</td></tr><tr><td>LargeBinary</td><td>存储一个任意大的二进制数据</td></tr></tbody></table><h3 id="3）添加一行记录"><a href="#3）添加一行记录" class="headerlink" title="3）添加一行记录"></a>3）添加一行记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from myapp import User</span><br><span class="line"></span><br><span class="line">admin = User(&apos;admin&apos;, &apos;admin@example.com&apos;)</span><br><span class="line">guest = User(&apos;guest&apos;, &apos;guest@example.com&apos;)</span><br><span class="line"></span><br><span class="line">db.session.add(admin)</span><br><span class="line">db.session.add(guest)</span><br><span class="line">db.session.commit()</span><br><span class="line"># 没有必要在每个请求后关闭它(session)，Flask-SQLAlchemy 会帮您完成关闭操作。</span><br></pre></td></tr></table></figure><h3 id="4）查询记录"><a href="#4）查询记录" class="headerlink" title="4）查询记录"></a>4）查询记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from myapp import User</span><br><span class="line"></span><br><span class="line">users = User.query.all()</span><br><span class="line">print(users)</span><br><span class="line"># [&lt;User u&apos;admin&apos;&gt;, &lt;User u&apos;guest&apos;&gt;]</span><br><span class="line"></span><br><span class="line">admin = User.query.filter_by(username=&apos;admin&apos;).first()</span><br><span class="line">print(admin)</span><br><span class="line"># &lt;User u&apos;admin&apos;&gt;</span><br></pre></td></tr></table></figure><p><strong>更多用法参考：</strong> <a href="http://www.pythondoc.com/flask-sqlalchemy/quickstart.html#id2" target="_blank" rel="noopener">Flask-SQLAlchemy 快速入门</a></p>]]></content>
    
    <summary type="html">
    
      在上一章对比了Python几款ORM框架，决定在我的项目里使用SQLAlchemy，这里简单介绍下SQLAlchemy的使用。
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python ORM 框架对比</title>
    <link href="http://miclee.site/2017/05/16/python-orm/"/>
    <id>http://miclee.site/2017/05/16/python-orm/</id>
    <published>2017-05-16T05:52:19.000Z</published>
    <updated>2017-05-17T03:42:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> ORM技术 - Object-Relational Mapping, 把关系数据库的表结构映射到对象上。本篇对比Python几个流行的可选 ORM 库。 </em></strong><br><a id="more"></a></p><hr><h2 id="SQLObject"><a href="#SQLObject" class="headerlink" title="SQLObject"></a>SQLObject</h2><p><strong>优点：</strong>  </p><ul><li>采用了易懂的ActiveRecord 模式；  </li><li>一个相对较小的代码库；</li></ul><p><strong>缺点：</strong>  </p><ul><li>方法和类的命名遵循了Java 的小驼峰风格；  </li><li>不支持数据库session隔离工作单元；</li></ul><h2 id="Storm"><a href="#Storm" class="headerlink" title="Storm"></a>Storm</h2><p><strong>优点：</strong>  </p><ul><li>清爽轻量的API，短学习曲线和长期可维护性；  </li><li>不需要特殊的类构造函数，也没有必要的基类；</li></ul><p><strong>缺点：</strong>  </p><ul><li>迫使程序员手工写表格创建的DDL语句，而不是从模型类自动派生；  </li><li>Storm的贡献者必须把他们的贡献的版权给Canonical公司；  </li></ul><h2 id="Django’s-ORM"><a href="#Django’s-ORM" class="headerlink" title="Django’s ORM"></a>Django’s ORM</h2><p><strong>优点：</strong>  </p><ul><li>易用，学习曲线短；  </li><li>和Django紧密集合，用Django时使用约定俗成的方法去操作数据库；</li></ul><p><strong>缺点：</strong>  </p><ul><li>不好处理复杂的查询，强制开发者回到原生SQL;  </li><li>紧密和Django集成，使得在Django环境外很难使用;</li></ul><h2 id="peewee"><a href="#peewee" class="headerlink" title="peewee"></a>peewee</h2><p><strong>优点：</strong>  </p><ul><li>Django式的API，使其易用;  </li><li>轻量实现，很容易和任意web框架集成;</li></ul><p><strong>缺点：</strong>  </p><ul><li>不支持自动化 schema 迁移;  </li><li>多对多查询写起来不直观;</li></ul><h2 id="SQLAlchemy"><a href="#SQLAlchemy" class="headerlink" title="SQLAlchemy"></a>SQLAlchemy</h2><p><strong>优点：</strong>  </p><ul><li>企业级 API，使得代码有健壮性和适应性;  </li><li>灵活的设计，使得能轻松写复杂查询;</li></ul><p><strong>缺点：</strong>  </p><ul><li>工作单元概念不常;  </li><li>重量级 API，导致长学习曲线;</li></ul>]]></content>
    
    <summary type="html">
    
      ORM技术 - Object-Relational Mapping, 把关系数据库的表结构映射到对象上。本篇对比Python几个流行的可选 ORM 库。
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>RESTful API 设计指南【转】</title>
    <link href="http://miclee.site/2017/05/15/restful-api/"/>
    <id>http://miclee.site/2017/05/15/restful-api/</id>
    <published>2017-05-15T06:40:15.000Z</published>
    <updated>2017-05-15T06:55:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 网络应用程序，分为前端和后端两个部分。当前的发展趋势，就是前端设备层出不穷（手机、平板、桌面电脑、其他专用设备......）。因此，必须有一种统一的机制，方便不同的前端设备与后端进行通信。这导致API构架的流行，甚至出现"API First"的设计思想。RESTful API是目前比较成熟的一套互联网应用程序的API设计理论。 </em></strong><br><a id="more"></a></p><hr><p>我以前写过一篇《理解RESTful架构》，探讨如何理解这个概念。<br>今天，我将介绍RESTful API的设计细节，探讨如何设计一套合理、好用的API。我的主要参考了两篇文章（<a href="https://codeplanet.io/principles-good-restful-api-design/" target="_blank" rel="noopener">1</a>，<a href="https://bourgeois.me/rest/" target="_blank" rel="noopener">2</a>）。</p><h2 id="一、协议"><a href="#一、协议" class="headerlink" title="一、协议"></a>一、协议</h2><p>API与用户的通信协议，总是使用  <a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">HTTPs</a> 协议。  </p><h2 id="二、域名"><a href="#二、域名" class="headerlink" title="二、域名"></a>二、域名</h2><p>应该尽量将API部署在专用域名之下。<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span><span class="comment">//api.example.com</span></span><br></pre></td></tr></table></figure></p><p>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span>//example<span class="meta">.org</span>/api/</span><br></pre></td></tr></table></figure></p><h2 id="三、版本（Versioning）"><a href="#三、版本（Versioning）" class="headerlink" title="三、版本（Versioning）"></a>三、版本（Versioning）</h2><p>应该将API的版本号放入URL。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>api.example.com<span class="regexp">/v1/</span></span><br></pre></td></tr></table></figure><p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。</p><h2 id="四、路径（Endpoint）"><a href="#四、路径（Endpoint）" class="headerlink" title="四、路径（Endpoint）"></a>四、路径（Endpoint）</h2><p>路径又称”终点”（endpoint），表示API的具体网址。<br>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。<br>举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>api.example.com<span class="regexp">/v1/</span>zoos</span><br><span class="line">https:<span class="regexp">//</span>api.example.com<span class="regexp">/v1/</span>animals</span><br><span class="line">https:<span class="regexp">//</span>api.example.com<span class="regexp">/v1/</span>employees</span><br></pre></td></tr></table></figure><h2 id="五、HTTP动词"><a href="#五、HTTP动词" class="headerlink" title="五、HTTP动词"></a>五、HTTP动词</h2><p>对于资源的具体操作类型，由HTTP动词表示。<br>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET（<span class="keyword">SELECT</span>）：从服务器取出资源（一项或多项）。</span><br><span class="line">POST（<span class="keyword">CREATE</span>）：在服务器新建一个资源。</span><br><span class="line">PUT（<span class="keyword">UPDATE</span>）：在服务器更新资源（客户端提供改变后的完整资源）。</span><br><span class="line"><span class="keyword">PATCH</span>（<span class="keyword">UPDATE</span>）：在服务器更新资源（客户端提供改变的属性）。</span><br><span class="line"><span class="keyword">DELETE</span>（<span class="keyword">DELETE</span>）：从服务器删除资源。</span><br></pre></td></tr></table></figure><p>还有两个不常用的HTTP动词。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HEAD：获取资源的元数据。</span><br><span class="line">OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</span><br><span class="line">下面是一些例子。</span><br><span class="line">GET <span class="string">/zoos</span>：列出所有动物园</span><br><span class="line">POST <span class="string">/zoos</span>：新建一个动物园</span><br><span class="line">GET <span class="string">/zoos/ID</span>：获取某个指定动物园的信息</span><br><span class="line">PUT <span class="string">/zoos/ID</span>：更新某个指定动物园的信息（提供该动物园的全部信息）</span><br><span class="line">PATCH <span class="string">/zoos/ID</span>：更新某个指定动物园的信息（提供该动物园的部分信息）</span><br><span class="line">DELETE <span class="string">/zoos/ID</span>：删除某个动物园</span><br><span class="line">GET <span class="string">/zoos/ID/animals</span>：列出某个指定动物园的所有动物</span><br><span class="line">DELETE <span class="string">/zoos/ID/animals/ID</span>：删除某个指定动物园的指定动物</span><br></pre></td></tr></table></figure><h2 id="六、过滤信息（Filtering）"><a href="#六、过滤信息（Filtering）" class="headerlink" title="六、过滤信息（Filtering）"></a>六、过滤信息（Filtering）</h2><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。<br>下面是一些常见的参数。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?<span class="attribute">limit</span>=10：指定返回记录的数量</span><br><span class="line">?<span class="attribute">offset</span>=10：指定返回记录的开始位置。</span><br><span class="line">?<span class="attribute">page</span>=2&amp;per_page=100：指定第几页，以及每页的记录数。</span><br><span class="line">?<span class="attribute">sortby</span>=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</span><br><span class="line">?<span class="attribute">animal_type_id</span>=1：指定筛选条件</span><br></pre></td></tr></table></figure><p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p><h2 id="七、状态码（Status-Codes）"><a href="#七、状态码（Status-Codes）" class="headerlink" title="七、状态码（Status Codes）"></a>七、状态码（Status Codes）</h2><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">200 </span>OK - [<span class="keyword">GET</span>]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</span><br><span class="line"><span class="symbol">201 </span>CREATED - [POST/<span class="keyword">PUT</span>/PATCH]：用户新建或修改数据成功。</span><br><span class="line"><span class="symbol">202 </span>Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</span><br><span class="line"><span class="symbol">204 </span>NO CONTENT - [<span class="keyword">DELETE</span>]：用户删除数据成功。</span><br><span class="line"><span class="symbol">400 </span>INVALID REQUEST - [POST/<span class="keyword">PUT</span>/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</span><br><span class="line"><span class="symbol">401 </span>Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</span><br><span class="line"><span class="symbol">403 </span>Forbidden - [*] 表示用户得到授权（与<span class="number">401</span>错误相对），但是访问是被禁止的。</span><br><span class="line"><span class="symbol">404 </span><span class="keyword">NOT</span> FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</span><br><span class="line"><span class="symbol">406 </span><span class="keyword">Not</span> Acceptable - [<span class="keyword">GET</span>]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</span><br><span class="line"><span class="symbol">410 </span>Gone -[<span class="keyword">GET</span>]：用户请求的资源被永久删除，且不会再得到的。</span><br><span class="line"><span class="symbol">422 </span>Unprocesable entity - [POST/<span class="keyword">PUT</span>/PATCH] 当创建一个对象时，发生一个验证错误。</span><br><span class="line"><span class="symbol">500 </span>INTERNAL SERVER <span class="keyword">ERROR</span> - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</span><br></pre></td></tr></table></figure><p>状态码的完全列表参见<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html" target="_blank" rel="noopener">这里</a>。</p><h2 id="八、错误处理（Error-handling）"><a href="#八、错误处理（Error-handling）" class="headerlink" title="八、错误处理（Error handling）"></a>八、错误处理（Error handling）</h2><p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">error</span>: <span class="string">"Invalid API key"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="九、返回结果"><a href="#九、返回结果" class="headerlink" title="九、返回结果"></a>九、返回结果</h2><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET <span class="string">/collection</span>：返回资源对象的列表（数组）</span><br><span class="line">GET <span class="string">/collection/resource</span>：返回单个资源对象</span><br><span class="line">POST <span class="string">/collection</span>：返回新生成的资源对象</span><br><span class="line">PUT <span class="string">/collection/resource</span>：返回完整的资源对象</span><br><span class="line">PATCH <span class="string">/collection/resource</span>：返回完整的资源对象</span><br><span class="line">DELETE <span class="string">/collection/resource</span>：返回一个空文档</span><br></pre></td></tr></table></figure><h2 id="十、Hypermedia-API"><a href="#十、Hypermedia-API" class="headerlink" title="十、Hypermedia API"></a>十、Hypermedia API</h2><p>RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。<br>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"link"</span>: &#123;</span><br><span class="line">  <span class="attr">"rel"</span>:   <span class="string">"collection https://www.example.com/zoos"</span>,</span><br><span class="line">  <span class="attr">"href"</span>:  <span class="string">"https://api.example.com/zoos"</span>,</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"List of zoos"</span>,</span><br><span class="line">  <span class="attr">"type"</span>:  <span class="string">"application/vnd.yourformat+json"</span></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。<br>Hypermedia API的设计被称为HATEOAS。Github的API就是这种设计，访问api.github.com会得到一个所有可用API的网址列表。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"current_user_url"</span>: <span class="string">"https://api.github.com/user"</span>,</span><br><span class="line">  <span class="string">"authorizations_url"</span>: <span class="string">"https://api.github.com/authorizations"</span>,</span><br><span class="line">  <span class="string">//</span> <span class="string">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看到，如果想获取当前用户的信息，应该去访问api.github.com/user，然后就得到了下面结果。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"message"</span>: <span class="string">"Requires authentication"</span>,</span><br><span class="line">  <span class="attr">"documentation_url"</span>: <span class="string">"https://developer.github.com/v3"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码表示，服务器给出了提示信息，以及文档的网址。</p><h2 id="十一、其他"><a href="#十一、其他" class="headerlink" title="十一、其他"></a>十一、其他</h2><p>（1）API的身份认证应该使用OAuth 2.0框架。<br>（2）服务器返回的数据格式，应该尽量使用JSON，避免使用XML。</p><hr><p><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">【原文链接】</a></p>]]></content>
    
    <summary type="html">
    
      网络应用程序，分为前端和后端两个部分。当前的发展趋势，就是前端设备层出不穷（手机、平板、桌面电脑、其他专用设备......）。因此，必须有一种统一的机制，方便不同的前端设备与后端进行通信。这导致API构架的流行，甚至出现&quot;API First&quot;的设计思想。RESTful API是目前比较成熟的一套互联网应用程序的API设计理论。
    
    </summary>
    
      <category term="Http" scheme="http://miclee.site/categories/Http/"/>
    
    
      <category term="Http" scheme="http://miclee.site/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>Python Web 框架一览</title>
    <link href="http://miclee.site/2017/05/15/Python-Web%E6%A1%86%E6%9E%B6%E4%B8%80%E8%A7%88/"/>
    <id>http://miclee.site/2017/05/15/Python-Web框架一览/</id>
    <published>2017-05-15T03:03:05.000Z</published>
    <updated>2017-05-15T05:39:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> Python 有许多 web 框架可以供你选择。网上甚至还有教你怎么制作自己专属的框架的教程，因为这实在是太容易了。然后就导致了现在框架的质量参差不齐。我们来对这些框架做一个概述然后你可以挑出自己喜欢的。 </em></strong><br><a id="more"></a></p><hr><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们经常谈到的 python web 框架有这些：</p><table><thead><tr><th>名字</th><th>版本</th><th>最后更新</th><th>诞生时间</th><th>代码行数</th></tr></thead><tbody><tr><td>Django</td><td>1.3.1</td><td>2011-09-09</td><td>2005</td><td>115759</td></tr><tr><td>Flask</td><td>0.8</td><td>2011-09-29</td><td>2010</td><td>4681</td></tr><tr><td>Bottle</td><td>0.10.9</td><td>2012-02-11</td><td>2009</td><td>4634</td></tr><tr><td>Tornado</td><td>2.2</td><td>2012-01-30</td><td>2009</td><td>11701</td></tr><tr><td>Cherry.py</td><td>3.2.2</td><td>2011-10-19</td><td>2002</td><td>18828</td></tr><tr><td>web.py</td><td>0.36</td><td>2011-07-04</td><td>2006</td><td>7398</td></tr><tr><td>Brubeck</td><td>0.3.7</td><td>2011-12-20</td><td>011</td><td>1525</td></tr></tbody></table><p>注释1：加上 Brubeck 是因为我认为我们可以从这个框架身上学到很多，虽然这个框架已经不是 Python 框架了。</p><p>注释2：还有许多其他的框架比如说 Zope， Pylons， Pyramid － 我之所以没有写它们是因为我对它们没有经验。</p><p>注释3：如果 Flask 的代码加上 Werkzeug 和 Jinja2 的话一共约 35000 行。</p><p>注释4：代码行数意思是实际的 Python 代码。使用 CLOC 计数。</p><h2 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h2><p>这可能是最广为人知和使用最广泛的 Python web 框架了。我承认它确实非常强大。Django 有世界上最大的社区，最多的包，可以说只有你想不到的，没有它做不到的。它的文档非常完善，但是有的比较冷门的知识你还是需要去 StackOverflow 咨询一下。</p><p>Django 在配置上面遵循惯例，这样对于初学者来说比较容易，而且在比较复杂的应用上也有一定的灵活性。Django 致力于快速开发以及简洁实用的设计。</p><p>Django 只需要这么 几行代码 就可以实现一个“Hello World！”程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">from django.conf.urls.defaults import patterns</span><br><span class="line">from django.http import HttpResponse</span><br><span class="line">filepath, extension = os.path.splitext(__file__)</span><br><span class="line">ROOT_URLCONF = os.path.basename(filepath)</span><br><span class="line"></span><br><span class="line">def hello(request):</span><br><span class="line">    return HttpResponse(&apos;Hello World!&apos;)</span><br><span class="line"></span><br><span class="line">urlpatterns = patterns(&apos;&apos;, (r&apos;^/$&apos;, hello))</span><br></pre></td></tr></table></figure></p><p>关于 Django 我不喜欢的一点就是它有点儿被焊死的感觉。不要尝试着去改变它，否则你会碰壁的。我来解释一下这个说法：比如说我想要使用 SQLAlchemy 作为 ORM 然后 SQLAlchemy 就会把 Admin， Auth， Form 等等几乎所有的部分都给搞砸。所以你最好使用它附带的工具包。</p><p>快速教程： <a href="https://www.djangoproject.com/" target="_blank" rel="noopener">Django</a></p><p>它们都基于 Django： Disqus ， EveryBlock ， Guardian (newspaper) ， Firefox add-ons (Mozilla)</p><h2 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h2><p>这个灵巧的框架是由 Armin Ronacher 创造的。它的名字暗示了它的含义，它基本上就是一个微型的胶水框架。它把 Werkzeug 和 Jinja 粘合在了一起。所以它很容易被扩展。</p><p>Flask 也有许多的 扩展 可以供你使用，Flask 也有一群忠诚的粉丝和不断增加的用户群。它有一份很完善的文档，甚至还有一份唾手可得的常见范例。Flask 很容易使用，你只需要 3(7) 行代码就可以写出来一个 Hello World。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;)</span><br><span class="line">def hello():</span><br><span class="line">    return &quot;Hello World!&quot;</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure></p><p>我觉得这是它最大的优点也是缺点 － Flask 并不强制一个特定的 ORM。这会使得写扩展有点儿困难，你可能会想用某种形式的数据库层，但是用哪一个呢？Python 有非常多可以选择的。这个 Blog 是用 Flask 写的，部署在 Google App Engine 上。这很容易因为 Google Datastore 和其他的不太一样。所以有时候不强制一个 ORM 也是好事儿。</p><p>如果你想建一个新站的话 Flask 是个非常不错的选择。但我并不会向所有的初学者都推荐 Flask，我指的是那些不关心“为什么可以”，只关心它们“可不可以”的初学者。</p><p>快速教程： <a href="http://flask.pocoo.org/docs/0.12/quickstart/" target="_blank" rel="noopener">Flask quickstart</a></p><p>它们都基于 Flask： Dev news aggregator for Battlefield3 ， Media Queries ， Learn buffet ， Konstruktor (appengine)</p><h2 id="Bottle"><a href="#Bottle" class="headerlink" title="Bottle"></a>Bottle</h2><p>这个框架相对来说比较新。它受到了 Sinatra 的影响。Bottle 才是名副其实的微框架 － 它只有大约 4500 行代码。并且我认为这是最真实的基于 Python 的微框架，它除了 Python 标准库以外没有任何其它的依赖，甚至它还有自己独特的一点儿模版语言。Bottle 还是为数不多的支持 Python 3 的框架之一。</p><p>Bottle 的文档很详细并且抓住了事物的实质。Hello World 例子很像 Flask，也使用了装饰器来定义路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from bottle import route, run</span><br><span class="line"></span><br><span class="line">@route(&apos;/hello/:name&apos;)</span><br><span class="line">def hello(name):</span><br><span class="line">    return &apos;&lt;h1&gt;Hello %s!&lt;/h1&gt;&apos; % name.title()</span><br><span class="line"></span><br><span class="line">run(host=&apos;localhost&apos;, port=8080)</span><br></pre></td></tr></table></figure><p>我知道 Bottle 内部有一座桥梁来沟通各个部分，因为它只有一个文件。但是很难找到你想要的东西，它的代码散布的到处都是，看起来一团糟。</p><p>对于非常小的项目或者是实验性的项目来说，Bottle 是一个不错的选择。但是对于一些大型的项目来说最好就不要使用它了，因为它的扩展并不多。</p><p>快速教程： <a href="http://bottlepy.org/docs/dev/tutorial.html" target="_blank" rel="noopener">Bottle tutorial</a></p><p>它们都基于 Bottle： Plush (monitoring) ， Hobo (Blog enginee)</p><h2 id="web-py"><a href="#web-py" class="headerlink" title="web.py"></a>web.py</h2><p>以前 web.py 还很流行的时候被用来写 reddit。它能很好的处理流量问题。如果你用 web.py 开发 web 应用的话，你会发现它并不会阻碍你。 标准配置 很简单也很直观。web.py 在文件和文件夹的分类上面也做的非常棒。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import web</span><br><span class="line"></span><br><span class="line">urls = (&apos;/(.*)&apos;, &apos;hello&apos;)</span><br><span class="line">app = web.application(urls, globals())</span><br><span class="line"></span><br><span class="line">class hello:</span><br><span class="line">    def GET(self):</span><br><span class="line">        return &apos;Hello, World!&apos;</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure></p><p>很遗憾的是这个库最近已经成为了 rails 框架狂热者的受害者。它有可以帮你做几乎所有事情的自己的库 － 模版，表格，数据库。可能它们并不像其它库一样得到了良好的维护，但是还是有许多人在用它。</p><p>快速教程： <a href="http://webpy.org/" target="_blank" rel="noopener">web.py</a></p><p>它们基于 web.py： Yandex (russian search engine) ， Telephone directory (Switzerland)</p><h2 id="Tornado"><a href="#Tornado" class="headerlink" title="Tornado"></a>Tornado</h2><p>Tornado 不单单是个框架，还是个 web 服务器。它一开始是给 FriendFeed 开发的，后来在 2009 年的时候也给 Facebook 使用。它是为了解决实时服务而诞生的。为了做到这一点，Tornado 使用了异步非阻塞 IO。</p><p>Tornado 的文档非常技术性。它并不是为初学者准备的。这是一个 Hello World 程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import tornado.ioloop</span><br><span class="line">import tornado.web</span><br><span class="line"></span><br><span class="line">class MainHandler(tornado.web.RequestHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        self.write(&quot;Hello, world&quot;)</span><br><span class="line"></span><br><span class="line">application = tornado.web.Application([</span><br><span class="line">    (r&quot;/&quot;, MainHandler),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    application.listen(8888)</span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br></pre></td></tr></table></figure></p><p>默认情况下 Tornado 会传递 WSGI 层，因为 WSGI 并不能处理异步请求。Tornado 确实性能非常强，但是当调用数据库的时候它会阻塞 IO。</p><p>快速教程： <a href="http://www.tornadoweb.org/en/stable/" target="_blank" rel="noopener">Tornado</a></p><p>它们基于 Tornado： Too cool for me ， FriendFeed</p><h2 id="CherryPy"><a href="#CherryPy" class="headerlink" title="CherryPy"></a>CherryPy</h2><p>这是最古老的 Python 框架的一种。CherryPy 并没有得到广泛的应用，大家提到它第一反应是 web 服务器然后才是一个框架。在处理请求方面 CherryPy 也使用了队列来优化性能，但是它使用的是 线程池 技术。</p><p>CherryPy 的文档实际上非常少，但是基本上都可以涵盖主要的方面。CherryPy 也可以支持 Python 3。我必须说，它的 Hello World 例子非常漂亮：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import cherrypy</span><br><span class="line">class HelloWorld(object):</span><br><span class="line">    def index(self):</span><br><span class="line">    return &quot;Hello World!&quot;</span><br><span class="line">    index.exposed = True</span><br><span class="line"></span><br><span class="line">cherrypy.quickstart(HelloWorld())</span><br></pre></td></tr></table></figure></p><p>快速教程： <a href="http://docs.cherrypy.org/en/latest/" target="_blank" rel="noopener">CherryPy</a></p><p>它们基于 CherryPy： YouGov ， Cuil search engine (ended 2010)</p><h2 id="Brubeck"><a href="#Brubeck" class="headerlink" title="Brubeck"></a>Brubeck</h2><p>这是一个新的 Python 框架。其并不使用 WSGI 而直接在语言级别用 Mongrel2 作为服务器使用，这个仅把请求处理交给 Python 程序，请求作为协同程序来处理。</p><p>模块方面 Brubeck 使用了 DictShield 库，意思就是对于不同的数据库插件都可以在其之上来进行操作。</p><p>Brubeck 的文档非常少，但是你看到源码以后，你会知道其实并没有多少东西。所以它还是一个非常年轻并且在不断发展的框架。Hello World 例子看起来也很漂亮。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class DemoHandler(WebMessageHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        self.set_body(&apos;Hello world&apos;)</span><br><span class="line">        return self.render()</span><br><span class="line"></span><br><span class="line">urls = [(r&apos;^/&apos;, DemoHandler)]</span><br><span class="line">mongrel2_pair = (&apos;ipc://127.0.0.1:9999&apos;, &apos;ipc://127.0.0.1:9998&apos;)</span><br><span class="line"></span><br><span class="line">app = Brubeck(mongrel2_pair=mongrel2_pair,</span><br><span class="line">          handler_tuples=urls)</span><br><span class="line">app.run()</span><br></pre></td></tr></table></figure></p><p>唯一需要注意的是当你使用 Brubeck 的时候你也需要看看 Mongrel2 服务器的相关知识。</p><p>快速教程： <a href="http://brubeck.io/" target="_blank" rel="noopener">Brubeck.io</a></p><p>它们基于 Brubeck： ListSurf</p>]]></content>
    
    <summary type="html">
    
      Python 有许多 web 框架可以供你选择。网上甚至还有教你怎么制作自己专属的框架的教程，因为这实在是太容易了。然后就导致了现在框架的质量参差不齐。我们来对这些框架做一个概述然后你可以挑出自己喜欢的。
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>人生苦短，我用Python【转】</title>
    <link href="http://miclee.site/2017/05/12/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8C%E6%88%91%E7%94%A8Python/"/>
    <id>http://miclee.site/2017/05/12/人生苦短，我用Python/</id>
    <published>2017-05-12T09:28:26.000Z</published>
    <updated>2017-05-15T05:38:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> Python语言的发展简史。 </em></strong><br><a id="more"></a></p><hr><p>Python是我喜欢的语言，简洁，优美，容易使用。前两天，我很激昂的向朋友宣传Python的好处。</p><p>“好吧，我承认Python不错，但它为什么叫Python呢？”<br>“呃，似乎是一个电视剧的名字。”<br>“那你说的Guido是美国人么？”<br>“他从Google换到Dropbox工作，但他的名字像是荷兰人的。”<br>“你确定你很熟悉Python吗？”</p><p>所以为了雪耻，我花时间调查了Python的历史。我看到了Python中许多功能的来源和Python的设计理念，看到了一门编程语言的演化历史，看到了Python与开源运动的奇妙联系。从Python的历史中，我们可以一窥开源开发的理念和成就。</p><p>这也可以作为我写的Python快速教程的序篇。</p><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>Python的作者，Guido von Rossum，确实是荷兰人。1982年，Guido从阿姆斯特丹大学获得了数学和计算机硕士学位。然而，尽管他算得上是一位数学家，但他更加享受计算机带来的乐趣。用他的话说，尽管拥有数学和计算机双料资质，他总趋向于做计算机相关的工作，并热衷于做任何和编程相关的活儿。</p><p>在那个时候，Guido接触并使用过诸如Pascal、C、 Fortran等语言。这些语言的基本设计原则是让机器能更快运行。在80年代，虽然IBM和苹果已经掀起了个人电脑浪潮，但这些个人电脑的配置很低。比如早期的Macintosh，只有8MHz的CPU主频和128KB的RAM，一个大的数组就能占满内存。所有的编译器的核心是做优化，以便让程序能够运行。为了增进效率，语言也迫使程序员像计算机一样思考，以便能写出更符合机器口味的程序。在那个时代，程序员恨不得用手榨取计算机每一寸的能力。有人甚至认为C语言的指针是在浪费内存。至于动态类型，内存自动管理，面向对象…… 别想了，那会让你的电脑陷入瘫痪。</p><p>这种编程方式让Guido感到苦恼。Guido知道如何用C语言写出一个功能，但整个编写过程需要耗费大量的时间，即使他已经准确的知道了如何实现。他的另一个选择是shell。Bourne Shell作为UNIX系统的解释器已经长期存在。UNIX的管理员们常常用shell去写一些简单的脚本，以进行一些系统维护的工作，比如定期备份、文件系统管理等等。shell可以像胶水一样，将UNIX下的许多功能连接在一起。许多C语言下上百行的程序，在shell下只用几行就可以完成。然而，shell的本质是调用命令。它并不是一个真正的语言。比如说，shell没有数值型的数据类型，加法运算都很复杂。总之，shell不能全面的调动计算机的功能。</p><p>Guido希望有一种语言，这种语言能够像C语言那样，能够全面调用计算机的功能接口，又可以像shell那样，可以轻松的编程。ABC语言让Guido看到希望。ABC是由荷兰的数学和计算机研究所开发的。Guido在该研究所工作，并参与到ABC语言的开发。ABC语言以教学为目的。与当时的大部分语言不同，ABC语言的目标是“让用户感觉更好”。ABC语言希望让语言变得容易阅读，容易使用，容易记忆，容易学习，并以此来激发人们学习编程的兴趣。比如下面是一段来自Wikipedia的ABC程序，这个程序用于统计文本中出现的词的总数：  </p><pre><code>HOW TO RETURN words document:    PUT {} IN collection    FOR line IN document:        FOR word IN split line:        IF word not.in collection:            INSERT word IN collection    RETURN collection</code></pre><p>HOW TO用于定义一个函数。一个Python程序员应该很容易理解这段程序。ABC语言使用冒号和缩进来表示程序块。行尾没有分号。for和if结构中也没有括号()。赋值采用的是PUT，而不是更常见的等号。这些改动让ABC程序读起来像一段文字。</p><p>尽管已经具备了良好的可读性和易用性，ABC语言最终没有流行起来。在当时，ABC语言编译器需要比较高配置的电脑才能运行。而这些电脑的使用者通常精通计算机，他们更多考虑程序的效率，而非它的学习难度。除了硬件上的困难外，ABC语言的设计也存在一些致命的问题：</p><ul><li><p>可拓展性差。ABC语言不是模块化语言。如果想在ABC语言中增加功能，比如对图形化的支持，就必须改动很多地方。</p></li><li><p>不能直接进行IO。ABC语言不能直接操作文件系统。尽管你可以通过诸如文本流的方式导入数据，但ABC无法直接读写文件。输入输出的困难对于计算机语言来说是致命的。你能想像一个打不开车门的跑车么？</p></li><li><p>过度革新。ABC用自然语言的方式来表达程序的意义，比如上面程序中的HOW TO 。然而对于程序员来说，他们更习惯用function或者define来定义一个函数。同样，程序员更习惯用等号来分配变量。尽管ABC语言很特别，但学习难度也很大。</p></li><li><p>传播困难。ABC编译器很大，必须被保存在磁带上。当时Guido在访问的时候，就必须有一个大磁带来给别人安装ABC编译器。 这样，ABC语言就很难快速传播。</p></li></ul><p>1989年，为了打发圣诞节假期，Guido开始写Python语言的编译器。Python这个名字，来自Guido所挚爱的电视剧Monty Python’s Flying Circus。他希望这个新的叫做Python的语言，能符合他的理想：创造一种C和shell之间，功能全面，易学易用，可拓展的语言。Guido作为一个语言设计爱好者，已经有过设计语言的尝试。这一次，也不过是一次纯粹的hacking行为。</p><h2 id="一门语言的诞生"><a href="#一门语言的诞生" class="headerlink" title="一门语言的诞生"></a>一门语言的诞生</h2><p>1991年，第一个Python编译器诞生。它是用C语言实现的，并能够调用C语言的库文件。从一出生，Python已经具有了：类，函数，异常处理，包含表和词典在内的核心数据类型，以及模块为基础的拓展系统。</p><p>Python语法很多来自C，但又受到ABC语言的强烈影响。来自ABC语言的一些规定直到今天还富有争议，比如强制缩进。但这些语法规定让Python容易读。另一方面，Python聪明的选择服从一些惯例，特别是C语言的惯例。比如使用等号赋值，使用def来定义函数。Guido认为，如果“常识”上确立的东西，没有必要过度纠结。</p><p>Python从一开始就特别在意可拓展性。Python可以在多个层次上拓展。从高层上，你可以直接引入.py文件。在底层，你可以引用C语言的库。Python程序员可以快速的使用Python写.py文件作为拓展模块。但当性能是考虑的重要因素时，Python程序员可以深入底层，写C程序，编译为.so文件引入到Python中使用。Python就好像是使用钢构建房一样，先规定好大的框架。而程序员可以在此框架下相当自由的拓展或更改。</p><p>最初的Python完全由Guido本人开发。Python得到Guido同事的欢迎。他们迅速的反馈使用意见，并参与到Python的改进。Guido和一些同事构成Python的核心团队。他们将自己大部分的业余时间用于hack Python。随后，Python拓展到研究所之外。Python将许多机器层面上的细节隐藏，交给编译器处理，并凸显出逻辑层面的编程思考。Python程序员可以花更多的时间用于思考程序的逻辑，而不是具体的实现细节。这一特征吸引了广大的程序员。Python开始流行。<br>人生苦短，我用python</p><p><img src="https://raw.githubusercontent.com/OfMicLee/img-hosting/master/python/001.jpg" alt=""></p><h2 id="时势造英雄"><a href="#时势造英雄" class="headerlink" title="时势造英雄"></a>时势造英雄</h2><p>我们不得不暂停我们的Python时间，转而看一看瞬息万变的计算机行业。1990年代初，个人计算机开始进入普通家庭。Intel发布了486处理器，windows发布window 3.0开始的一系列视窗系统。计算机的性能大大提高。程序员开始关注计算机的易用性  ，比如图形化界面。</p><p><img src="https://raw.githubusercontent.com/OfMicLee/img-hosting/master/python/002.png" alt=""></p><p>由于计算机性能的提高，软件的世界也开始随之改变。硬件足以满足许多个人电脑的需要。硬件厂商甚至渴望高需求软件的出现，以带动硬件的更新换代。C++和Java相继流行。C++和Java提供了面向对象的编程范式，以及丰富的对象库。在牺牲了一定的性能的代价下，C++和Java大大提高了程序的产量。语言的易用性被提到一个新的高度。我们还记得，ABC失败的一个重要原因是硬件的性能限制。从这方面说，Python要比ABC幸运许多。</p><p>另一个悄然发生的改变是Internet。1990年代还是个人电脑的时代，windows和Intel挟PC以令天下，盛极一时。尽管Internet为主体的信息革命尚未到来，但许多程序员以及资深计算机用户已经在频繁使用Internet进行交流，比如使用email和newsgroup。Internet让信息交流成本大大下降。一种新的软件开发模式开始流行：开源。程序员利用业余时间进行软件开发，并开放源代码。1991年，Linus在comp.os.minix新闻组上发布了Linux内核源代码，吸引大批hacker的加入。Linux和GNU相互合作，最终构成了一个充满活力的开源平台。</p><p>硬件性能不是瓶颈，Python又容易使用，所以许多人开始转向Python。Guido维护了一个maillist，Python用户就通过邮件进行交流。Python用户来自许多领域，有不同的背景，对Python也有不同的需求。Python相当的开放，又容易拓展，所以当用户不满足于现有功能，很容易对Python进行拓展或改造。随后，这些用户将改动发给Guido，并由Guido决定是否将新的特征加入到Python或者标准库中。如果代码能被纳入Python自身或者标准库，这将极大的荣誉。由于Guido至高无上的决定权，他因此被称为“终身的仁慈独裁者”。</p><p>Python被称为“Battery Included”，是说它以及其标准库的功能强大。这些是整个社区的贡献。Python的开发者来自不同领域，他们将不同领域的优点带给Python。比如Python标准库中的正则表达是参考Perl，而lambda, map, filter, reduce等函数参考了Lisp。Python本身的一些功能以及大部分的标准库来自于社区。Python的社区不断扩大，进而拥有了自己的newsgroup，网站，以及基金。从Python 2.0开始，Python也从maillist的开发方式，转为完全开源的开发方式。社区气氛已经形成，工作被整个社区分担，Python也获得了更加高速的发展。</p><p>到今天，Python的框架已经确立。Python语言以对象为核心组织代码，支持多种编程范式，采用动态类型，自动进行内存回收。Python支持解释运行，并能调用C库进行拓展。Python有强大的标准库。由于标准库的体系已经稳定，所以Python的生态系统开始拓展到第三方包。这些包，如Django、web.py、wxpython、numpy、matplotlib、PIL，将Python升级成了物种丰富的热带雨林。</p><h2 id="启示录"><a href="#启示录" class="headerlink" title="启示录"></a>启示录</h2><p>Python崇尚优美、清晰、简单，是一个优秀并广泛使用的语言。Python在TIOBE排行榜中排行第八，它是Google的第三大开发语言，Dropbox的基础语言，豆瓣的服务器语言。Python的发展史可以作为一个代表，带给我许多启示。</p><p>在Python的开发过程中，社区起到了重要的作用。Guido自认为自己不是全能型的程序员，所以他只负责制订框架。如果问题太复杂，他会选择绕过去，也就是cut the corner。这些问题最终由社区中的其他人解决。社区中的人才是异常丰富的，就连创建网站，筹集基金这样与开发稍远的事情，也有人乐意于处理。如今的项目开发越来越复杂，越来越庞大，合作以及开放的心态成为项目最终成功的关键。</p><p>Python从其他语言中学到了很多，无论是已经进入历史的ABC，还是依然在使用的C和Perl，以及许多没有列出的其他语言。可以说，Python的成功代表了它所有借鉴的语言的成功。同样，Ruby借鉴了Python，它的成功也代表了Python某些方面的成功。每个语言都是混合体，都有它优秀的地方，但也有各种各样的缺陷。同时，一个语言“好与不好”的评判，往往受制于平台、硬件、时代等等外部原因。程序员经历过许多语言之争。其实，以开放的心态来接受各个语言，说不定哪一天，程序员也可以如Guido那样，混合出自己的语言。</p><p>无论Python未来的命运如何，Python的历史已经是本很有趣的小说。</p>]]></content>
    
    <summary type="html">
    
      Python语言的发展简史。
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>解决MAC系统上matplotlib无法使用问题</title>
    <link href="http://miclee.site/2017/05/12/%E8%A7%A3%E5%86%B3matplotlib%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://miclee.site/2017/05/12/解决matplotlib无法使用问题/</id>
    <published>2017-05-12T01:49:13.000Z</published>
    <updated>2017-05-12T01:58:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 在 MAC 上运行Python时，如果涉及到matplotlib画图，小火箭总是弹不出界面，有的还会报RuntimeError。 </em></strong><br><a id="more"></a></p><hr><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**RuntimeError**: Python <span class="keyword">is</span> <span class="keyword">not</span> installed <span class="keyword">as</span> a framework. The Mac OS X backend will <span class="keyword">not</span> be able <span class="keyword">to</span> function correctly <span class="keyword">if</span> Python <span class="keyword">is</span> <span class="keyword">not</span> installed <span class="keyword">as</span> a framework. See <span class="keyword">the</span> Python documentation <span class="keyword">for</span> more information <span class="keyword">on</span> installing Python <span class="keyword">as</span> a framework <span class="keyword">on</span> Mac OS X. Please either reinstall Python <span class="keyword">as</span> a framework, <span class="keyword">or</span> <span class="keyword">try</span> one <span class="keyword">of</span> <span class="keyword">the</span> other backends.</span><br></pre></td></tr></table></figure><p><strong>原因：</strong>  </p><p>Problem Cause In mac os image rendering back end of matplotlib (what-is-a-backend to render using the API of Cocoa by default). There is Qt4Agg and GTKAgg and as a back-end is not the default. Set the back end of macosx that is differ compare with other windows or linux os.</p><p><strong>解决方案：</strong></p><p>创建文件 ~/.matplotlib/matplotlibrc<br>增加内容:<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">backend: </span>TkAgg</span><br></pre></td></tr></table></figure></p><p>搞定收工！</p>]]></content>
    
    <summary type="html">
    
      在 MAC 上运行Python时，如果涉及到matplotlib画图，小火箭总是弹不出界面，有的还会报RuntimeError。
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Numpy 矩阵乘法</title>
    <link href="http://miclee.site/2017/05/10/py-dot-multiply/"/>
    <id>http://miclee.site/2017/05/10/py-dot-multiply/</id>
    <published>2017-05-10T09:02:17.000Z</published>
    <updated>2017-05-16T05:50:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 在NumPy中，array用于表示通用的N维数组，matrix则特定用于线性代数计算。array和matrix都可以用来表示矩阵，二者在进行乘法操作时，有一些不同之处。 </em></strong><br><a id="more"></a></p><hr><h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><p>使用array时，运算符 * 用于计算数量积（点乘），函数 dot() 用于计算矢量积（叉乘），例子如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">a = np.array([[1, 2], [3, 4]])</span><br><span class="line">b = np.array([[5, 6], [7, 8]])</span><br><span class="line"></span><br><span class="line">print(&apos;a * b = \n&apos;, a * b)</span><br><span class="line">print(&apos;dot(a, b) = \n&apos;, np.dot(a, b))</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a * b =</span><br><span class="line">[[ 5 12]</span><br><span class="line"> [21 32]]</span><br><span class="line">dot(a, b) =</span><br><span class="line">[[19 22]</span><br><span class="line"> [43 50]]</span><br></pre></td></tr></table></figure><p>可见，当a和b为array时， a <em> b 计算了a和b的数量积（对应Matlab的 a .</em> b ）， dot(a, b) 计算了a和b的矢量积（对应Matlab的 a * b ）。</p><h2 id="matrix"><a href="#matrix" class="headerlink" title="matrix"></a>matrix</h2><p>与array不同的是，使用matrix时，运算符 * 用于计算矢量积，函数 multiply() 用于计算数量积，例子如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">a = np.mat(&apos;1 2; 3 4&apos;)</span><br><span class="line">b = np.mat(&apos;5 6; 7 8&apos;);</span><br><span class="line"></span><br><span class="line">print &apos;a * b = \n&apos;, a * b</span><br><span class="line">print &apos;multiply(a, b) = \n&apos;, np.multiply(a, b)</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a * b =</span><br><span class="line"><span class="string">[[19 22]</span></span><br><span class="line"><span class="string"> [43 50]]</span></span><br><span class="line">multiply(a, b) =</span><br><span class="line"><span class="string">[[ 5 12]</span></span><br><span class="line"><span class="string"> [21 32]]</span></span><br></pre></td></tr></table></figure><p>可见，当a和b为matrix时， a * b 计算了a和b的矢量积， multiply(a, b) 计算了a和b的数量积。当使用matrix时，无论是生成矩阵还是计算，Numpy的风格和Matlab更加贴近，降低了语言切换时的负担。</p>]]></content>
    
    <summary type="html">
    
      在NumPy中，array用于表示通用的N维数组，matrix则特定用于线性代数计算。array和matrix都可以用来表示矩阵，二者在进行乘法操作时，有一些不同之处。
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
</feed>
