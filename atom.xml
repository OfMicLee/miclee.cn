<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MicLee&#39;s Bolg</title>
  
  <subtitle>道生一 一生二 二生三 三生万物</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://miclee.site/"/>
  <updated>2018-12-30T09:11:25.091Z</updated>
  <id>http://miclee.site/</id>
  
  <author>
    <name>射雕</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于sharding-sphere无需数据迁移的弹性扩容分片算法</title>
    <link href="http://miclee.site/2018/12/30/%E6%97%A0%E9%9C%80%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E7%9A%84%E5%BC%B9%E6%80%A7%E6%89%A9%E5%AE%B9%E5%88%86%E7%89%87%E7%AE%97%E6%B3%95/"/>
    <id>http://miclee.site/2018/12/30/无需数据迁移的弹性扩容分片算法/</id>
    <published>2018-12-30T08:39:06.000Z</published>
    <updated>2018-12-30T09:11:25.091Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 常见的分库分表方案大都用主键mod一个数（如分为8个库，则 id % 8 根据余数决定落到哪个分片）。此种方案中，如果要拓展数据库将是十分复杂的事情（例如拓展为10个，则代码需要改为 id % 10 之前的旧数据也要做迁移）。我们希望有一种支持自由规划无须数据迁移和修改路由代码的Sharding扩容方案。 </em></strong><br><a id="more"></a></p><hr><h3 id="Sharding-sphere介绍"><a href="#Sharding-sphere介绍" class="headerlink" title="Sharding-sphere介绍"></a>Sharding-sphere介绍</h3><p>sharding-sphere是基于当当的开源框架sharding-jdbc，团队加入京东后，现在成为Apache的项目。整个集合包含三个产品：  </p><h4 id="1-Sharding-jdbc"><a href="#1-Sharding-jdbc" class="headerlink" title="1. Sharding-jdbc"></a>1. Sharding-jdbc</h4><p>Sharding-JDBC是Sharding-Sphere的第一个产品，也是Sharding-Sphere的前身。 它定位为轻量级Java框架，在Java的JDBC层提供分库分表、读写分离、数据库治理、柔性事务等服务。它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。</p><h4 id="2-Sharding-Proxy"><a href="#2-Sharding-Proxy" class="headerlink" title="2. Sharding-Proxy"></a>2. Sharding-Proxy</h4><p>Sharding-Proxy是Sharding-Sphere的第二个产品。 定位为透明化的数据库代理端，提供封装了数据库二进制协议的服务端版本，用于完成对异构语言的支持。 目前先提供MySQL版本，它可以使用任何兼容MySQL协议的访问客户端(如：MySQL Command Client, MySQL Workbench等)操作数据，对DBA更加友好。</p><h4 id="3-Sharding-Sidecar"><a href="#3-Sharding-Sidecar" class="headerlink" title="3. Sharding-Sidecar"></a>3. Sharding-Sidecar</h4><p>Sharding-Sidecar定位为Kubernetes或Mesos的云原生数据库代理，以DaemonSet的形式代理所有对数据库的访问。 通过无中心、零侵入的方案提供与数据库交互的的啮合层，即Database Mesh，又可称数据网格。<br>Database Mesh的关注重点在于如何将分布式的数据访问应用与数据库有机串联起来，它更加关注的是交互，是将杂乱无章的应用与数据库之间的交互有效的梳理。使用Database Mesh，访问数据库的应用和数据库终将形成一个巨大的网格体系，应用和数据库只需在网格体系中对号入座即可，它们都是被啮合层所治理的对象。</p><h4 id="4-Mixed-scheme-of-Sharding-JDBC-amp-Sharding-Proxy"><a href="#4-Mixed-scheme-of-Sharding-JDBC-amp-Sharding-Proxy" class="headerlink" title="4. Mixed scheme of Sharding-JDBC &amp; Sharding-Proxy"></a>4. Mixed scheme of Sharding-JDBC &amp; Sharding-Proxy</h4><p><strong>混合架构</strong><br>Sharding-JDBC采用无中心化架构，适用于Java开发的高性能的轻量级OLTP应用；Sharding-Proxy提供静态入口以及异构语言的支持，适用于OLAP应用以及对分片数据库进行管理和运维的场景。</p><p>ShardingSphere是多接入端共同组成的生态圈。 通过混合使用Sharding-JDBC和Sharding-Proxy，并采用同一注册中心统一配置分片策略，能够灵活的搭建适用于各种场景的应用系统，使得架构师更加自由的调整适合与当前业务的最佳系统架构。  </p><p><img src="http://cdn.processon.com/5c0f6316e4b0c87510c92820?e=1544515878&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:TJvZtqEh2px8v3TebojfI6HHuGU=" alt=""></p><h3 id="分片方案设计"><a href="#分片方案设计" class="headerlink" title="分片方案设计"></a>分片方案设计</h3><p>前面了解了Twitter-Snowflake分库分表算法的实现，而Snowflake主键算法本身就带时间戳，我们可以基于它实现无需数据迁移的扩容方案。<br>　　Snowflake生成的ID是一个64位的Long值，通过主键可以算出两个维度的值：</p><ul><li>时间维度<br>主键的前42位就是一个以毫秒为单位的时间戳。  </li><li>分片维度<br>对主键做Hash运算（为了得到的hash值尽可能散，使用MurmurHash算法），可以得到一个32位的hash值，我们以它的前16位作为数据库分片值，后16位作为表分片值。</li></ul><p>如此一来，只需根据时间戳，指定某一时间戳后使用新的分片规则，即可不迁移数据对数据库进行扩容。  </p><p><strong>具体实现</strong><br>这只是个算法和框架无关，你可以基于各种分库分表中间件实现它，此处基于当当网的Sharding-JDBC写了实现（修改中，未Merge），<a href="https://github.com/sharding-sphere/sharding-sphere/issues/186" target="_blank" rel="noopener">Issue地址</a>，<a href="https://github.com/xydonne/sharding-jdbc/tree/hash-sharding/186" target="_blank" rel="noopener">Branch地址</a></p><hr><p>参考：<a href="http://www.jianshu.com/p/d296fa2bf61b" target="_blank" rel="noopener">http://www.jianshu.com/p/d296fa2bf61b</a></p>]]></content>
    
    <summary type="html">
    
      常见的分库分表方案大都用主键mod一个数（如分为8个库，则 id % 8 根据余数决定落到哪个分片）。此种方案中，如果要拓展数据库将是十分复杂的事情（例如拓展为10个，则代码需要改为 id % 10 之前的旧数据也要做迁移）。我们希望有一种支持自由规划无须数据迁移和修改路由代码的Sharding扩容方案。
    
    </summary>
    
      <category term="电商交易" scheme="http://miclee.site/categories/%E7%94%B5%E5%95%86%E4%BA%A4%E6%98%93/"/>
    
    
      <category term="分布式" scheme="http://miclee.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式ID</title>
    <link href="http://miclee.site/2018/12/30/%E5%88%86%E5%B8%83%E5%BC%8FID/"/>
    <id>http://miclee.site/2018/12/30/分布式ID/</id>
    <published>2018-12-30T08:38:18.000Z</published>
    <updated>2018-12-30T08:55:21.627Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 分布式系统下典型的一个场景就是分布式ID的设计，会有哪些可用方案呢？ </em></strong><br><a id="more"></a></p><hr><h3 id="主键生成策略"><a href="#主键生成策略" class="headerlink" title="主键生成策略"></a>主键生成策略</h3><p>系统唯一ID是我们在设计一个系统的时候常常会遇见的问题，下面介绍一些常见的ID生成策略。  </p><ul><li>Sequence ID</li><li>UUID</li><li>GUID</li><li>COMB</li><li>Snowflake</li></ul><p>最开始的自增ID为了实现分库分别的需求，会在自增的前提下，使用不同步长(例如DB1 生成1,4,7,10，DB2生成2,5,8,11，DB3生成3,6,9,12)，但需要做数据库拓展时，极其麻烦。<br>相比自增ID，UUID生成唯一主键更加方便（数据量非常大的情况下，存在重复的可能），但由于UUID的无序性，性能不如自增ID，字符串储存，储存空间大，查询效率低。<br>COMB相对于UUID，增加了生成ID的有序性，插入与查询效率都有所提高。<br>Sonwflake是Twitter主键生成策略，可以看做是COMB的一种改进，用64位的长整型代替128位的字符串。ID构成：第一位0 + 41位的时间前缀 + 10位的节点标识 + 12位的sequence避免并发的数字。  </p><h4 id="1-Sequence-ID"><a href="#1-Sequence-ID" class="headerlink" title="1. Sequence ID"></a>1. Sequence ID</h4><p>数据库自增长序列或字段，最常见的方式。由数据库维护，数据库唯一。<br><strong>优点：</strong><br>简单，代码方便，性能可以接受。<br>数字ID天然排序，对分页或者需要排序的结果很有帮助。</p><p><strong>缺点：</strong><br>不同数据库语法和实现不同，数据库迁移的时候或多数据库版本支持的时候需要处理。<br>在单个数据库或读写分离或一主多从的情况下，只有一个主库可以生成。有单点故障的风险。<br>在性能达不到要求的情况下，比较难于扩展。<br>如果遇见多个系统需要合并或者涉及到数据迁移会相当痛苦。<br>分表分库的时候会有麻烦。</p><p><strong>优化方案：</strong><br>针对主库单点，如果有多个Master库，则每个Master库设置的起始数字不一样，步长一样，可以是Master的个数。<br>比如：Master1 生成的是 1，4，7，10，Master2生成的是2,5,8,11 Master3生成的是 3,6,9,12。这样就可以有效生成集群中的唯一ID，也可以大大降低ID生成数据库操作的负载。</p><h4 id="2-UUID"><a href="#2-UUID" class="headerlink" title="2. UUID"></a>2. UUID</h4><p>常见的方式,128位。可以利用数据库也可以利用程序生成，一般来说全球唯一。<br><strong>优点：</strong><br>简单，代码方便。<br>全球唯一，在遇见数据迁移，系统数据合并，或者数据库变更等情况下，可以从容应对。</p><p><strong>缺点：</strong><br>没有排序，无法保证趋势递增。<br>UUID往往是使用字符串存储，查询的效率比较低。<br>存储空间比较大，如果是海量数据库，就需要考虑存储量的问题。<br>传输数据量大<br>不可读。</p><p><strong>优化方案：</strong><br>为了解决UUID不可读，可以使用UUID to Int64的方法。</p><h4 id="3-GUID"><a href="#3-GUID" class="headerlink" title="3. GUID"></a>3. GUID</h4><p>GUID：是微软对UUID这个标准的实现。UUID还有其它各种实现，不止GUID一种。优缺点同UUID。</p><h4 id="4-COMB"><a href="#4-COMB" class="headerlink" title="4. COMB"></a>4. COMB</h4><p>COMB（combine）型是数据库特有的一种设计思想，可以理解为一种改进的GUID，它通过组合GUID和系统时间，以使其在索引和检索事有更优的性能。<br>数据库中没有COMB类型，它是Jimmy Nilsson在他的“The Cost of GUIDs as Primary Keys”一文中设计出来的。<br>COMB数据类型的基本设计思路是这样的：既然UniqueIdentifier数据因毫无规律可言造成索引效率低下，影响了系统的性能，那么我们能不能通过组合的方式，保留UniqueIdentifier的前10个字节，用后6个字节表示GUID生成的时间（DateTime），这样我们将时间信息与UniqueIdentifier组合起来，在保留UniqueIdentifier的唯一性的同时增加了有序性，以此来提高索引效率。</p><p><strong>优点：</strong><br>解决UUID无序的问题，在其主键生成方式中提供了Comb算法(combined guid/timestamp)。保留GUID的10个字节，用另6个字节表示GUID生成的时间(DateTime)。<br>性能优于UUID。</p><h4 id="5-Twitter的snowflake算法"><a href="#5-Twitter的snowflake算法" class="headerlink" title="5. Twitter的snowflake算法"></a>5. Twitter的snowflake算法</h4><p>snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。snowflake算法可以根据自身项目的需要进行一定的修改。比如估算未来的数据中心个数，每个数据中心的机器数以及统一毫秒可以能的并发数来调整在算法中所需要的bit数。  </p><p><strong>优点：</strong><br>不依赖于数据库，灵活方便，且性能优于数据库。<br>ID按照时间在单机上是递增的。</p><p><strong>缺点：</strong><br>在单机上是递增的，但是由于涉及到分布式环境，每台机器上的时钟不可能完全同步，也许有时候也会出现不是全局递增的情况。</p><hr><p><a href="http://www.jianshu.com/p/a0a3aa888a49" target="_blank" rel="noopener">From Donney Young -&gt;</a></p>]]></content>
    
    <summary type="html">
    
      分布式系统下典型的一个场景就是分布式ID的设计，会有哪些可用方案呢？
    
    </summary>
    
      <category term="电商交易" scheme="http://miclee.site/categories/%E7%94%B5%E5%95%86%E4%BA%A4%E6%98%93/"/>
    
    
      <category term="分布式" scheme="http://miclee.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>电商秒杀场景实现方案</title>
    <link href="http://miclee.site/2018/12/26/%E7%94%B5%E5%95%86%E7%A7%92%E6%9D%80%E5%9C%BA%E6%99%AF%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"/>
    <id>http://miclee.site/2018/12/26/电商秒杀场景实现方案/</id>
    <published>2018-12-26T03:27:01.000Z</published>
    <updated>2018-12-26T07:02:20.449Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 秒杀属于电商的常见业务场景，特点是时间短、瞬时并发量高。针对这样的场景我们需要怎样的技术方案来应对呢？ </em></strong><br><a id="more"></a></p><hr><p><strong>场景特点：</strong></p><ol><li>瞬时大访问量，流量波峰</li><li>用户不断刷新页面导致高并发</li><li>控制不能提前下单</li><li>下单防止超卖</li><li>单用户购买限制</li><li>页面更新为活动结束</li></ol><p><strong>解决方案：</strong></p><ol><li>如果同时秒杀商品较多，需要做服务隔离，单独部署甚至使用独立域名，避免对主应用影响；</li><li>单独设计秒杀商品页面，不使用网站原来的商品详细页面，页面内容静态化，上CDN，用户请求不需要经过应用服务；</li><li>设计单独控制秒杀按钮的JS文件（文件要非常小）放在js服务器上，由另外一台服务器写 定时任务 来控制js 推送；<br>可以使用xxx.js?v=随机数 的方式来避免js被浏览器缓存；<br>后端同时要做开始控制，避免跳过页面的接口访问；</li><li>商品秒杀库存提前放入redis。活动开始后利用redis decby原子命令或者watch乐观锁模式扣减库存；<br>扣减成功后异步通知消息到队列，可以用有界非阻塞队列，每个商品单独队列，界点为活动库存值（也可以用MQ）；<br>队列消费端连接商城正常下单逻辑；</li><li>用户进入秒杀接口立即在redis 注入标记，下单成功后用户标记保留（不能再下单），下单失败清除标记，用户可再次尝试</li><li>后台定时轮询读取redis活动库存，库存为0后推送新的js，将页面展现为“活动结束”，方案同第3点</li></ol><p><strong>防刷场景：</strong></p><ol><li>同一账号刷单<br>就是单用户购买限制，上面已经解决了</li><li>僵尸号刷单<br>通过检测指定机器IP请求频率解决，如果发现某个IP请求频率很高，可以给它弹出一个验证码或者直接禁止IP</li><li>僵尸号不同代理IP刷单<br>这种场景下的请求，和真实用户的行为，已经基本相同了，想做分辨很困难。再做进一步的限制很容易“误伤“真实用户，这个时候，通常只能通过设置业务门槛高来限制这种请求了，或者通过账号行为的”数据挖掘“来提前清理掉它们。<br>现在有专门的数据公司专业做这个业务，帮助电商的活动资源有效用在真实客户身上。但是进攻和防守，是一场永远不会停止的战争。</li></ol>]]></content>
    
    <summary type="html">
    
      秒杀属于电商的常见业务场景，特点是时间短、瞬时并发量高。针对这样的场景我们需要怎样的技术方案来应对呢？
    
    </summary>
    
      <category term="电商交易" scheme="http://miclee.site/categories/%E7%94%B5%E5%95%86%E4%BA%A4%E6%98%93/"/>
    
    
      <category term="高并发" scheme="http://miclee.site/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>分布式领域CAP理论</title>
    <link href="http://miclee.site/2018/12/24/%E5%88%86%E5%B8%83%E5%BC%8F%E9%A2%86%E5%9F%9FCAP%E7%90%86%E8%AE%BA/"/>
    <id>http://miclee.site/2018/12/24/分布式领域CAP理论/</id>
    <published>2018-12-24T08:03:56.000Z</published>
    <updated>2018-12-24T08:06:00.611Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 上篇文章讲到各注册中心设计中CAP的取舍，究竟什么是CAP呢？ </em></strong><br><a id="more"></a></p><hr><h3 id="分布式领域CAP理论"><a href="#分布式领域CAP理论" class="headerlink" title="分布式领域CAP理论"></a>分布式领域CAP理论</h3><ul><li>Consistency(一致性), 数据一致更新，所有数据变动都是同步的</li><li>Availability(可用性), 好的响应性能</li><li>Partition tolerance(分区容错性) 可靠性</li></ul><p><strong>定理：</strong>任何分布式系统只可同时满足二点，没法三者兼顾。<br><strong>忠告：</strong>架构师不要将精力浪费在如何设计能满足三者的完美分布式系统，而是应该进行取舍。</p><h4 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h4><p>关系数据库的ACID模型拥有高一致性和高可用性：</p><ul><li>Atomicity原子性：一个事务中所有操作都必须全部完成，要么全部不完成。</li><li>Consistency一致性. 在事务开始或结束时，数据库应该在一致状态。</li><li>Isolation隔离层. 事务将假定只有它自己在操作数据库，彼此不知晓。</li><li>Durability. 一旦事务完成，就不能返回。</li><li>跨数据库事务：2PC (two-phase commit)， 2PC is the anti-scalability pattern (Pat Helland) 是反可伸缩模式的，JavaEE中的JTA事务可以支持2PC。因为2PC是反模式，尽量不要使用2PC，使用BASE来回避。</li></ul><h4 id="BASE模型"><a href="#BASE模型" class="headerlink" title="BASE模型"></a>BASE模型</h4><p>BASE模型反ACID模型，完全不同ACID模型，牺牲高一致性，获得可用性和可靠性：</p><ul><li>Basically Available基本可用。支持分区失败(e.g. sharding碎片划分数据库)</li><li>Soft state软状态 状态可以有一段时间不同步，异步。</li><li>Eventually consistent最终一致，最终数据是一致的就可以了，而不是时时高一致。</li></ul><p>BASE思想主要强调基本的可用性，如果你需要High 可用性，也就是纯粹的高性能，那么就要以一致性或容错性为牺牲，BASE思想的方案在性能上还是有潜力可挖的。主要实现有：<strong>按功能划分数据库 &amp; sharding碎片</strong></p><p>现在NOSQL运动丰富了拓展了BASE思想，可按照具体情况定制特别方案，比如忽视一致性，获得高可用性等等，NOSQL应该有下面两个流派：</p><ol><li>Key-Value存储，如Amaze Dynamo等，可根据CAP三原则灵活选择不同倾向的数据库产品。</li><li>领域模型 + 分布式缓存 + 存储 （Qi4j和NoSql运动），可根据CAP三原则结合自己项目定制灵活的分布式方案，难度高。</li></ol><p>这两者共同点：都是关系数据库SQL以外的可选方案，逻辑随着数据分布，任何模型都可以自己持久化，将数据处理和数据存储分离，将读和写分离，存储可以是异步或同步，取决于对一致性的要求程度。<br>不同点：NOSQL之类的Key-Value存储产品是和关系数据库头碰头的产品BOX，可以适合非Java如PHP RUBY等领域，是一种可以拿来就用的产品，而领域模型 + 分布式缓存 + 存储是一种复杂的架构解决方案，不是产品，但这种方式更灵活，更应该是架构师必须掌握的。</p>]]></content>
    
    <summary type="html">
    
      上篇文章讲到各注册中心设计中CAP的取舍，究竟什么是CAP呢？
    
    </summary>
    
      <category term="Spring cloud" scheme="http://miclee.site/categories/Spring-cloud/"/>
    
    
      <category term="Spring cloud" scheme="http://miclee.site/tags/Spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring cloud注册中心</title>
    <link href="http://miclee.site/2018/12/24/ConsulvsZookeepervsEtcdvsEureka/"/>
    <id>http://miclee.site/2018/12/24/ConsulvsZookeepervsEtcdvsEureka/</id>
    <published>2018-12-24T07:20:09.000Z</published>
    <updated>2018-12-24T08:03:41.716Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> eureka官方已经正式宣布：自2.0起不再维护该项目，并在github 项目wiki上放出了一段吓唬人的话，大意就是：从2.x起，官方不会继续开发了，如果需要使用2.x，风险自负。 </em></strong><br><a id="more"></a></p><hr><p>但其实我觉得问题并不大，eureka目前的功能已经非常稳定，就算不升级，服务注册/发现这些功能已经够用。如果想寻找替代方案的话，建议采用功能更为丰富的consul，除了服务注册、发现，consul还提供了k-v存储等其它功能，consul的官网针对其它同类软件也做了详细比较，详见 <a href="https://www.consul.io/intro/vs/index.html" target="_blank" rel="noopener">consul vs other software</a>，有兴趣的可以看看，特别是有一句话，翻译成大白话就是：我不是针对在座的各位，我想说除我之外其它的都是渣渣（足见其相当的自信！）</p><p>OK，回归正题，这里我们来对比下四个常用的注册中心解决方案Consul、Zookeeper、Etcd、Eureka：  </p><h3 id="特性对比"><a href="#特性对比" class="headerlink" title="特性对比"></a>特性对比</h3><table><thead><tr><th>Feature</th><th>Consul</th><th>zookeeper</th><th>etcd</th><th>euerka</th></tr></thead><tbody><tr><td>服务健康检查</td><td>服务状态，内存，硬盘等</td><td>(弱)长连接，keepalive</td><td>连接心跳</td><td>可配支持</td></tr><tr><td>多数据中心</td><td>支持</td><td>—</td><td>—</td><td>—</td></tr><tr><td>kv存储服务</td><td>支持</td><td>支持</td><td>支持</td><td>—</td></tr><tr><td>一致性</td><td>raft</td><td>paxos</td><td>raft</td><td>—</td></tr><tr><td>cap</td><td>ca</td><td>cp</td><td>cp</td><td>ap</td></tr><tr><td>使用接口(多语言能力)</td><td>支持http和dns</td><td>客户端</td><td>http/grpc</td><td>http（sidecar）</td></tr><tr><td>watch支持</td><td>全量/支持long polling</td><td>支持</td><td>支持 long polling</td><td>支持 long polling/大部分增量</td></tr><tr><td>自身监控</td><td>metrics</td><td>—</td><td>metrics</td><td>metrics</td></tr><tr><td>安全</td><td>acl/https</td><td>acl</td><td>https支持（弱）</td><td>—</td></tr><tr><td>spring cloud集成</td><td>已支持</td><td>已支持</td><td>已支持</td><td>已支持</td></tr></tbody></table><ul><li><h4 id="服务的健康检查"><a href="#服务的健康检查" class="headerlink" title="服务的健康检查"></a>服务的健康检查</h4><p>Euraka 使用时需要显式配置健康检查支持；Zookeeper,Etcd 则在失去了和服务进程的连接情况下任务不健康，而 Consul 相对更为详细点，比如内存是否已使用了90%，文件系统的空间是不是快不足了。</p></li><li><h4 id="多数据中心支持"><a href="#多数据中心支持" class="headerlink" title="多数据中心支持"></a>多数据中心支持</h4><p>Consul 通过 WAN 的 Gossip 协议，完成跨数据中心的同步；而且其他的产品则需要额外的开发工作来实现；</p></li><li><h4 id="KV-存储服务"><a href="#KV-存储服务" class="headerlink" title="KV 存储服务"></a>KV 存储服务</h4><p>除了 Eureka ,其他几款都能够对外支持 k-v 的存储服务，所以后面会讲到这几款产品追求高一致性的重要原因。而提供存储服务，也能够较好的转化为动态配置服务哦。</p></li><li><h4 id="产品设计中-CAP-理论的取舍"><a href="#产品设计中-CAP-理论的取舍" class="headerlink" title="产品设计中 CAP 理论的取舍"></a>产品设计中 CAP 理论的取舍</h4><p>Eureka 典型的 AP,作为分布式场景下的服务发现的产品较为合适，服务发现场景的可用性优先级较高，一致性并不是特别致命。其次 CA 类型的场景 Consul,也能提供较高的可用性，并能 k-v store 服务保证一致性。 而Zookeeper,Etcd则是CP类型 牺牲可用性，在服务发现场景并没太大优势。  </p><p>Eureka提供了一个弱一致的服务视图，使用尽力而为复制。当客户端向服务器注册时，该服务器将尝试复制到其他服务器，但不提供保证。服务注册的生存时间（TTL）较短，要求客户端对服务器心存感激。不健康的服务或节点将停止心跳，导致它们超时并从注册表中删除。发现请求可以路由到任何服务，由于尽力而为的复制，这些服务可能会导致陈旧或丢失数据。这个简化的模型允许简单的群集管理和高可扩展性。  </p><p>Consul提供强大的一致性保证，因为服务器使用Raft协议复制状态（<a href="http://www.cnblogs.com/mindwind/p/5231986.html" target="_blank" rel="noopener">Raft 协议的易理解性描述</a>）。Consul支持丰富的健康检查，包括TCP，HTTP，Nagios / Sensu兼容脚本或基于Eureka的TTL。客户端节点参与基于八卦的健康检查，该检查分发健康检查工作，而不像集中式心跳检测那样成为可扩展性挑战。发现请求被路由到选举出来的领事领导，这使他们默认情况下强烈一致。允许陈旧读取的客户端使任何服务器都可以处理他们的请求，从而实现像Eureka这样的线性可伸缩性。Consul强烈的一致性意味着它可以作为领导选举和集群协调的锁定服务。Eureka不提供类似的保证，并且通常需要为需要执行协调或具有更强一致性需求的服务运行ZooKeeper.  </p></li><li><h4 id="多语言能力与对外提供服务的接入协议"><a href="#多语言能力与对外提供服务的接入协议" class="headerlink" title="多语言能力与对外提供服务的接入协议"></a>多语言能力与对外提供服务的接入协议</h4><p>Zookeeper的跨语言支持较弱，其他几款支持 http11 提供接入的可能。Euraka 一般通过 sidecar的方式提供多语言客户端的接入支持。Etcd 还提供了Grpc的支持。 Consul除了标准的Rest服务api,还提供了DNS的支持。</p></li><li><h4 id="Watch的支持（客户端观察到服务提供者变化）"><a href="#Watch的支持（客户端观察到服务提供者变化）" class="headerlink" title="Watch的支持（客户端观察到服务提供者变化）"></a>Watch的支持（客户端观察到服务提供者变化）</h4><p>Zookeeper 支持服务器端推送变化，Eureka 2.0(正在开发中)也计划支持。 Eureka 1,Consul,Etcd则都通过长轮询的方式来实现变化的感知；</p></li><li><h4 id="自身集群的监控"><a href="#自身集群的监控" class="headerlink" title="自身集群的监控"></a>自身集群的监控</h4><p>除了 Zookeeper ,其他几款都默认支持 metrics，运维者可以搜集并报警这些度量信息达到监控目的；</p></li><li><h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><p>Consul,Zookeeper 支持ACL，另外 Consul,Etcd 支持安全通道https.</p></li><li><h4 id="Spring-Cloud的集成"><a href="#Spring-Cloud的集成" class="headerlink" title="Spring Cloud的集成"></a>Spring Cloud的集成</h4><p>目前都有相对应的 boot starter，提供了集成能力。</p></li></ul>]]></content>
    
    <summary type="html">
    
      eureka官方已经正式宣布：自2.0起不再维护该项目，并在github 项目wiki上放出了一段吓唬人的话，大意就是：从2.x起，官方不会继续开发了，如果需要使用2.x，风险自负。
    
    </summary>
    
      <category term="Spring cloud" scheme="http://miclee.site/categories/Spring-cloud/"/>
    
    
      <category term="Spring cloud" scheme="http://miclee.site/tags/Spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>Web本地存储</title>
    <link href="http://miclee.site/2018/12/22/Web%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"/>
    <id>http://miclee.site/2018/12/22/Web本地存储/</id>
    <published>2018-12-22T12:39:12.000Z</published>
    <updated>2018-12-22T13:01:42.229Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> WEB 浏览器端本地存储的常规策略。 </em></strong><br><a id="more"></a></p><hr><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ul><li>cookie数据始终在同源的http请求中携带（即使不需要）</li><li>cookie数据存储大小限制为4K</li><li>在设置的cookie过期时间之前永远有效，即使窗口关闭或浏览器关闭</li><li>cookie在所有同源窗口中都是共享的  </li></ul><h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h2><ul><li>请求中不携带，与服务端无关</li><li>存储大小限制5M</li><li>始终有效，窗口或浏览器关闭也一直保存，除非手动删除，因此用作持久数据</li><li>localstorage在所有同源窗口中都是共享的  </li></ul><h2 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h2><ul><li>请求中不携带，与服务端无关</li><li>存储大小限制5M</li><li>浏览器窗口关闭后立刻销毁</li><li>sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面  </li></ul><h2 id="Web-SQL"><a href="#Web-SQL" class="headerlink" title="Web SQL"></a>Web SQL</h2><p>关系数据库，通过SQL语句访问<br>Web SQL 数据库 API 并不是 HTML5 规范的一部分，但是它是一个独立的规范，引入了一组使用 SQL 操作客户端数据库的 APIs。</p><p>浏览器支持：<br>Web SQL 数据库可以在最新版的 Safari, Chrome 和 Opera 浏览器中工作。  </p><h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><p>IndexedDB 是一种更复杂和全面地客户端数据存储方案，它是基于 JavaScript、面向对象的和数据库的，能非常容易地存储数据和检索已经建立关键字索引的数据。</p><p>IndexedDB 的优点：</p><ul><li>能够处理更复杂和结构化的数据</li><li>每个’database’中可以有多个’databases’和’tables’</li><li>更大的存储空间</li><li>对其有更多的交互控制  </li></ul><p>IndexedDB 的缺点</p><ul><li>比 Web Storage API 更难于应用  </li></ul><p>浏览器支持：<br>IE10+/Edge12+/Firefox 4+/Chrome 11+/Safari 7.1+/Opera 15+(caniuse)  </p><h2 id="离线缓存-application-cache"><a href="#离线缓存-application-cache" class="headerlink" title="离线缓存 application cache"></a>离线缓存 application cache</h2><p>应用程序缓存，是从浏览器的缓存中分出来的一块缓存区，要想在这个缓存中保存数据，可以使用一个描述文件（manifest file），列出要下载和缓存的资源。<br>application cache通过mainfest文件指定了缓存的资源，可以使我们的应用在断网的时候也能够使用。  </p><p>浏览器支持：<br>IE10+、Firefox3+、Safari4+、Opera10.6、Chrome、iOS3.2+、Android Webkit  </p><p>application cache的使用比较简单，只需要两步<br>1、服务器端需要维护一个manifest清单<br>2、Html标签用属性manifest引入文件即可</p>]]></content>
    
    <summary type="html">
    
      WEB 浏览器端本地存储的常规策略。
    
    </summary>
    
      <category term="Http" scheme="http://miclee.site/categories/Http/"/>
    
    
      <category term="Http" scheme="http://miclee.site/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>python 应用部署</title>
    <link href="http://miclee.site/2017/05/18/python-deploy/"/>
    <id>http://miclee.site/2017/05/18/python-deploy/</id>
    <published>2017-05-18T06:49:09.000Z</published>
    <updated>2017-05-20T08:56:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> flask 自带的服务器，能够完成了 web 服务的启动，但在生产环境下，无法满足性能要求。我们这里采用 gunicorn 做 wsgi容器，用来部署 python。 </em></strong><br><a id="more"></a></p><hr><p>web的部署，一般都是 nginx 做前端代理，中间 webservice 调用程序脚本。大概方式：nginx + webservice + script</p><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p>nginx，高性能的web服务器，通常用来在前端做反向代理服务器。<br>一个请求经过代理服务器从局域网发出，然后到达互联网上服务器，这个过程的代理为 <strong>正向代理</strong>。<br>如果一个请求，从互联网过来，先进入代理服务器，再由代理服务器转发给局域网的目标服务器，这个时候，代理服务器为 <strong>反向代理</strong>（相对正向而言）。</p><h2 id="webservice"><a href="#webservice" class="headerlink" title="webservice"></a>webservice</h2><p>webservice 也有很多方式。常见的有FastCGI，WSGI等。我们采用gunicorn为 wsgi容器，python为服务器script，采用flask框架。<br>最终的部署方式为：<br>nginx + gunicorn + flask</p><h2 id="gunicorn-使用"><a href="#gunicorn-使用" class="headerlink" title="gunicorn 使用"></a>gunicorn 使用</h2><ul><li><strong>安装</strong>  </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install gunicorn</span><br></pre></td></tr></table></figure><ul><li><strong>运行</strong>  </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunicorn -w4 -b0.0.0.0:8080 run:app</span><br></pre></td></tr></table></figure><p>-w 表示开启多少个 worker，-b 表示 gunicorn 开发的访问地址</p><p>为了在后台运行这个服务器（也即使它变成守护进程），可以传递-D选项给Gunicorn。这下它会持续运行，即使你关闭了当前的终端会话。</p><p>如果这么做了，当想要关闭服务器时就会困惑于到底应该关闭哪个进程。我们可以让Gunicorn把进程ID储存到文件中，这样如果想要停止或者重启服务器时，我们可以不用在一大串运行中的进程中搜索它。我们使用-p <file>选项来这么做。现在，我们的Gunicorn部署命令是这样：</file></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunicorn -w4 -b0.0.0.0:8080 run:app -p run.pid -D</span><br></pre></td></tr></table></figure><ul><li><strong>重启</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -HUP `cat run.pid` # 发送一个SIGHUP信号，终止进程</span><br></pre></td></tr></table></figure><ul><li><strong>关闭</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill `cat run.pid`</span><br></pre></td></tr></table></figure><ul><li><strong>访问地址的设置</strong><br>Gunicorn应该隐藏于反向代理之后。如果你直接让它监听来自外网的请求，它很容易成为拒绝服务攻击的目标。<br>只有在debug的情况下你才能把Gunicorn摆上前台，而且完工之后，切记把它重新隐藏到幕后。</li></ul><p>Gunicorn绑定在 127.0.0.1 上时，它仅仅监听来自服务器自身的连接。所以通常使用一个反向代理来作为外网和Gunicorn服务器的中介。<br>Gunicorn绑定在 0.0.0.0 上时，它就会监听所有请求，这样可以直接从外网发送请求给Gunicorn。debug的时候可以这么做。</p><h2 id="nginx的配置"><a href="#nginx的配置" class="headerlink" title="nginx的配置"></a>nginx的配置</h2><p>交给运维去管吧</p>]]></content>
    
    <summary type="html">
    
      flask 自带的服务器，能够完成了 web 服务的启动，但在生产环境下，无法满足性能要求。我们这里采用 gunicorn 做 wsgi容器，用来部署 python。
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>解决 ImportError cannot import name &#39;db&#39;</title>
    <link href="http://miclee.site/2017/05/17/ImportError/"/>
    <id>http://miclee.site/2017/05/17/ImportError/</id>
    <published>2017-05-17T03:19:14.000Z</published>
    <updated>2017-05-17T03:41:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 在使用 flask_sqlalchemy 的时候启动项目总是报错ImportError cannot import name 'db'，解决方案如此。 </em></strong><br><a id="more"></a></p><hr><h2 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "/Users/MicLee/WorkSpace/risk-model/pandora/pandora/__main__.py", line 28, in &lt;module&gt;</span><br><span class="line">    from pandora import get_app</span><br><span class="line">  File "/Users/MicLee/WorkSpace/risk-model/pandora/pandora/__init__.py", line 16, in &lt;module&gt;</span><br><span class="line">    import pandora.web.views</span><br><span class="line">  File "/Users/MicLee/WorkSpace/risk-model/pandora/pandora/web/views.py", line 8, in &lt;module&gt;</span><br><span class="line">    from pandora.dao import theta as ta</span><br><span class="line">  File "/Users/MicLee/WorkSpace/risk-model/pandora/pandora/dao/theta.py", line 8, in &lt;module&gt;</span><br><span class="line">    from pandora import db</span><br><span class="line">ImportError: cannot import name 'db'</span><br></pre></td></tr></table></figure><h2 id="错误相关项目结构"><a href="#错误相关项目结构" class="headerlink" title="错误相关项目结构"></a>错误相关项目结构</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pandora</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── __main__.py</span><br><span class="line">│   └── web</span><br><span class="line">│       ├── __init__.py</span><br><span class="line">│       └── views.py</span><br></pre></td></tr></table></figure><h2 id="错误相关代码"><a href="#错误相关代码" class="headerlink" title="错误相关代码"></a>错误相关代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">#</span><br><span class="line"># @Author  : MicLee</span><br><span class="line"># @Date    : 2017/4/5 17:55</span><br><span class="line"># @File    : __init__.py</span><br><span class="line"></span><br><span class="line">from flask import Flask</span><br><span class="line">from flask_sqlalchemy import SQLAlchemy</span><br><span class="line">from flask_cors import CORS, cross_origin</span><br><span class="line">from pandora import config</span><br><span class="line">import pandora.web.views</span><br><span class="line"></span><br><span class="line">__version__ = &quot;0.1&quot;</span><br><span class="line">__description__ = &quot;NFQ Risk Model.&quot;</span><br><span class="line"></span><br><span class="line">db = SQLAlchemy()</span><br><span class="line">_app = None</span><br><span class="line"></span><br><span class="line">def _create_app():</span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    app.config.from_object(config)</span><br><span class="line"></span><br><span class="line">    CORS(app)</span><br><span class="line">    db.init_app(app)</span><br><span class="line">    return app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_app():</span><br><span class="line">    global _app</span><br><span class="line">    if _app is None:</span><br><span class="line">        _app = _create_app()</span><br><span class="line">    return _app</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">#</span><br><span class="line"># @Author  : MicLee</span><br><span class="line"># @Date    : 2017/5/16 15:28</span><br><span class="line"># @File    : views.py</span><br><span class="line"></span><br><span class="line">from pandora import db</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>1、开始以为是import的路径错误，仔细研究了下python的import机制，并木有发现问题。<br>2、考虑到Python顺序执行的特点，在执行 “import pandora.web.views” 时加载views.py，执行“from pandora import db”，而“db = SQLAlchemy()”语句还没执行，db对象还没有被创建，所以发生ImportError!</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>将 “import pandora.web.views” 放到 <strong>init.py</strong> 的最后。</p>]]></content>
    
    <summary type="html">
    
      在使用 flask_sqlalchemy 的时候启动项目总是报错ImportError cannot import name &#39;db&#39;，解决方案如此。
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python字符串格式符</title>
    <link href="http://miclee.site/2017/05/16/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E7%AC%A6/"/>
    <id>http://miclee.site/2017/05/16/python字符串格式符/</id>
    <published>2017-05-16T06:28:00.000Z</published>
    <updated>2017-05-16T07:01:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 格式化字符串时，Python使用一个字符串作为模板。模板中有格式符，这些格式符为真实值预留位置，并说明真实数值应该呈现的格式。Python用一个 tuple 或者 字典 将多个值传递给模板，每个值对应一个格式符。 </em></strong><br><a id="more"></a></p><hr><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;I&apos;m %s. I&apos;m %d year old&quot; % (&apos;MicLee&apos;, 30))</span><br><span class="line"></span><br><span class="line">print(&quot;I&apos;m %(name)s. I&apos;m %(age)d year old&quot; % &#123;&apos;name&apos;:&apos;MicLee&apos;, &apos;age&apos;:30&#125;)</span><br></pre></td></tr></table></figure><h2 id="格式符"><a href="#格式符" class="headerlink" title="格式符"></a>格式符</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">%</span><span class="bash">s    字符串 (采用str()的显示)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">r    字符串 (采用repr()的显示)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">c    单个字符</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">b    二进制整数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">d    十进制整数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">i    十进制整数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">o    八进制整数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">x    十六进制整数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">e    指数 (基底写为e)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">E    指数 (基底写为E)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">f    浮点数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">F    浮点数，与上相同</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">g    指数(e)或浮点数 (根据显示长度)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">G    指数(E)或浮点数 (根据显示长度)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">%    字符<span class="string">"%"</span></span></span><br></pre></td></tr></table></figure><h2 id="高级格式符"><a href="#高级格式符" class="headerlink" title="高级格式符"></a>高级格式符</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[<span class="string">(name)</span>][<span class="symbol">flags</span>][<span class="string">width</span>].[precision]typecode</span><br></pre></td></tr></table></figure><p>(name)为命名</p><p>flags可以有+,-,’ ‘或0。+表示右对齐。-表示左对齐。’ ‘为一个空格，表示在正数的左侧填充一个空格，从而与负数对齐。0表示使用0填充。</p><p>width表示显示宽度</p><p>precision表示小数点后精度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&quot;%+10x&quot; % 10)</span><br><span class="line">        +a</span><br><span class="line">&gt;&gt;&gt; print(&quot;%04d&quot; % 5)</span><br><span class="line">0005</span><br><span class="line">&gt;&gt;&gt; print(&quot;%6.3f&quot; % 2.3)</span><br><span class="line"> 2.300</span><br></pre></td></tr></table></figure><p>上面的width, precision为两个整数。我们可以利用*，来动态代入这两个量。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&quot;%.*f&quot; % (4, 1.2))</span><br><span class="line">1.2000</span><br></pre></td></tr></table></figure><p>Python实际上用4来替换*，所以实际的模板为”%.4f”。</p><h2 id="r和-s的区别"><a href="#r和-s的区别" class="headerlink" title="%r和%s的区别"></a>%r和%s的区别</h2><p>%r用rper()方法处理对象<br>%s用str()方法处理对象</p><p>有些情况下，两者处理的结果是一样的，比如int型对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&quot;I&apos;m %s year old&quot; % 30)</span><br><span class="line">I&apos;m 30 year old</span><br><span class="line">&gt;&gt;&gt; print(&quot;I&apos;m %r year old&quot; % 30)</span><br><span class="line">I&apos;m 30 year old</span><br></pre></td></tr></table></figure></p><p>有些情况下是不一样的，比如str对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&quot;I&apos;m %s.&quot; % &apos;MicLee&apos;)</span><br><span class="line">I&apos;m MicLee.</span><br><span class="line">&gt;&gt;&gt; print(&quot;I&apos;m %r.&quot; % &apos;MicLee&apos;)</span><br><span class="line">I&apos;m &apos;MicLee&apos;.</span><br></pre></td></tr></table></figure></p><p>还有一种情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import datetime</span><br><span class="line">&gt;&gt;&gt; d = datetime.date.today()</span><br><span class="line">&gt;&gt;&gt; str(d)</span><br><span class="line">&apos;2011-05-14&apos;</span><br><span class="line">&gt;&gt;&gt; repr(d)</span><br><span class="line">&apos;datetime.date(2011, 5, 14)&apos;</span><br></pre></td></tr></table></figure></p><p>%r(也就是repr()方法)打印时能够重现它所代表的对象</p>]]></content>
    
    <summary type="html">
    
      格式化字符串时，Python使用一个字符串作为模板。模板中有格式符，这些格式符为真实值预留位置，并说明真实数值应该呈现的格式。Python用一个 tuple 或者 字典 将多个值传递给模板，每个值对应一个格式符。
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>SQLAlchemy</title>
    <link href="http://miclee.site/2017/05/16/SQLAlchemy/"/>
    <id>http://miclee.site/2017/05/16/SQLAlchemy/</id>
    <published>2017-05-16T06:10:26.000Z</published>
    <updated>2017-05-16T08:23:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 在上一章对比了Python几款ORM框架，决定在我的项目里使用SQLAlchemy，这里简单介绍下SQLAlchemy的使用。 </em></strong><br><a id="more"></a></p><hr><h2 id="一、单独使用SQLAlchemy"><a href="#一、单独使用SQLAlchemy" class="headerlink" title="一、单独使用SQLAlchemy"></a>一、单独使用SQLAlchemy</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1) 安装"></a>1) 安装</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">workon py3</span><br><span class="line">pip <span class="keyword">install</span> sqlalchemy</span><br></pre></td></tr></table></figure><h3 id="2-初始化DBSession"><a href="#2-初始化DBSession" class="headerlink" title="2) 初始化DBSession"></a>2) 初始化DBSession</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from sqlalchemy import Column, String, create_engine  </span><br><span class="line">from sqlalchemy.orm import sessionmaker  </span><br><span class="line">from sqlalchemy.ext.declarative import declarative_base  </span><br><span class="line"></span><br><span class="line"># 创建对象的基类:  </span><br><span class="line">Base = declarative_base()  </span><br><span class="line"></span><br><span class="line"># 定义User对象:  </span><br><span class="line">class User(Base):  </span><br><span class="line">    # 表的名字:  </span><br><span class="line">    __tablename__ = &apos;user&apos;  </span><br><span class="line"></span><br><span class="line">    # 表的结构:  </span><br><span class="line">    id = Column(String(20), primary_key=True)  </span><br><span class="line">    name = Column(String(20))  </span><br><span class="line"></span><br><span class="line"># 初始化数据库连接:  </span><br><span class="line"># &apos;数据库类型+数据库驱动名称://用户名:口令@机器地址:端口号/数据库名&apos;  </span><br><span class="line">engine = create_engine(&apos;mysql+mysqlconnector://root:root@localhost:3306/test&apos;)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 创建DBSession类型:  </span><br><span class="line">DBSession = sessionmaker(bind=engine)</span><br></pre></td></tr></table></figure><h3 id="3-添加一行记录"><a href="#3-添加一行记录" class="headerlink" title="3) 添加一行记录"></a>3) 添加一行记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 创建session对象:  </span><br><span class="line">session = DBSession()  </span><br><span class="line"># 创建新User对象:  </span><br><span class="line">new_user = User(id=&apos;5&apos;, name=&apos;Bob&apos;)  </span><br><span class="line"># 添加到session:  </span><br><span class="line">session.add(new_user)  </span><br><span class="line"># 提交即保存到数据库:  </span><br><span class="line">session.commit()  </span><br><span class="line"># 关闭session:  </span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure><h3 id="4-查询数据"><a href="#4-查询数据" class="headerlink" title="4) 查询数据"></a>4) 查询数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 创建Session:  </span><br><span class="line">session = DBSession()  </span><br><span class="line"># 创建Query查询，filter是where条件，最后调用one()返回唯一行，如果调用all()则返回所有行:  </span><br><span class="line">user = session.query(User).filter(User.id==&apos;5&apos;).one()  </span><br><span class="line"># 打印类型和对象的name属性:  </span><br><span class="line">print &apos;type:&apos;, type(user)  </span><br><span class="line">print &apos;name:&apos;, user.name  </span><br><span class="line"># 关闭Session:  </span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure><h3 id="5-创建一个一对多的关系"><a href="#5-创建一个一对多的关系" class="headerlink" title="5) 创建一个一对多的关系"></a>5) 创建一个一对多的关系</h3><p>一个人有多本书：当我们查询一个User对象时，该对象的books属性将返回一个包含若干个Book对象的list。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class User(Base):  </span><br><span class="line">    __tablename__ = &apos;user&apos;  </span><br><span class="line"></span><br><span class="line">    id = Column(String(20), primary_key=True)  </span><br><span class="line">    name = Column(String(20))  </span><br><span class="line">    # 一对多:  </span><br><span class="line">    books = relationship(&apos;Book&apos;)  </span><br><span class="line"></span><br><span class="line">class Book(Base):  </span><br><span class="line">    __tablename__ = &apos;book&apos;  </span><br><span class="line"></span><br><span class="line">    id = Column(String(20), primary_key=True)  </span><br><span class="line">    name = Column(String(20))  </span><br><span class="line">    # “多”的一方的book表是通过外键关联到user表的:  </span><br><span class="line">    user_id = Column(String(20), ForeignKey(&apos;user.id&apos;))</span><br></pre></td></tr></table></figure><h2 id="二、Flask-SQLAlchemy"><a href="#二、Flask-SQLAlchemy" class="headerlink" title="二、Flask-SQLAlchemy"></a>二、Flask-SQLAlchemy</h2><p>常见情况下对于只有一个 Flask 应用，所有您需要做的事情就是创建 Flask 应用，选择加载配置接着创建 SQLAlchemy 对象时候把 Flask 应用传递给它作为参数。</p><p>一旦创建，这个对象就包含 sqlalchemy 和 sqlalchemy.orm 中的所有函数和助手。此外它还提供一个名为 Model 的类，用于作为声明模型时的 delarative 基类:</p><h3 id="1）安装"><a href="#1）安装" class="headerlink" title="1）安装"></a>1）安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">workon py3</span><br><span class="line">pip install Flask-SQLAlchemy</span><br></pre></td></tr></table></figure><p>会附带安装 SQLAlchemy</p><h3 id="2）初始化"><a href="#2）初始化" class="headerlink" title="2）初始化"></a>2）初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># myapp.py</span><br><span class="line">from flask import Flask</span><br><span class="line">from flask.ext.sqlalchemy import SQLAlchemy</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[&apos;SQLALCHEMY_DATABASE_URI&apos;] = &apos;mysql://username:password@server/db&apos;</span><br><span class="line">db = SQLAlchemy(app)</span><br><span class="line"></span><br><span class="line"># 有一些部分在 SQLAlchemy 上是必选的，但是在 Flask-SQLAlchemy 上是可选的。 比如表名是自动地为您设置好的，除非您想要覆盖它。它是从转成小写的类名派生出来的，即 “CamelCase” 转换为 “camel_case”。</span><br><span class="line">class User(db.Model):</span><br><span class="line">    id = db.Column(db.Integer, primary_key=True)</span><br><span class="line">    username = db.Column(db.String(80), unique=True)</span><br><span class="line">    email = db.Column(db.String(120), unique=True)</span><br><span class="line"></span><br><span class="line">    def __init__(self, username, email):</span><br><span class="line">        self.username = username</span><br><span class="line">        self.email = email</span><br><span class="line"></span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &apos;&lt;User %r&gt;&apos; % self.username</span><br></pre></td></tr></table></figure><p><strong>常用类型：</strong></p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>Integer</td><td>一个整数</td></tr><tr><td>String(size)</td><td>有长度限制的字符串</td></tr><tr><td>Text</td><td>一些较长的 unicode 文本</td></tr><tr><td>DateTime</td><td>表示为 Python datetime 对象的 时间和日期</td></tr><tr><td>Float</td><td>存储浮点值</td></tr><tr><td>Boolean</td><td>存储布尔值</td></tr><tr><td>PickleType</td><td>存储为一个持久化的 Python 对象</td></tr><tr><td>LargeBinary</td><td>存储一个任意大的二进制数据</td></tr></tbody></table><h3 id="3）添加一行记录"><a href="#3）添加一行记录" class="headerlink" title="3）添加一行记录"></a>3）添加一行记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from myapp import User</span><br><span class="line"></span><br><span class="line">admin = User(&apos;admin&apos;, &apos;admin@example.com&apos;)</span><br><span class="line">guest = User(&apos;guest&apos;, &apos;guest@example.com&apos;)</span><br><span class="line"></span><br><span class="line">db.session.add(admin)</span><br><span class="line">db.session.add(guest)</span><br><span class="line">db.session.commit()</span><br><span class="line"># 没有必要在每个请求后关闭它(session)，Flask-SQLAlchemy 会帮您完成关闭操作。</span><br></pre></td></tr></table></figure><h3 id="4）查询记录"><a href="#4）查询记录" class="headerlink" title="4）查询记录"></a>4）查询记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from myapp import User</span><br><span class="line"></span><br><span class="line">users = User.query.all()</span><br><span class="line">print(users)</span><br><span class="line"># [&lt;User u&apos;admin&apos;&gt;, &lt;User u&apos;guest&apos;&gt;]</span><br><span class="line"></span><br><span class="line">admin = User.query.filter_by(username=&apos;admin&apos;).first()</span><br><span class="line">print(admin)</span><br><span class="line"># &lt;User u&apos;admin&apos;&gt;</span><br></pre></td></tr></table></figure><p><strong>更多用法参考：</strong> <a href="http://www.pythondoc.com/flask-sqlalchemy/quickstart.html#id2" target="_blank" rel="noopener">Flask-SQLAlchemy 快速入门</a></p>]]></content>
    
    <summary type="html">
    
      在上一章对比了Python几款ORM框架，决定在我的项目里使用SQLAlchemy，这里简单介绍下SQLAlchemy的使用。
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python ORM 框架对比</title>
    <link href="http://miclee.site/2017/05/16/python-orm/"/>
    <id>http://miclee.site/2017/05/16/python-orm/</id>
    <published>2017-05-16T05:52:19.000Z</published>
    <updated>2017-05-17T03:42:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> ORM技术 - Object-Relational Mapping, 把关系数据库的表结构映射到对象上。本篇对比Python几个流行的可选 ORM 库。 </em></strong><br><a id="more"></a></p><hr><h2 id="SQLObject"><a href="#SQLObject" class="headerlink" title="SQLObject"></a>SQLObject</h2><p><strong>优点：</strong>  </p><ul><li>采用了易懂的ActiveRecord 模式；  </li><li>一个相对较小的代码库；</li></ul><p><strong>缺点：</strong>  </p><ul><li>方法和类的命名遵循了Java 的小驼峰风格；  </li><li>不支持数据库session隔离工作单元；</li></ul><h2 id="Storm"><a href="#Storm" class="headerlink" title="Storm"></a>Storm</h2><p><strong>优点：</strong>  </p><ul><li>清爽轻量的API，短学习曲线和长期可维护性；  </li><li>不需要特殊的类构造函数，也没有必要的基类；</li></ul><p><strong>缺点：</strong>  </p><ul><li>迫使程序员手工写表格创建的DDL语句，而不是从模型类自动派生；  </li><li>Storm的贡献者必须把他们的贡献的版权给Canonical公司；  </li></ul><h2 id="Django’s-ORM"><a href="#Django’s-ORM" class="headerlink" title="Django’s ORM"></a>Django’s ORM</h2><p><strong>优点：</strong>  </p><ul><li>易用，学习曲线短；  </li><li>和Django紧密集合，用Django时使用约定俗成的方法去操作数据库；</li></ul><p><strong>缺点：</strong>  </p><ul><li>不好处理复杂的查询，强制开发者回到原生SQL;  </li><li>紧密和Django集成，使得在Django环境外很难使用;</li></ul><h2 id="peewee"><a href="#peewee" class="headerlink" title="peewee"></a>peewee</h2><p><strong>优点：</strong>  </p><ul><li>Django式的API，使其易用;  </li><li>轻量实现，很容易和任意web框架集成;</li></ul><p><strong>缺点：</strong>  </p><ul><li>不支持自动化 schema 迁移;  </li><li>多对多查询写起来不直观;</li></ul><h2 id="SQLAlchemy"><a href="#SQLAlchemy" class="headerlink" title="SQLAlchemy"></a>SQLAlchemy</h2><p><strong>优点：</strong>  </p><ul><li>企业级 API，使得代码有健壮性和适应性;  </li><li>灵活的设计，使得能轻松写复杂查询;</li></ul><p><strong>缺点：</strong>  </p><ul><li>工作单元概念不常;  </li><li>重量级 API，导致长学习曲线;</li></ul>]]></content>
    
    <summary type="html">
    
      ORM技术 - Object-Relational Mapping, 把关系数据库的表结构映射到对象上。本篇对比Python几个流行的可选 ORM 库。
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>RESTful API 设计指南【转】</title>
    <link href="http://miclee.site/2017/05/15/restful-api/"/>
    <id>http://miclee.site/2017/05/15/restful-api/</id>
    <published>2017-05-15T06:40:15.000Z</published>
    <updated>2017-05-15T06:55:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 网络应用程序，分为前端和后端两个部分。当前的发展趋势，就是前端设备层出不穷（手机、平板、桌面电脑、其他专用设备......）。因此，必须有一种统一的机制，方便不同的前端设备与后端进行通信。这导致API构架的流行，甚至出现"API First"的设计思想。RESTful API是目前比较成熟的一套互联网应用程序的API设计理论。 </em></strong><br><a id="more"></a></p><hr><p>我以前写过一篇《理解RESTful架构》，探讨如何理解这个概念。<br>今天，我将介绍RESTful API的设计细节，探讨如何设计一套合理、好用的API。我的主要参考了两篇文章（<a href="https://codeplanet.io/principles-good-restful-api-design/" target="_blank" rel="noopener">1</a>，<a href="https://bourgeois.me/rest/" target="_blank" rel="noopener">2</a>）。</p><h2 id="一、协议"><a href="#一、协议" class="headerlink" title="一、协议"></a>一、协议</h2><p>API与用户的通信协议，总是使用  <a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">HTTPs</a> 协议。  </p><h2 id="二、域名"><a href="#二、域名" class="headerlink" title="二、域名"></a>二、域名</h2><p>应该尽量将API部署在专用域名之下。<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span><span class="comment">//api.example.com</span></span><br></pre></td></tr></table></figure></p><p>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span>//example<span class="meta">.org</span>/api/</span><br></pre></td></tr></table></figure></p><h2 id="三、版本（Versioning）"><a href="#三、版本（Versioning）" class="headerlink" title="三、版本（Versioning）"></a>三、版本（Versioning）</h2><p>应该将API的版本号放入URL。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>api.example.com<span class="regexp">/v1/</span></span><br></pre></td></tr></table></figure><p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。</p><h2 id="四、路径（Endpoint）"><a href="#四、路径（Endpoint）" class="headerlink" title="四、路径（Endpoint）"></a>四、路径（Endpoint）</h2><p>路径又称”终点”（endpoint），表示API的具体网址。<br>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。<br>举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>api.example.com<span class="regexp">/v1/</span>zoos</span><br><span class="line">https:<span class="regexp">//</span>api.example.com<span class="regexp">/v1/</span>animals</span><br><span class="line">https:<span class="regexp">//</span>api.example.com<span class="regexp">/v1/</span>employees</span><br></pre></td></tr></table></figure><h2 id="五、HTTP动词"><a href="#五、HTTP动词" class="headerlink" title="五、HTTP动词"></a>五、HTTP动词</h2><p>对于资源的具体操作类型，由HTTP动词表示。<br>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET（<span class="keyword">SELECT</span>）：从服务器取出资源（一项或多项）。</span><br><span class="line">POST（<span class="keyword">CREATE</span>）：在服务器新建一个资源。</span><br><span class="line">PUT（<span class="keyword">UPDATE</span>）：在服务器更新资源（客户端提供改变后的完整资源）。</span><br><span class="line"><span class="keyword">PATCH</span>（<span class="keyword">UPDATE</span>）：在服务器更新资源（客户端提供改变的属性）。</span><br><span class="line"><span class="keyword">DELETE</span>（<span class="keyword">DELETE</span>）：从服务器删除资源。</span><br></pre></td></tr></table></figure><p>还有两个不常用的HTTP动词。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HEAD：获取资源的元数据。</span><br><span class="line">OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</span><br><span class="line">下面是一些例子。</span><br><span class="line">GET <span class="string">/zoos</span>：列出所有动物园</span><br><span class="line">POST <span class="string">/zoos</span>：新建一个动物园</span><br><span class="line">GET <span class="string">/zoos/ID</span>：获取某个指定动物园的信息</span><br><span class="line">PUT <span class="string">/zoos/ID</span>：更新某个指定动物园的信息（提供该动物园的全部信息）</span><br><span class="line">PATCH <span class="string">/zoos/ID</span>：更新某个指定动物园的信息（提供该动物园的部分信息）</span><br><span class="line">DELETE <span class="string">/zoos/ID</span>：删除某个动物园</span><br><span class="line">GET <span class="string">/zoos/ID/animals</span>：列出某个指定动物园的所有动物</span><br><span class="line">DELETE <span class="string">/zoos/ID/animals/ID</span>：删除某个指定动物园的指定动物</span><br></pre></td></tr></table></figure><h2 id="六、过滤信息（Filtering）"><a href="#六、过滤信息（Filtering）" class="headerlink" title="六、过滤信息（Filtering）"></a>六、过滤信息（Filtering）</h2><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。<br>下面是一些常见的参数。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?<span class="attribute">limit</span>=10：指定返回记录的数量</span><br><span class="line">?<span class="attribute">offset</span>=10：指定返回记录的开始位置。</span><br><span class="line">?<span class="attribute">page</span>=2&amp;per_page=100：指定第几页，以及每页的记录数。</span><br><span class="line">?<span class="attribute">sortby</span>=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</span><br><span class="line">?<span class="attribute">animal_type_id</span>=1：指定筛选条件</span><br></pre></td></tr></table></figure><p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p><h2 id="七、状态码（Status-Codes）"><a href="#七、状态码（Status-Codes）" class="headerlink" title="七、状态码（Status Codes）"></a>七、状态码（Status Codes）</h2><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">200 </span>OK - [<span class="keyword">GET</span>]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</span><br><span class="line"><span class="symbol">201 </span>CREATED - [POST/<span class="keyword">PUT</span>/PATCH]：用户新建或修改数据成功。</span><br><span class="line"><span class="symbol">202 </span>Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</span><br><span class="line"><span class="symbol">204 </span>NO CONTENT - [<span class="keyword">DELETE</span>]：用户删除数据成功。</span><br><span class="line"><span class="symbol">400 </span>INVALID REQUEST - [POST/<span class="keyword">PUT</span>/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</span><br><span class="line"><span class="symbol">401 </span>Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</span><br><span class="line"><span class="symbol">403 </span>Forbidden - [*] 表示用户得到授权（与<span class="number">401</span>错误相对），但是访问是被禁止的。</span><br><span class="line"><span class="symbol">404 </span><span class="keyword">NOT</span> FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</span><br><span class="line"><span class="symbol">406 </span><span class="keyword">Not</span> Acceptable - [<span class="keyword">GET</span>]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</span><br><span class="line"><span class="symbol">410 </span>Gone -[<span class="keyword">GET</span>]：用户请求的资源被永久删除，且不会再得到的。</span><br><span class="line"><span class="symbol">422 </span>Unprocesable entity - [POST/<span class="keyword">PUT</span>/PATCH] 当创建一个对象时，发生一个验证错误。</span><br><span class="line"><span class="symbol">500 </span>INTERNAL SERVER <span class="keyword">ERROR</span> - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</span><br></pre></td></tr></table></figure><p>状态码的完全列表参见<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html" target="_blank" rel="noopener">这里</a>。</p><h2 id="八、错误处理（Error-handling）"><a href="#八、错误处理（Error-handling）" class="headerlink" title="八、错误处理（Error handling）"></a>八、错误处理（Error handling）</h2><p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">error</span>: <span class="string">"Invalid API key"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="九、返回结果"><a href="#九、返回结果" class="headerlink" title="九、返回结果"></a>九、返回结果</h2><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET <span class="string">/collection</span>：返回资源对象的列表（数组）</span><br><span class="line">GET <span class="string">/collection/resource</span>：返回单个资源对象</span><br><span class="line">POST <span class="string">/collection</span>：返回新生成的资源对象</span><br><span class="line">PUT <span class="string">/collection/resource</span>：返回完整的资源对象</span><br><span class="line">PATCH <span class="string">/collection/resource</span>：返回完整的资源对象</span><br><span class="line">DELETE <span class="string">/collection/resource</span>：返回一个空文档</span><br></pre></td></tr></table></figure><h2 id="十、Hypermedia-API"><a href="#十、Hypermedia-API" class="headerlink" title="十、Hypermedia API"></a>十、Hypermedia API</h2><p>RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。<br>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"link"</span>: &#123;</span><br><span class="line">  <span class="attr">"rel"</span>:   <span class="string">"collection https://www.example.com/zoos"</span>,</span><br><span class="line">  <span class="attr">"href"</span>:  <span class="string">"https://api.example.com/zoos"</span>,</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"List of zoos"</span>,</span><br><span class="line">  <span class="attr">"type"</span>:  <span class="string">"application/vnd.yourformat+json"</span></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。<br>Hypermedia API的设计被称为HATEOAS。Github的API就是这种设计，访问api.github.com会得到一个所有可用API的网址列表。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"current_user_url"</span>: <span class="string">"https://api.github.com/user"</span>,</span><br><span class="line">  <span class="string">"authorizations_url"</span>: <span class="string">"https://api.github.com/authorizations"</span>,</span><br><span class="line">  <span class="string">//</span> <span class="string">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看到，如果想获取当前用户的信息，应该去访问api.github.com/user，然后就得到了下面结果。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"message"</span>: <span class="string">"Requires authentication"</span>,</span><br><span class="line">  <span class="attr">"documentation_url"</span>: <span class="string">"https://developer.github.com/v3"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码表示，服务器给出了提示信息，以及文档的网址。</p><h2 id="十一、其他"><a href="#十一、其他" class="headerlink" title="十一、其他"></a>十一、其他</h2><p>（1）API的身份认证应该使用OAuth 2.0框架。<br>（2）服务器返回的数据格式，应该尽量使用JSON，避免使用XML。</p><hr><p><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">【原文链接】</a></p>]]></content>
    
    <summary type="html">
    
      网络应用程序，分为前端和后端两个部分。当前的发展趋势，就是前端设备层出不穷（手机、平板、桌面电脑、其他专用设备......）。因此，必须有一种统一的机制，方便不同的前端设备与后端进行通信。这导致API构架的流行，甚至出现&quot;API First&quot;的设计思想。RESTful API是目前比较成熟的一套互联网应用程序的API设计理论。
    
    </summary>
    
      <category term="Http" scheme="http://miclee.site/categories/Http/"/>
    
    
      <category term="Http" scheme="http://miclee.site/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>Python Web 框架一览</title>
    <link href="http://miclee.site/2017/05/15/Python-Web%E6%A1%86%E6%9E%B6%E4%B8%80%E8%A7%88/"/>
    <id>http://miclee.site/2017/05/15/Python-Web框架一览/</id>
    <published>2017-05-15T03:03:05.000Z</published>
    <updated>2017-05-15T05:39:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> Python 有许多 web 框架可以供你选择。网上甚至还有教你怎么制作自己专属的框架的教程，因为这实在是太容易了。然后就导致了现在框架的质量参差不齐。我们来对这些框架做一个概述然后你可以挑出自己喜欢的。 </em></strong><br><a id="more"></a></p><hr><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们经常谈到的 python web 框架有这些：</p><table><thead><tr><th>名字</th><th>版本</th><th>最后更新</th><th>诞生时间</th><th>代码行数</th></tr></thead><tbody><tr><td>Django</td><td>1.3.1</td><td>2011-09-09</td><td>2005</td><td>115759</td></tr><tr><td>Flask</td><td>0.8</td><td>2011-09-29</td><td>2010</td><td>4681</td></tr><tr><td>Bottle</td><td>0.10.9</td><td>2012-02-11</td><td>2009</td><td>4634</td></tr><tr><td>Tornado</td><td>2.2</td><td>2012-01-30</td><td>2009</td><td>11701</td></tr><tr><td>Cherry.py</td><td>3.2.2</td><td>2011-10-19</td><td>2002</td><td>18828</td></tr><tr><td>web.py</td><td>0.36</td><td>2011-07-04</td><td>2006</td><td>7398</td></tr><tr><td>Brubeck</td><td>0.3.7</td><td>2011-12-20</td><td>011</td><td>1525</td></tr></tbody></table><p>注释1：加上 Brubeck 是因为我认为我们可以从这个框架身上学到很多，虽然这个框架已经不是 Python 框架了。</p><p>注释2：还有许多其他的框架比如说 Zope， Pylons， Pyramid － 我之所以没有写它们是因为我对它们没有经验。</p><p>注释3：如果 Flask 的代码加上 Werkzeug 和 Jinja2 的话一共约 35000 行。</p><p>注释4：代码行数意思是实际的 Python 代码。使用 CLOC 计数。</p><h2 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h2><p>这可能是最广为人知和使用最广泛的 Python web 框架了。我承认它确实非常强大。Django 有世界上最大的社区，最多的包，可以说只有你想不到的，没有它做不到的。它的文档非常完善，但是有的比较冷门的知识你还是需要去 StackOverflow 咨询一下。</p><p>Django 在配置上面遵循惯例，这样对于初学者来说比较容易，而且在比较复杂的应用上也有一定的灵活性。Django 致力于快速开发以及简洁实用的设计。</p><p>Django 只需要这么 几行代码 就可以实现一个“Hello World！”程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">from django.conf.urls.defaults import patterns</span><br><span class="line">from django.http import HttpResponse</span><br><span class="line">filepath, extension = os.path.splitext(__file__)</span><br><span class="line">ROOT_URLCONF = os.path.basename(filepath)</span><br><span class="line"></span><br><span class="line">def hello(request):</span><br><span class="line">    return HttpResponse(&apos;Hello World!&apos;)</span><br><span class="line"></span><br><span class="line">urlpatterns = patterns(&apos;&apos;, (r&apos;^/$&apos;, hello))</span><br></pre></td></tr></table></figure></p><p>关于 Django 我不喜欢的一点就是它有点儿被焊死的感觉。不要尝试着去改变它，否则你会碰壁的。我来解释一下这个说法：比如说我想要使用 SQLAlchemy 作为 ORM 然后 SQLAlchemy 就会把 Admin， Auth， Form 等等几乎所有的部分都给搞砸。所以你最好使用它附带的工具包。</p><p>快速教程： <a href="https://www.djangoproject.com/" target="_blank" rel="noopener">Django</a></p><p>它们都基于 Django： Disqus ， EveryBlock ， Guardian (newspaper) ， Firefox add-ons (Mozilla)</p><h2 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h2><p>这个灵巧的框架是由 Armin Ronacher 创造的。它的名字暗示了它的含义，它基本上就是一个微型的胶水框架。它把 Werkzeug 和 Jinja 粘合在了一起。所以它很容易被扩展。</p><p>Flask 也有许多的 扩展 可以供你使用，Flask 也有一群忠诚的粉丝和不断增加的用户群。它有一份很完善的文档，甚至还有一份唾手可得的常见范例。Flask 很容易使用，你只需要 3(7) 行代码就可以写出来一个 Hello World。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;)</span><br><span class="line">def hello():</span><br><span class="line">    return &quot;Hello World!&quot;</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure></p><p>我觉得这是它最大的优点也是缺点 － Flask 并不强制一个特定的 ORM。这会使得写扩展有点儿困难，你可能会想用某种形式的数据库层，但是用哪一个呢？Python 有非常多可以选择的。这个 Blog 是用 Flask 写的，部署在 Google App Engine 上。这很容易因为 Google Datastore 和其他的不太一样。所以有时候不强制一个 ORM 也是好事儿。</p><p>如果你想建一个新站的话 Flask 是个非常不错的选择。但我并不会向所有的初学者都推荐 Flask，我指的是那些不关心“为什么可以”，只关心它们“可不可以”的初学者。</p><p>快速教程： <a href="http://flask.pocoo.org/docs/0.12/quickstart/" target="_blank" rel="noopener">Flask quickstart</a></p><p>它们都基于 Flask： Dev news aggregator for Battlefield3 ， Media Queries ， Learn buffet ， Konstruktor (appengine)</p><h2 id="Bottle"><a href="#Bottle" class="headerlink" title="Bottle"></a>Bottle</h2><p>这个框架相对来说比较新。它受到了 Sinatra 的影响。Bottle 才是名副其实的微框架 － 它只有大约 4500 行代码。并且我认为这是最真实的基于 Python 的微框架，它除了 Python 标准库以外没有任何其它的依赖，甚至它还有自己独特的一点儿模版语言。Bottle 还是为数不多的支持 Python 3 的框架之一。</p><p>Bottle 的文档很详细并且抓住了事物的实质。Hello World 例子很像 Flask，也使用了装饰器来定义路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from bottle import route, run</span><br><span class="line"></span><br><span class="line">@route(&apos;/hello/:name&apos;)</span><br><span class="line">def hello(name):</span><br><span class="line">    return &apos;&lt;h1&gt;Hello %s!&lt;/h1&gt;&apos; % name.title()</span><br><span class="line"></span><br><span class="line">run(host=&apos;localhost&apos;, port=8080)</span><br></pre></td></tr></table></figure><p>我知道 Bottle 内部有一座桥梁来沟通各个部分，因为它只有一个文件。但是很难找到你想要的东西，它的代码散布的到处都是，看起来一团糟。</p><p>对于非常小的项目或者是实验性的项目来说，Bottle 是一个不错的选择。但是对于一些大型的项目来说最好就不要使用它了，因为它的扩展并不多。</p><p>快速教程： <a href="http://bottlepy.org/docs/dev/tutorial.html" target="_blank" rel="noopener">Bottle tutorial</a></p><p>它们都基于 Bottle： Plush (monitoring) ， Hobo (Blog enginee)</p><h2 id="web-py"><a href="#web-py" class="headerlink" title="web.py"></a>web.py</h2><p>以前 web.py 还很流行的时候被用来写 reddit。它能很好的处理流量问题。如果你用 web.py 开发 web 应用的话，你会发现它并不会阻碍你。 标准配置 很简单也很直观。web.py 在文件和文件夹的分类上面也做的非常棒。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import web</span><br><span class="line"></span><br><span class="line">urls = (&apos;/(.*)&apos;, &apos;hello&apos;)</span><br><span class="line">app = web.application(urls, globals())</span><br><span class="line"></span><br><span class="line">class hello:</span><br><span class="line">    def GET(self):</span><br><span class="line">        return &apos;Hello, World!&apos;</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure></p><p>很遗憾的是这个库最近已经成为了 rails 框架狂热者的受害者。它有可以帮你做几乎所有事情的自己的库 － 模版，表格，数据库。可能它们并不像其它库一样得到了良好的维护，但是还是有许多人在用它。</p><p>快速教程： <a href="http://webpy.org/" target="_blank" rel="noopener">web.py</a></p><p>它们基于 web.py： Yandex (russian search engine) ， Telephone directory (Switzerland)</p><h2 id="Tornado"><a href="#Tornado" class="headerlink" title="Tornado"></a>Tornado</h2><p>Tornado 不单单是个框架，还是个 web 服务器。它一开始是给 FriendFeed 开发的，后来在 2009 年的时候也给 Facebook 使用。它是为了解决实时服务而诞生的。为了做到这一点，Tornado 使用了异步非阻塞 IO。</p><p>Tornado 的文档非常技术性。它并不是为初学者准备的。这是一个 Hello World 程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import tornado.ioloop</span><br><span class="line">import tornado.web</span><br><span class="line"></span><br><span class="line">class MainHandler(tornado.web.RequestHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        self.write(&quot;Hello, world&quot;)</span><br><span class="line"></span><br><span class="line">application = tornado.web.Application([</span><br><span class="line">    (r&quot;/&quot;, MainHandler),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    application.listen(8888)</span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br></pre></td></tr></table></figure></p><p>默认情况下 Tornado 会传递 WSGI 层，因为 WSGI 并不能处理异步请求。Tornado 确实性能非常强，但是当调用数据库的时候它会阻塞 IO。</p><p>快速教程： <a href="http://www.tornadoweb.org/en/stable/" target="_blank" rel="noopener">Tornado</a></p><p>它们基于 Tornado： Too cool for me ， FriendFeed</p><h2 id="CherryPy"><a href="#CherryPy" class="headerlink" title="CherryPy"></a>CherryPy</h2><p>这是最古老的 Python 框架的一种。CherryPy 并没有得到广泛的应用，大家提到它第一反应是 web 服务器然后才是一个框架。在处理请求方面 CherryPy 也使用了队列来优化性能，但是它使用的是 线程池 技术。</p><p>CherryPy 的文档实际上非常少，但是基本上都可以涵盖主要的方面。CherryPy 也可以支持 Python 3。我必须说，它的 Hello World 例子非常漂亮：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import cherrypy</span><br><span class="line">class HelloWorld(object):</span><br><span class="line">    def index(self):</span><br><span class="line">    return &quot;Hello World!&quot;</span><br><span class="line">    index.exposed = True</span><br><span class="line"></span><br><span class="line">cherrypy.quickstart(HelloWorld())</span><br></pre></td></tr></table></figure></p><p>快速教程： <a href="http://docs.cherrypy.org/en/latest/" target="_blank" rel="noopener">CherryPy</a></p><p>它们基于 CherryPy： YouGov ， Cuil search engine (ended 2010)</p><h2 id="Brubeck"><a href="#Brubeck" class="headerlink" title="Brubeck"></a>Brubeck</h2><p>这是一个新的 Python 框架。其并不使用 WSGI 而直接在语言级别用 Mongrel2 作为服务器使用，这个仅把请求处理交给 Python 程序，请求作为协同程序来处理。</p><p>模块方面 Brubeck 使用了 DictShield 库，意思就是对于不同的数据库插件都可以在其之上来进行操作。</p><p>Brubeck 的文档非常少，但是你看到源码以后，你会知道其实并没有多少东西。所以它还是一个非常年轻并且在不断发展的框架。Hello World 例子看起来也很漂亮。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class DemoHandler(WebMessageHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        self.set_body(&apos;Hello world&apos;)</span><br><span class="line">        return self.render()</span><br><span class="line"></span><br><span class="line">urls = [(r&apos;^/&apos;, DemoHandler)]</span><br><span class="line">mongrel2_pair = (&apos;ipc://127.0.0.1:9999&apos;, &apos;ipc://127.0.0.1:9998&apos;)</span><br><span class="line"></span><br><span class="line">app = Brubeck(mongrel2_pair=mongrel2_pair,</span><br><span class="line">          handler_tuples=urls)</span><br><span class="line">app.run()</span><br></pre></td></tr></table></figure></p><p>唯一需要注意的是当你使用 Brubeck 的时候你也需要看看 Mongrel2 服务器的相关知识。</p><p>快速教程： <a href="http://brubeck.io/" target="_blank" rel="noopener">Brubeck.io</a></p><p>它们基于 Brubeck： ListSurf</p>]]></content>
    
    <summary type="html">
    
      Python 有许多 web 框架可以供你选择。网上甚至还有教你怎么制作自己专属的框架的教程，因为这实在是太容易了。然后就导致了现在框架的质量参差不齐。我们来对这些框架做一个概述然后你可以挑出自己喜欢的。
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>人生苦短，我用Python【转】</title>
    <link href="http://miclee.site/2017/05/12/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8C%E6%88%91%E7%94%A8Python/"/>
    <id>http://miclee.site/2017/05/12/人生苦短，我用Python/</id>
    <published>2017-05-12T09:28:26.000Z</published>
    <updated>2017-05-15T05:38:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> Python语言的发展简史。 </em></strong><br><a id="more"></a></p><hr><p>Python是我喜欢的语言，简洁，优美，容易使用。前两天，我很激昂的向朋友宣传Python的好处。</p><p>“好吧，我承认Python不错，但它为什么叫Python呢？”<br>“呃，似乎是一个电视剧的名字。”<br>“那你说的Guido是美国人么？”<br>“他从Google换到Dropbox工作，但他的名字像是荷兰人的。”<br>“你确定你很熟悉Python吗？”</p><p>所以为了雪耻，我花时间调查了Python的历史。我看到了Python中许多功能的来源和Python的设计理念，看到了一门编程语言的演化历史，看到了Python与开源运动的奇妙联系。从Python的历史中，我们可以一窥开源开发的理念和成就。</p><p>这也可以作为我写的Python快速教程的序篇。</p><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>Python的作者，Guido von Rossum，确实是荷兰人。1982年，Guido从阿姆斯特丹大学获得了数学和计算机硕士学位。然而，尽管他算得上是一位数学家，但他更加享受计算机带来的乐趣。用他的话说，尽管拥有数学和计算机双料资质，他总趋向于做计算机相关的工作，并热衷于做任何和编程相关的活儿。</p><p>在那个时候，Guido接触并使用过诸如Pascal、C、 Fortran等语言。这些语言的基本设计原则是让机器能更快运行。在80年代，虽然IBM和苹果已经掀起了个人电脑浪潮，但这些个人电脑的配置很低。比如早期的Macintosh，只有8MHz的CPU主频和128KB的RAM，一个大的数组就能占满内存。所有的编译器的核心是做优化，以便让程序能够运行。为了增进效率，语言也迫使程序员像计算机一样思考，以便能写出更符合机器口味的程序。在那个时代，程序员恨不得用手榨取计算机每一寸的能力。有人甚至认为C语言的指针是在浪费内存。至于动态类型，内存自动管理，面向对象…… 别想了，那会让你的电脑陷入瘫痪。</p><p>这种编程方式让Guido感到苦恼。Guido知道如何用C语言写出一个功能，但整个编写过程需要耗费大量的时间，即使他已经准确的知道了如何实现。他的另一个选择是shell。Bourne Shell作为UNIX系统的解释器已经长期存在。UNIX的管理员们常常用shell去写一些简单的脚本，以进行一些系统维护的工作，比如定期备份、文件系统管理等等。shell可以像胶水一样，将UNIX下的许多功能连接在一起。许多C语言下上百行的程序，在shell下只用几行就可以完成。然而，shell的本质是调用命令。它并不是一个真正的语言。比如说，shell没有数值型的数据类型，加法运算都很复杂。总之，shell不能全面的调动计算机的功能。</p><p>Guido希望有一种语言，这种语言能够像C语言那样，能够全面调用计算机的功能接口，又可以像shell那样，可以轻松的编程。ABC语言让Guido看到希望。ABC是由荷兰的数学和计算机研究所开发的。Guido在该研究所工作，并参与到ABC语言的开发。ABC语言以教学为目的。与当时的大部分语言不同，ABC语言的目标是“让用户感觉更好”。ABC语言希望让语言变得容易阅读，容易使用，容易记忆，容易学习，并以此来激发人们学习编程的兴趣。比如下面是一段来自Wikipedia的ABC程序，这个程序用于统计文本中出现的词的总数：  </p><pre><code>HOW TO RETURN words document:    PUT {} IN collection    FOR line IN document:        FOR word IN split line:        IF word not.in collection:            INSERT word IN collection    RETURN collection</code></pre><p>HOW TO用于定义一个函数。一个Python程序员应该很容易理解这段程序。ABC语言使用冒号和缩进来表示程序块。行尾没有分号。for和if结构中也没有括号()。赋值采用的是PUT，而不是更常见的等号。这些改动让ABC程序读起来像一段文字。</p><p>尽管已经具备了良好的可读性和易用性，ABC语言最终没有流行起来。在当时，ABC语言编译器需要比较高配置的电脑才能运行。而这些电脑的使用者通常精通计算机，他们更多考虑程序的效率，而非它的学习难度。除了硬件上的困难外，ABC语言的设计也存在一些致命的问题：</p><ul><li><p>可拓展性差。ABC语言不是模块化语言。如果想在ABC语言中增加功能，比如对图形化的支持，就必须改动很多地方。</p></li><li><p>不能直接进行IO。ABC语言不能直接操作文件系统。尽管你可以通过诸如文本流的方式导入数据，但ABC无法直接读写文件。输入输出的困难对于计算机语言来说是致命的。你能想像一个打不开车门的跑车么？</p></li><li><p>过度革新。ABC用自然语言的方式来表达程序的意义，比如上面程序中的HOW TO 。然而对于程序员来说，他们更习惯用function或者define来定义一个函数。同样，程序员更习惯用等号来分配变量。尽管ABC语言很特别，但学习难度也很大。</p></li><li><p>传播困难。ABC编译器很大，必须被保存在磁带上。当时Guido在访问的时候，就必须有一个大磁带来给别人安装ABC编译器。 这样，ABC语言就很难快速传播。</p></li></ul><p>1989年，为了打发圣诞节假期，Guido开始写Python语言的编译器。Python这个名字，来自Guido所挚爱的电视剧Monty Python’s Flying Circus。他希望这个新的叫做Python的语言，能符合他的理想：创造一种C和shell之间，功能全面，易学易用，可拓展的语言。Guido作为一个语言设计爱好者，已经有过设计语言的尝试。这一次，也不过是一次纯粹的hacking行为。</p><h2 id="一门语言的诞生"><a href="#一门语言的诞生" class="headerlink" title="一门语言的诞生"></a>一门语言的诞生</h2><p>1991年，第一个Python编译器诞生。它是用C语言实现的，并能够调用C语言的库文件。从一出生，Python已经具有了：类，函数，异常处理，包含表和词典在内的核心数据类型，以及模块为基础的拓展系统。</p><p>Python语法很多来自C，但又受到ABC语言的强烈影响。来自ABC语言的一些规定直到今天还富有争议，比如强制缩进。但这些语法规定让Python容易读。另一方面，Python聪明的选择服从一些惯例，特别是C语言的惯例。比如使用等号赋值，使用def来定义函数。Guido认为，如果“常识”上确立的东西，没有必要过度纠结。</p><p>Python从一开始就特别在意可拓展性。Python可以在多个层次上拓展。从高层上，你可以直接引入.py文件。在底层，你可以引用C语言的库。Python程序员可以快速的使用Python写.py文件作为拓展模块。但当性能是考虑的重要因素时，Python程序员可以深入底层，写C程序，编译为.so文件引入到Python中使用。Python就好像是使用钢构建房一样，先规定好大的框架。而程序员可以在此框架下相当自由的拓展或更改。</p><p>最初的Python完全由Guido本人开发。Python得到Guido同事的欢迎。他们迅速的反馈使用意见，并参与到Python的改进。Guido和一些同事构成Python的核心团队。他们将自己大部分的业余时间用于hack Python。随后，Python拓展到研究所之外。Python将许多机器层面上的细节隐藏，交给编译器处理，并凸显出逻辑层面的编程思考。Python程序员可以花更多的时间用于思考程序的逻辑，而不是具体的实现细节。这一特征吸引了广大的程序员。Python开始流行。<br>人生苦短，我用python</p><p><img src="https://raw.githubusercontent.com/OfMicLee/img-hosting/master/python/001.jpg" alt=""></p><h2 id="时势造英雄"><a href="#时势造英雄" class="headerlink" title="时势造英雄"></a>时势造英雄</h2><p>我们不得不暂停我们的Python时间，转而看一看瞬息万变的计算机行业。1990年代初，个人计算机开始进入普通家庭。Intel发布了486处理器，windows发布window 3.0开始的一系列视窗系统。计算机的性能大大提高。程序员开始关注计算机的易用性  ，比如图形化界面。</p><p><img src="https://raw.githubusercontent.com/OfMicLee/img-hosting/master/python/002.png" alt=""></p><p>由于计算机性能的提高，软件的世界也开始随之改变。硬件足以满足许多个人电脑的需要。硬件厂商甚至渴望高需求软件的出现，以带动硬件的更新换代。C++和Java相继流行。C++和Java提供了面向对象的编程范式，以及丰富的对象库。在牺牲了一定的性能的代价下，C++和Java大大提高了程序的产量。语言的易用性被提到一个新的高度。我们还记得，ABC失败的一个重要原因是硬件的性能限制。从这方面说，Python要比ABC幸运许多。</p><p>另一个悄然发生的改变是Internet。1990年代还是个人电脑的时代，windows和Intel挟PC以令天下，盛极一时。尽管Internet为主体的信息革命尚未到来，但许多程序员以及资深计算机用户已经在频繁使用Internet进行交流，比如使用email和newsgroup。Internet让信息交流成本大大下降。一种新的软件开发模式开始流行：开源。程序员利用业余时间进行软件开发，并开放源代码。1991年，Linus在comp.os.minix新闻组上发布了Linux内核源代码，吸引大批hacker的加入。Linux和GNU相互合作，最终构成了一个充满活力的开源平台。</p><p>硬件性能不是瓶颈，Python又容易使用，所以许多人开始转向Python。Guido维护了一个maillist，Python用户就通过邮件进行交流。Python用户来自许多领域，有不同的背景，对Python也有不同的需求。Python相当的开放，又容易拓展，所以当用户不满足于现有功能，很容易对Python进行拓展或改造。随后，这些用户将改动发给Guido，并由Guido决定是否将新的特征加入到Python或者标准库中。如果代码能被纳入Python自身或者标准库，这将极大的荣誉。由于Guido至高无上的决定权，他因此被称为“终身的仁慈独裁者”。</p><p>Python被称为“Battery Included”，是说它以及其标准库的功能强大。这些是整个社区的贡献。Python的开发者来自不同领域，他们将不同领域的优点带给Python。比如Python标准库中的正则表达是参考Perl，而lambda, map, filter, reduce等函数参考了Lisp。Python本身的一些功能以及大部分的标准库来自于社区。Python的社区不断扩大，进而拥有了自己的newsgroup，网站，以及基金。从Python 2.0开始，Python也从maillist的开发方式，转为完全开源的开发方式。社区气氛已经形成，工作被整个社区分担，Python也获得了更加高速的发展。</p><p>到今天，Python的框架已经确立。Python语言以对象为核心组织代码，支持多种编程范式，采用动态类型，自动进行内存回收。Python支持解释运行，并能调用C库进行拓展。Python有强大的标准库。由于标准库的体系已经稳定，所以Python的生态系统开始拓展到第三方包。这些包，如Django、web.py、wxpython、numpy、matplotlib、PIL，将Python升级成了物种丰富的热带雨林。</p><h2 id="启示录"><a href="#启示录" class="headerlink" title="启示录"></a>启示录</h2><p>Python崇尚优美、清晰、简单，是一个优秀并广泛使用的语言。Python在TIOBE排行榜中排行第八，它是Google的第三大开发语言，Dropbox的基础语言，豆瓣的服务器语言。Python的发展史可以作为一个代表，带给我许多启示。</p><p>在Python的开发过程中，社区起到了重要的作用。Guido自认为自己不是全能型的程序员，所以他只负责制订框架。如果问题太复杂，他会选择绕过去，也就是cut the corner。这些问题最终由社区中的其他人解决。社区中的人才是异常丰富的，就连创建网站，筹集基金这样与开发稍远的事情，也有人乐意于处理。如今的项目开发越来越复杂，越来越庞大，合作以及开放的心态成为项目最终成功的关键。</p><p>Python从其他语言中学到了很多，无论是已经进入历史的ABC，还是依然在使用的C和Perl，以及许多没有列出的其他语言。可以说，Python的成功代表了它所有借鉴的语言的成功。同样，Ruby借鉴了Python，它的成功也代表了Python某些方面的成功。每个语言都是混合体，都有它优秀的地方，但也有各种各样的缺陷。同时，一个语言“好与不好”的评判，往往受制于平台、硬件、时代等等外部原因。程序员经历过许多语言之争。其实，以开放的心态来接受各个语言，说不定哪一天，程序员也可以如Guido那样，混合出自己的语言。</p><p>无论Python未来的命运如何，Python的历史已经是本很有趣的小说。</p>]]></content>
    
    <summary type="html">
    
      Python语言的发展简史。
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>解决MAC系统上matplotlib无法使用问题</title>
    <link href="http://miclee.site/2017/05/12/%E8%A7%A3%E5%86%B3matplotlib%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://miclee.site/2017/05/12/解决matplotlib无法使用问题/</id>
    <published>2017-05-12T01:49:13.000Z</published>
    <updated>2017-05-12T01:58:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 在 MAC 上运行Python时，如果涉及到matplotlib画图，小火箭总是弹不出界面，有的还会报RuntimeError。 </em></strong><br><a id="more"></a></p><hr><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**RuntimeError**: Python <span class="keyword">is</span> <span class="keyword">not</span> installed <span class="keyword">as</span> a framework. The Mac OS X backend will <span class="keyword">not</span> be able <span class="keyword">to</span> function correctly <span class="keyword">if</span> Python <span class="keyword">is</span> <span class="keyword">not</span> installed <span class="keyword">as</span> a framework. See <span class="keyword">the</span> Python documentation <span class="keyword">for</span> more information <span class="keyword">on</span> installing Python <span class="keyword">as</span> a framework <span class="keyword">on</span> Mac OS X. Please either reinstall Python <span class="keyword">as</span> a framework, <span class="keyword">or</span> <span class="keyword">try</span> one <span class="keyword">of</span> <span class="keyword">the</span> other backends.</span><br></pre></td></tr></table></figure><p><strong>原因：</strong>  </p><p>Problem Cause In mac os image rendering back end of matplotlib (what-is-a-backend to render using the API of Cocoa by default). There is Qt4Agg and GTKAgg and as a back-end is not the default. Set the back end of macosx that is differ compare with other windows or linux os.</p><p><strong>解决方案：</strong></p><p>创建文件 ~/.matplotlib/matplotlibrc<br>增加内容:<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">backend: </span>TkAgg</span><br></pre></td></tr></table></figure></p><p>搞定收工！</p>]]></content>
    
    <summary type="html">
    
      在 MAC 上运行Python时，如果涉及到matplotlib画图，小火箭总是弹不出界面，有的还会报RuntimeError。
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Numpy 矩阵乘法</title>
    <link href="http://miclee.site/2017/05/10/py-dot-multiply/"/>
    <id>http://miclee.site/2017/05/10/py-dot-multiply/</id>
    <published>2017-05-10T09:02:17.000Z</published>
    <updated>2017-05-16T05:50:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 在NumPy中，array用于表示通用的N维数组，matrix则特定用于线性代数计算。array和matrix都可以用来表示矩阵，二者在进行乘法操作时，有一些不同之处。 </em></strong><br><a id="more"></a></p><hr><h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><p>使用array时，运算符 * 用于计算数量积（点乘），函数 dot() 用于计算矢量积（叉乘），例子如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">a = np.array([[1, 2], [3, 4]])</span><br><span class="line">b = np.array([[5, 6], [7, 8]])</span><br><span class="line"></span><br><span class="line">print(&apos;a * b = \n&apos;, a * b)</span><br><span class="line">print(&apos;dot(a, b) = \n&apos;, np.dot(a, b))</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a * b =</span><br><span class="line">[[ 5 12]</span><br><span class="line"> [21 32]]</span><br><span class="line">dot(a, b) =</span><br><span class="line">[[19 22]</span><br><span class="line"> [43 50]]</span><br></pre></td></tr></table></figure><p>可见，当a和b为array时， a <em> b 计算了a和b的数量积（对应Matlab的 a .</em> b ）， dot(a, b) 计算了a和b的矢量积（对应Matlab的 a * b ）。</p><h2 id="matrix"><a href="#matrix" class="headerlink" title="matrix"></a>matrix</h2><p>与array不同的是，使用matrix时，运算符 * 用于计算矢量积，函数 multiply() 用于计算数量积，例子如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">a = np.mat(&apos;1 2; 3 4&apos;)</span><br><span class="line">b = np.mat(&apos;5 6; 7 8&apos;);</span><br><span class="line"></span><br><span class="line">print &apos;a * b = \n&apos;, a * b</span><br><span class="line">print &apos;multiply(a, b) = \n&apos;, np.multiply(a, b)</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a * b =</span><br><span class="line"><span class="string">[[19 22]</span></span><br><span class="line"><span class="string"> [43 50]]</span></span><br><span class="line">multiply(a, b) =</span><br><span class="line"><span class="string">[[ 5 12]</span></span><br><span class="line"><span class="string"> [21 32]]</span></span><br></pre></td></tr></table></figure><p>可见，当a和b为matrix时， a * b 计算了a和b的矢量积， multiply(a, b) 计算了a和b的数量积。当使用matrix时，无论是生成矩阵还是计算，Numpy的风格和Matlab更加贴近，降低了语言切换时的负担。</p>]]></content>
    
    <summary type="html">
    
      在NumPy中，array用于表示通用的N维数组，matrix则特定用于线性代数计算。array和matrix都可以用来表示矩阵，二者在进行乘法操作时，有一些不同之处。
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>range、xrange、arange比较</title>
    <link href="http://miclee.site/2017/05/10/python-range/"/>
    <id>http://miclee.site/2017/05/10/python-range/</id>
    <published>2017-05-10T05:31:51.000Z</published>
    <updated>2017-05-11T10:56:41.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> range & xrange属于python的原生方法，arange属于numpy库的方法，具体区别如下。 </em></strong><br><a id="more"></a></p><hr><h2 id="range"><a href="#range" class="headerlink" title="range"></a>range</h2><p>官方文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">range(stop) -&gt; range object</span><br><span class="line">range(start, stop[, step]) -&gt; range object</span><br><span class="line"></span><br><span class="line">Return an object that produces a sequence of integers from start (inclusive)</span><br><span class="line">to stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.</span><br><span class="line">start defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.</span><br><span class="line">These are exactly the valid indices for a list of 4 elements.</span><br><span class="line">When step is given, it specifies the increment (or decrement).</span><br></pre></td></tr></table></figure></p><p><strong>函数说明：</strong><br>根据start与stop指定的范围以及step设定的步长，生成一个序列。<br>range示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; range(5)</span><br><span class="line">[0, 1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt; range(1,5)</span><br><span class="line">[1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt; range(0,6,2)</span><br><span class="line">[0, 2, 4]</span><br></pre></td></tr></table></figure></p><h2 id="xrange"><a href="#xrange" class="headerlink" title="xrange"></a>xrange</h2><p><strong>函数说明：</strong><br>用法与range完全相同，所不同的是生成的不是一个数组，而是一个生成器。<br>xrange示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; xrange(5)</span><br><span class="line">xrange(5)</span><br><span class="line">&gt;&gt;&gt; list(xrange(5))</span><br><span class="line">[0, 1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt; xrange(1,5)</span><br><span class="line">xrange(1, 5)</span><br><span class="line">&gt;&gt;&gt; list(xrange(1,5))</span><br><span class="line">[1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt; xrange(0,6,2)</span><br><span class="line">xrange(0, 6, 2)</span><br><span class="line">&gt;&gt;&gt; list(xrange(0,6,2))</span><br><span class="line">[0, 2, 4]</span><br></pre></td></tr></table></figure></p><p>要生成很大的数字序列的时候，用xrange会比range性能优很多，因为不需要一上来就开辟一块很大的内存空间，这两个基本上都是在循环的时候用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in range(0, 100):</span><br><span class="line">print i</span><br><span class="line">for i in xrange(0, 100):</span><br><span class="line">print i</span><br></pre></td></tr></table></figure></p><p><strong>在Python 3中，range()的实现方式与xrange()函数相同，所以就不存在专用的xrange()（在Python 3中使用xrange()会触发NameError）。</strong>  </p><h2 id="arange"><a href="#arange" class="headerlink" title="arange"></a>arange</h2><p><strong>官方文档：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">numpy.arange([start, ]stop, [step, ]dtype=None)</span><br><span class="line">Return evenly spaced values within a given interval.</span><br><span class="line"></span><br><span class="line">Values are generated within the half-open interval [start, stop) (in other words, the interval including start but excluding stop). For integer arguments the function is equivalent to the Python built-in range function, but returns an ndarray rather than a list.</span><br><span class="line">```   </span><br><span class="line">用法等同于range，区别在于返回的是ndarray而非list。</span><br><span class="line">```python3</span><br><span class="line">&gt;&gt;&gt; np.arange(3)</span><br><span class="line">array([0, 1, 2])</span><br><span class="line">&gt;&gt;&gt; np.arange(3.0)</span><br><span class="line">array([ 0.,  1.,  2.])</span><br><span class="line">&gt;&gt;&gt; np.arange(3,7)</span><br><span class="line">array([3, 4, 5, 6])</span><br><span class="line">&gt;&gt;&gt; np.arange(3,7,2)</span><br><span class="line">array([3, 5])</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      range &amp; xrange属于python的原生方法，arange属于numpy库的方法，具体区别如下。
    
    </summary>
    
      <category term="Python" scheme="http://miclee.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://miclee.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>机器学习里的常用数学概念</title>
    <link href="http://miclee.site/2017/04/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%87%8C%E7%9A%84%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E6%A6%82%E5%BF%B5/"/>
    <id>http://miclee.site/2017/04/26/机器学习里的常用数学概念/</id>
    <published>2017-04-26T08:26:40.000Z</published>
    <updated>2017-04-26T08:40:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 机器学习是门数学强相关的学科，在学习过程中不得不回过头去复习很多大学甚至中学的数学概念，在此记录下，方便以后查询。会持续往里更新。。。 </em></strong><br><a id="more"></a></p><hr><h2 id="偏差（Bias）"><a href="#偏差（Bias）" class="headerlink" title="偏差（Bias）"></a>偏差（Bias）</h2><p>   偏差描述的是预测值和真实值的差距。<br>   偏差越大，越偏离真实数据。  </p><h2 id="方差（Variance）"><a href="#方差（Variance）" class="headerlink" title="方差（Variance）"></a>方差（Variance）</h2><p>   方差描述的是预测值的变化范围、离散程度。<br>   方差越大，数据的分布越分散。  </p><h2 id="标准差"><a href="#标准差" class="headerlink" title="标准差"></a>标准差</h2><p>   标准差是方差的算术平方根。<br>   标准差和均值的量纲是一致的，在描述一个波动范围时更方便。<br>   如，身高分布是 170cm ± 10cm，标准差为10，方差为100。   </p><h2 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h2><p>   协方差用于衡量两个变量的总体误差。<br>   方差是协方差的一种特殊情况，即当两个变量是相同的情况。  </p><hr><h2 id="中位数"><a href="#中位数" class="headerlink" title="中位数"></a>中位数</h2><p>   将一组数据按大小一次排列，把处在中间位置的一个数据（或最中间两位数的平均数）叫做这组数据的中位数。  </p><h2 id="众数"><a href="#众数" class="headerlink" title="众数"></a>众数</h2><p>   一组数据中出现次数最多的数。</p>]]></content>
    
    <summary type="html">
    
      机器学习是门数学强相关的学科，在学习过程中不得不回过头去复习很多大学甚至中学的数学概念，在此记录下，方便以后查询。会持续往里更新。。。
    
    </summary>
    
      <category term="机器学习" scheme="http://miclee.site/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://miclee.site/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>数据挖掘</title>
    <link href="http://miclee.site/2017/04/26/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    <id>http://miclee.site/2017/04/26/数据挖掘/</id>
    <published>2017-04-26T08:06:36.000Z</published>
    <updated>2017-04-26T08:42:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 在机器学习那章提到过，数据挖掘就是“机器学习+数据库”。就是在大型数据存储库中自动发现有用信息的过程。数据库中的知识发现。 </em></strong><br><a id="more"></a></p><hr><h2 id="数据挖掘主要任务"><a href="#数据挖掘主要任务" class="headerlink" title="数据挖掘主要任务"></a>数据挖掘主要任务</h2><ul><li>预测建模  <ul><li>分类：预测离散的目标变量</li><li>回归：预测连续的目标变量</li></ul></li><li>关联分析<br>发现数据中强关联特征的模式，如购物篮分析。</li><li>聚类分析<br>发现紧密相关的观测值组群，如新闻分类聚合。  </li><li>异常检测<br>识别其特征显著不同于其他数据的观测值，这样的观测值称为 <em>异常点</em> 或 <em>利群点</em>。如信贷欺诈、网络攻击、疾病发现、生态系统扰动等。  </li></ul><h2 id="数据挖掘主要步骤"><a href="#数据挖掘主要步骤" class="headerlink" title="数据挖掘主要步骤"></a>数据挖掘主要步骤</h2><ol><li>业务理解  </li><li>数据理解  </li><li>数据准备<br>数据准备就是对数据预处理，包括抽样、缺失值&amp;异常值处理、变量选择、数据分箱、数据降维等。  </li><li>建模  </li><li>模型评估<br>常用评估方法：混淆矩阵、基尼系数、K-S曲线、ROC曲线等。</li><li>模型发布</li></ol><h2 id="常用分类算法"><a href="#常用分类算法" class="headerlink" title="常用分类算法"></a>常用分类算法</h2><ul><li>决策树</li><li>基于规则的分类器</li><li>K-最近邻分类器</li><li>支持向量机</li><li>贝叶斯分类</li><li>人工神经网络</li><li>Logistic回归</li><li>多分类器组合使用</li></ul>]]></content>
    
    <summary type="html">
    
      在机器学习那章提到过，数据挖掘就是“机器学习+数据库”。就是在大型数据存储库中自动发现有用信息的过程。数据库中的知识发现。
    
    </summary>
    
      <category term="机器学习" scheme="http://miclee.site/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="数据挖掘" scheme="http://miclee.site/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>机器学习</title>
    <link href="http://miclee.site/2017/04/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://miclee.site/2017/04/26/机器学习/</id>
    <published>2017-04-26T07:13:26.000Z</published>
    <updated>2017-04-26T08:14:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 今年正式开始学习机器学习，记了很多笔记在小本子上（本人还是比较偏爱传统书写），缺点就是回头翻阅起来检索比较困难，So干脆花点时间整理到博客上吧，方便自己也方便他人。由于我目前的工作主要用到机器学习的分类算法，所以会先入手研究这方面，其他的以后再慢慢补充吧。 </em></strong><br><a id="more"></a></p><hr><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>机器学习是人工智能的一个分支。<br>机器学习方法是指用某些算法指导计算机利用已有的数据，得出适当的模型，并利用此模型对新的情境给出判断（预测未来）的一种方法。  </p><p>人工智能 &gt; 机器学习 &gt; 深度学习（即多层神经网络）</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li><p><strong>监督学习</strong><br>从给定的训练数据集中学习出一个函数，当新的数据到来时，可以根据这个函数预测结果。<br>监督学习的训练集要求是包括输入和输出，也可以说是特征和目标。训练集中的目标是由人标注的。<br>常见的监督学习算法包括 <em>回归分析</em> 和 <em>统计分类</em>。  </p><ul><li><strong>回归分析（Regression）</strong><br>预测一个连续值的输出，比如房价。</li><li><strong>统计分类（Classification）</strong><br>预测一个离散值的输出。又细分为二元分类和多元分类。  </li></ul></li><li><p><strong>无监督学习</strong><br>它是一种学习机制，给算法大量的数据，自动找出数据中蕴含的数据结构。<br>无监督学习中，没有属性或标签这一概念，也就是说所有数据都是一样的，没有区别。<br>与监督学习相比，训练集没有人为标注的结果。<br>常见的无监督学习算法有 <em>聚类算法</em> 和 <em>鸡尾酒会算法</em>。  </p><ul><li><strong>聚类算法</strong><br>不同的个体归入不同的类。如谷歌新闻分类。</li><li><strong>鸡尾酒会算法</strong><br>分离出叠加在一起的分类。</li></ul></li><li><p><strong>半监督学习</strong><br>介于监督学习与无监督学习之间。</p></li><li><p><strong>增强学习</strong><br>强调如何基于环境而行动，以取得最大化的预期利益。其灵感来源于心理学中的行为主义理论，即有机体如何在环境给予的奖励或惩罚的刺激下，逐步形成对刺激的预期，产生能获得最大利益的习惯性行为。这个方法具有普适性，因此在其他许多领域都有研究，例如博弈论、控制论、运筹学、信息论、仿真优化、多主体系统学习、群体智能、统计学以及遗传算法。  </p><p>增强学习和标准的监督式学习之间的区别在于，它并不需要出现正确的输入/输出对，也不需要精确校正次优化的行为。强化学习更加专注于在线规划，需要在探索（在未知的领域）和遵从（现有知识）之间找到平衡。强化学习中的“探索-遵从”的交换，在“多臂老虎机问题”和“有限MDP”中研究得最多。</p><h2 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h2><ul><li><strong>模式识别</strong><br>模式识别 = 机器学习，前者是工业界的概念。  </li><li><strong>数据挖掘</strong><br>数据挖掘 = 机器学习 + 数据库   </li><li><strong>统计学习</strong><br>统计学习 ≈ 机器学习，前者偏数学，后者偏实践。</li><li><strong>语音识别</strong><br>语言处理 + 机器学习</li><li><strong>计算机视觉</strong><br>图像处理 + 机器学习</li><li><strong>自然语言处理</strong><br>文本处理 + 机器学习</li></ul></li></ul><h2 id="经典代表算法"><a href="#经典代表算法" class="headerlink" title="经典代表算法"></a>经典代表算法</h2><ul><li><strong>监督学习算法</strong>  <ul><li>线性回归</li><li>逻辑回归</li><li>神经网络</li><li>SVM  </li></ul></li><li><strong>无监督算法</strong>  <ul><li>聚类算法</li><li>降维算法</li></ul></li><li><strong>特殊</strong><ul><li>推荐算法</li></ul></li></ul><h2 id="开发机器学习应用程序的步骤"><a href="#开发机器学习应用程序的步骤" class="headerlink" title="开发机器学习应用程序的步骤"></a>开发机器学习应用程序的步骤</h2><ol><li>收集数据    </li><li>准备数据  </li><li>分析数据  </li><li>训练算法（无监督学习不需要这一步）  </li><li>测试算法  </li><li>使用算法  </li></ol>]]></content>
    
    <summary type="html">
    
      今年正式开始学习机器学习，记了很多笔记在小本子上（本人还是比较偏爱传统书写），缺点就是回头翻阅起来检索比较困难，So干脆花点时间整理到博客上吧，方便自己也方便他人。由于我目前的工作主要用到机器学习的分类算法，所以会先入手研究这方面，其他的以后再慢慢补充吧。
    
    </summary>
    
      <category term="机器学习" scheme="http://miclee.site/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://miclee.site/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
