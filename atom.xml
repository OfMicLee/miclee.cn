<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[MicLee's Bolg]]></title>
  <subtitle><![CDATA[技术创造价值，分享带来快乐]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://miclee.cn/"/>
  <updated>2017-04-19T06:51:30.000Z</updated>
  <id>http://miclee.cn/</id>
  
  <author>
    <name><![CDATA[MicLee]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Python之禅]]></title>
    <link href="http://miclee.cn/2017/04/19/Python%E4%B9%8B%E7%A6%85/"/>
    <id>http://miclee.cn/2017/04/19/Python之禅/</id>
    <published>2017-04-19T06:41:37.000Z</published>
    <updated>2017-04-19T06:51:30.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> 有人说，要想学好一门编程语言，你就需要接受这门语言的哲学。那么如果你想精通Python，就需要践行Python背后的设计哲学。 </em></strong><br><a id="more"></a></p>
<hr>
<p>Python之父是荷兰人Guido van Rossum，被誉为历史上最伟大的12名程序员之一。他在设计Python时，目的是设计出一种优美而强大，提供给非专业程序设计师使用的语言，同时采取开放策略，使Python能够完美结合如C 、 C++和Java等其他语言。Guido对python设计之初提出了规范和风格，名为“Pythonic”，它指的是以Python的方式去编写代码、组织逻辑和对象行为。而对Python哲学的最好阐述，莫过于核心开发者Tim Peters所总结的“Python之禅”（The Zen of Python）了。启动Python解释器后，输入import this就可以看到全文了。</p>
<h2 id="原文">原文</h2><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import this</div><div class="line"></div><div class="line">The Zen <span class="keyword">of</span> Python, <span class="keyword">by</span> Tim Peters</div><div class="line"></div><div class="line">Beautiful <span class="keyword">is</span> better than ugly.</div><div class="line"><span class="keyword">Explicit</span> <span class="keyword">is</span> better than implicit.</div><div class="line">Simple <span class="keyword">is</span> better than complex.</div><div class="line">Complex <span class="keyword">is</span> better than complicated.</div><div class="line">Flat <span class="keyword">is</span> better than nested.</div><div class="line">Sparse <span class="keyword">is</span> better than dense.</div><div class="line">Readability counts.</div><div class="line">Special cases aren<span class="comment">'t special enough to break the rules.</span></div><div class="line">Although practicality beats purity.</div><div class="line">Errors should never pass silently.</div><div class="line">Unless explicitly silenced.</div><div class="line"><span class="keyword">In</span> the face <span class="keyword">of</span> ambiguity, refuse the temptation <span class="keyword">to</span> guess.</div><div class="line">There should be one-- <span class="keyword">and</span> preferably only one --obvious way <span class="keyword">to</span> <span class="keyword">do</span> it.</div><div class="line">Although that way may <span class="keyword">not</span> be obvious at first unless you<span class="comment">'re Dutch.</span></div><div class="line">Now <span class="keyword">is</span> better than never.</div><div class="line">Although never <span class="keyword">is</span> often better than *right* now.</div><div class="line"><span class="keyword">If</span> the implementation <span class="keyword">is</span> hard <span class="keyword">to</span> explain, it<span class="comment">'s a bad idea.</span></div><div class="line"><span class="keyword">If</span> the implementation <span class="keyword">is</span> easy <span class="keyword">to</span> explain, it may be a good idea.</div><div class="line">Namespaces are one honking great idea -- <span class="keyword">let</span><span class="comment">'s do more of those!</span></div></pre></td></tr></table></figure>
<h2 id="Python之禅">Python之禅</h2><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">优美胜于丑陋，</div><div class="line">明了胜于晦涩。</div><div class="line">简洁胜于复杂，</div><div class="line">复杂胜于凌乱。</div><div class="line">扁平胜于嵌套，</div><div class="line">稀疏胜于密繁。</div><div class="line">可读性很重要！</div><div class="line">即便假借特例的实用性之名，也不可违背这些规则。</div><div class="line">不要放过一切错误，除非错误本身需要以忽略对待。</div><div class="line">不确定面前，我们应抵挡妄加猜测的引诱。</div><div class="line">应该有一种，也但愿只有这一种是显而易见的解决之道。</div><div class="line">万事开头难，除非荷兰人。</div><div class="line">做好过不做，而不假思索就动手还不如不做。</div><div class="line">如果某个实现无法很好阐释，那么它肯定是一个糟糕的办法；</div><div class="line">如果某个实现很容易说清楚，那么它可能就是个不错的方案。</div><div class="line">命名空间是个绝妙的发明——对此我们应多多益善！</div></pre></td></tr></table></figure>
<h2 id="蛇宗三字经">蛇宗三字经</h2><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">美胜丑</div><div class="line">明胜暗</div><div class="line">简胜复</div><div class="line">复胜杂</div><div class="line">浅胜深</div><div class="line">疏胜密</div><div class="line">辞达意</div><div class="line">不逾矩</div><div class="line">弃至清</div><div class="line">无阴差</div><div class="line">有阳错</div><div class="line">拒疑数</div><div class="line">求完一</div><div class="line">虽不至，向往之</div><div class="line">敏于行</div><div class="line">戒莽撞</div><div class="line">差难言</div><div class="line">好易说</div><div class="line">每师出，多有名</div></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[有人说，要想学好一门编程语言，你就需要接受这门语言的哲学。那么如果你想精通Python，就需要践行Python背后的设计哲学。]]>
    
    </summary>
    
      <category term="Python" scheme="http://miclee.cn/tags/Python/"/>
    
      <category term="Python" scheme="http://miclee.cn/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[virtualenvwrapper设置]]></title>
    <link href="http://miclee.cn/2017/04/18/py_virtualenvwrapper/"/>
    <id>http://miclee.cn/2017/04/18/py_virtualenvwrapper/</id>
    <published>2017-04-18T11:16:24.000Z</published>
    <updated>2017-04-19T05:17:01.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> virtualenv 是一个可以在同一计算机中隔离多个python版本的工具。有时，两个不同的项目可能需要不同版本的python，如 python2.6.6 / python3.0 ，但是如果都装到一起，经常会导致问题。所以需要一个工具能够将这两种或几种不同版本的环境隔离开来，需要哪个版本就切换到哪个版本做为默认版本。virtualenv 既是满足这个需求的工具。它能够用于创建独立的Python环境，多个Python相互独立，互不影响。 </em></strong><br><a id="more"></a></p>
<hr>
<p>virtualenvwrapper是virtualenv的扩展管理包，用于更方便管理虚拟环境，它可以做：</p>
<ul>
<li>将所有虚拟环境整合在一个目录下</li>
<li>管理（新增，删除，复制）虚拟环境</li>
<li>切换虚拟环境</li>
</ul>
<h2 id="安装">安装</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pip <span class="keyword">install</span> virtualenv</div><div class="line">pip <span class="keyword">install</span> virtualenvwrapper</div></pre></td></tr></table></figure>
<h2 id="配置">配置</h2><p>在 ~/.bash_profile 文件里添加以下配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> WORKON_HOME=~/.virtualenvs</div><div class="line"><span class="built_in">source</span> /usr/<span class="built_in">local</span>/bin/virtualenvwrapper.sh</div></pre></td></tr></table></figure>
<p>别忘了执行 source .bash_profile</p>
<h2 id="使用方法">使用方法</h2><p>所有的命令可使用：virtualenvwrapper –help 进行查看，这里列出几个常用的：</p>
<ul>
<li>创建基本环境：mkvirtualenv [环境名]</li>
<li>删除环境：rmvirtualenv [环境名]</li>
<li>激活环境：workon [环境名]</li>
<li>退出环境：deactivate</li>
<li>列出所有环境：workon 或者 lsvirtualenv -b</li>
</ul>
<h2 id="安装Python3_环境">安装Python3 环境</h2><p>先安装Python3：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">brew </span><span class="keyword">install </span>Python3</div></pre></td></tr></table></figure>
<p>创建环境：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkvirtualenv --python=<span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>python3 envname</div></pre></td></tr></table></figure>
<p>查看环境：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">workon</span></div></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[virtualenv 是一个可以在同一计算机中隔离多个python版本的工具。有时，两个不同的项目可能需要不同版本的python，如 python2.6.6 / python3.0 ，但是如果都装到一起，经常会导致问题。所以需要一个工具能够将这两种或几种不同版本的环境隔离开来，需要哪个版本就切换到哪个版本做为默认版本。virtualenv 既是满足这个需求的工具。它能够用于创建独立的Python环境，多个Python相互独立，互不影响。]]>
    
    </summary>
    
      <category term="Python" scheme="http://miclee.cn/tags/Python/"/>
    
      <category term="Python" scheme="http://miclee.cn/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Jupyter 安装]]></title>
    <link href="http://miclee.cn/2017/04/18/py_jurpyter/"/>
    <id>http://miclee.cn/2017/04/18/py_jurpyter/</id>
    <published>2017-04-18T11:09:03.000Z</published>
    <updated>2017-04-19T02:37:33.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> Jupyter NoteBook 支持python2和3 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="全新安装">全新安装</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip3 <span class="keyword">install</span> jupyter</div></pre></td></tr></table></figure>
<h2 id="增加Python3的支持">增加Python3的支持</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">python3 -m pip <span class="keyword">install</span> ipykernel</div><div class="line">python3 -m ipykernel <span class="keyword">install</span> <span class="comment">--user</span></div></pre></td></tr></table></figure>
<h2 id="增加Python2的支持">增加Python2的支持</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">python -m pip <span class="keyword">install</span> ipykernel</div><div class="line">python -m ipykernel <span class="keyword">install</span> <span class="comment">--user</span></div></pre></td></tr></table></figure>
<h2 id="新的启动命令">新的启动命令</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">jupyter notebook</span></div></pre></td></tr></table></figure>
<h2 id="页面支持内嵌图表">页面支持内嵌图表</h2><p>在notebook页面执行：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">%<span class="selector-tag">pylab</span></span> inline</div></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[Jupyter NoteBook 支持python2和3]]>
    
    </summary>
    
      <category term="Python" scheme="http://miclee.cn/tags/Python/"/>
    
      <category term="Python" scheme="http://miclee.cn/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python模块 - collections]]></title>
    <link href="http://miclee.cn/2017/03/13/py_collections/"/>
    <id>http://miclee.cn/2017/03/13/py_collections/</id>
    <published>2017-03-13T06:54:36.000Z</published>
    <updated>2017-04-19T02:06:52.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> collections是Python内建的一个集合模块，提供了许多有用的集合类。 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="defaultdict_带有默认值的字典">defaultdict 带有默认值的字典</h2><p>我们都知道，在使用Python原生的数据结构dict的时候，如果用 d[key] 这样的方式访问， 当指定的key不存在时，是会抛出KeyError异常的。</p>
<p>但是，如果使用defaultdict，只要你传入一个默认的类型或工厂方法，那么请求一个不存在的key时，便会调用这个工厂方法使用其结果来作为这个key的默认值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</div><div class="line"></div><div class="line">members = [</div><div class="line">    <span class="comment"># Age, name</span></div><div class="line">    [<span class="string">'male'</span>, <span class="string">'John'</span>],</div><div class="line">    [<span class="string">'male'</span>, <span class="string">'Jack'</span>],</div><div class="line">    [<span class="string">'female'</span>, <span class="string">'Lily'</span>],</div><div class="line">    [<span class="string">'male'</span>, <span class="string">'Pony'</span>],</div><div class="line">    [<span class="string">'female'</span>, <span class="string">'Lucy'</span>],</div><div class="line">]</div><div class="line"></div><div class="line">result = defaultdict(list)</div><div class="line"><span class="keyword">for</span> sex, name <span class="keyword">in</span> members:</div><div class="line">    result[sex].append(name)</div><div class="line"></div><div class="line"><span class="keyword">print</span> result</div><div class="line"></div><div class="line"><span class="comment"># Result:</span></div><div class="line"><span class="comment"># defaultdict(&lt;type 'list'&gt;, &#123;'male': ['John', 'Jack', 'Pony'], 'female': ['Lily', 'Lucy']&#125;)</span></div></pre></td></tr></table></figure>
<h3 id="namedtuple">namedtuple</h3><p>namedtuple主要用来产生可以使用名称来访问元素的数据对象，通常用来增强代码的可读性， 在访问一些tuple类型的数据时尤其好用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</div><div class="line"></div><div class="line">websites = [</div><div class="line">    (<span class="string">'google'</span>, <span class="string">'http://www.google.com/'</span>, <span class="string">u'拉里·佩奇'</span>),</div><div class="line">    (<span class="string">'facebook'</span>, <span class="string">'http://www.facebook.com/'</span>, <span class="string">u'马克·扎克伯格'</span>),</div><div class="line">    (<span class="string">'taobao'</span>, <span class="string">'http://www.taobao.com'</span>, <span class="string">u'马云'</span>)</div><div class="line">]</div><div class="line"></div><div class="line">Website = namedtuple(<span class="string">'Website'</span>, [<span class="string">'name'</span>, <span class="string">'url'</span>, <span class="string">'founder'</span>])</div><div class="line"></div><div class="line"><span class="keyword">for</span> website <span class="keyword">in</span> websites:</div><div class="line">    website = Website._make(website)</div><div class="line">    print(website)</div><div class="line"></div><div class="line"><span class="comment"># Result:</span></div><div class="line"><span class="comment"># Website(name='google', url='http://www.google.com/', founder='拉里·佩奇')</span></div><div class="line"><span class="comment"># Website(name='facebook', url='http://www.facebook.com/', founder='马克·扎克伯格')</span></div><div class="line"><span class="comment"># Website(name='taobao', url='http://www.taobao.com', founder='马云')</span></div></pre></td></tr></table></figure>
<h3 id="deque">deque</h3><p>deque其实是 double-ended queue 的缩写，翻译过来就是双端队列，它最大的好处就是实现了从队列 头部快速增加和取出对象: .popleft(), .appendleft() 。</p>
<p>你可能会说，原生的list也可以从头部添加和取出对象啊？就像这样：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">l</span><span class="selector-class">.insert</span>(0, <span class="selector-tag">v</span>)</div><div class="line"><span class="selector-tag">l</span><span class="selector-class">.pop</span>(0)</div></pre></td></tr></table></figure>
<p>但是值得注意的是，list对象的这两种用法的时间复杂度是 O(n) ，也就是说随着元素数量的增加耗时呈 线性上升。而使用deque对象则是 O(1) 的复杂度，所以当你的代码有这样的需求的时候， 一定要记得使用deque。</p>
<p>作为一个双端队列，deque还提供了一些其他的好用方法，比如 rotate 等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</div><div class="line"></div><div class="line">fancy_loading = deque(<span class="string">'------&gt;---托--乐--嘉--花--园---&gt;------'</span>)</div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    <span class="keyword">print</span> <span class="string">'\r%s'</span> % <span class="string">''</span>.join(fancy_loading),</div><div class="line">    fancy_loading.rotate(<span class="number">1</span>)</div><div class="line">    sys.stdout.flush()</div><div class="line">    time.sleep(<span class="number">0.15</span>)</div></pre></td></tr></table></figure>
<h3 id="Counter_计时器">Counter 计时器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</div><div class="line">c = Counter(time_zones)</div><div class="line"><span class="comment"># 最多的10个</span></div><div class="line"><span class="keyword">print</span> c.most_common(<span class="number">10</span>)</div></pre></td></tr></table></figure>
<h3 id="OrderedDict">OrderedDict</h3><p>在Python中，dict这个数据结构由于hash的特性，是无序的，这在有的时候会给我们带来一些麻烦， 幸运的是，collections模块为我们提供了OrderedDict，当你要获得一个有序的字典对象时，用它就对了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</div><div class="line"></div><div class="line">items = (</div><div class="line">    (<span class="string">'A'</span>, <span class="number">1</span>),</div><div class="line">    (<span class="string">'B'</span>, <span class="number">2</span>),</div><div class="line">    (<span class="string">'C'</span>, <span class="number">3</span>)</div><div class="line">)</div><div class="line"></div><div class="line">regular_dict = dict(items)</div><div class="line">ordered_dict = OrderedDict(items)</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">'Regular Dict:'</span></div><div class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> regular_dict.items():</div><div class="line">    <span class="keyword">print</span> k, v</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">'Ordered Dict:'</span></div><div class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> ordered_dict.items():</div><div class="line">    <span class="keyword">print</span> k, v</div><div class="line"></div><div class="line"><span class="comment"># Result:</span></div><div class="line"><span class="comment"># Regular Dict:</span></div><div class="line"><span class="comment"># A 1</span></div><div class="line"><span class="comment"># C 3</span></div><div class="line"><span class="comment"># B 2</span></div><div class="line"><span class="comment"># Ordered Dict:</span></div><div class="line"><span class="comment"># A 1</span></div><div class="line"><span class="comment"># B 2</span></div><div class="line"><span class="comment"># C 3</span></div></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[collections是Python内建的一个集合模块，提供了许多有用的集合类。]]>
    
    </summary>
    
      <category term="Python" scheme="http://miclee.cn/tags/Python/"/>
    
      <category term="Python" scheme="http://miclee.cn/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JPA 对象关系模型之继承映射策略]]></title>
    <link href="http://miclee.cn/2016/05/25/jpa-inherit-type/"/>
    <id>http://miclee.cn/2016/05/25/jpa-inherit-type/</id>
    <published>2016-05-25T09:00:27.000Z</published>
    <updated>2016-05-25T09:30:25.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> Java 是一种面向对象的语言，面向对象的语言特的性之一就是继承。而关系型数据库中的表与表之间的关系，并没有这种继承关系，不能说一张表继承另一张表，它们之间的关系只是关联关系。那么现在 JPA 要将 POJO 的 Java 类映射到数据库中，对于 Java 类中的这种继承关系是如何映射到数据库中的呢。JPA 规范中现在提供了三种不同的策略来实现继承与关系之间的映射。 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="策略">策略</h2><h3 id="一、Single-table_策略">一、Single-table 策略</h3><p>这是继承映射中的缺省策略，在不特别指明的情况下，系统默认就是采用这种映射策略进行映射的。这个策略的映射原则就是父类包括子类中新添加的属性全部映射到一张数据库表中，数据库表中有一个自动生成的字段用来存储区分不同的子类的信息。</p>
<p><strong><em>就是不管有几张子实体，统统存在一张表里，父实体会为每个子实体冗余一条数据，通过自动生成的’DTYPE’字段来区分属于谁的数据。</em></strong></p>
<h3 id="二、Joined-subclass_策略">二、Joined-subclass 策略</h3><p>这种映射策略中，继承关系中的每一个实体类，无论是具体类 (concrete entity) 或者抽象类 (abstract entity)，数据库中都有一个单独的表与他对应。子实体对应的表中不含有从根实体继承而来的属性，它们之间通过共享主键的方式进行关联。</p>
<p><strong><em>子实体会自动存入父实体的主键ID字段，父实体会为每个子实体存一条记录，通过自动生成的’DTYPE’字段来区分属于谁的数据。</em></strong></p>
<h3 id="三、Table-per-concrete-class_策略">三、Table-per-concrete-class 策略</h3><p>这个策略就是将继承关系中的每一个实体映射到数据库中的一个单独的表中，与“Joined”策略不同的是，子实体对应的表中含有从根实体继承而来的属性。这种策略在 JPA2.0 中仍然是自由选取得，也就是说实现 JPA2.0 规范的持久化引擎，如 Toplink，Hibernate 等 , 仍然可以自由选取是否实现这种策略。</p>
<p><strong><em>每个子实体都有单独表冗余进父实体的字段</em></strong></p>
<h2 id="注解">注解</h2><p>得益于注解 (annotation) 方式的使用，JPA 2.0 中实现继承关系的映射非常简单。当实体 (entity) 之间有继承关系的时候，一定有一个根实体 (root entity)，JPA2.0 中只需要在这个根实体 (root entity) 上标注 @Inheritance 注解并且指明想要采用的映射策略就可以了。如果是不用 @Inheritance 注解，或者使用了 @Inheritance 注解但是没有指明所要采用的映射策略的时候，默认就是采用单表策略 (Single-table strategy)。下面用图 1 这个继承关系分别说明这三种映射策略的使用。</p>
<h3 id="1、@Inheritance">1、@Inheritance</h3><p>用于父，对应策略一</p>
<h3 id="2、@Inheritance(strategy=InheritanceType-JOINED)">2、@Inheritance(strategy=InheritanceType.JOINED)</h3><p>用于父，对应策略二</p>
<h3 id="3、_@Inheritance(strategy=InheritanceType-TABLE_PER_CLASS)">3、 @Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)</h3><p>用于父，对应策略三</p>
<h3 id="4、用@MappedSuperclass来替代@Entity">4、用@MappedSuperclass来替代@Entity</h3><p>用于父，父实体一般为抽象的不用被实例，数据库不会生成对应表，子实体会继承字段</p>
<h3 id="5、@Embeddable_和_@Embedded">5、@Embeddable 和 @Embedded</h3><p>@Embeddable用于父，@Embedded用于子。嵌套映射，子实体里定义父实体的类型变量。</p>
<p><strong><em>需要注意的是，如有重复字段，需要用 @Transient 注解排除 </em></strong></p>
<p><strong><em>实际使用中可以用改良版 Joined-subclass 策略，父实体和子实体各自一张表，父实体只存储一份数据，由子实体通过父ID共享。</em></strong></p>
]]></content>
    <summary type="html">
    <![CDATA[Java 是一种面向对象的语言，面向对象的语言特的性之一就是继承。而关系型数据库中的表与表之间的关系，并没有这种继承关系，不能说一张表继承另一张表，它们之间的关系只是关联关系。那么现在 JPA 要将 POJO 的 Java 类映射到数据库中，对于 Java 类中的这种继承关系是如何映射到数据库中的呢。JPA 规范中现在提供了三种不同的策略来实现继承与关系之间的映射。]]>
    
    </summary>
    
      <category term="jpa" scheme="http://miclee.cn/tags/jpa/"/>
    
      <category term="spring" scheme="http://miclee.cn/categories/spring/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis 安装]]></title>
    <link href="http://miclee.cn/2016/05/12/redis-setup/"/>
    <id>http://miclee.cn/2016/05/12/redis-setup/</id>
    <published>2016-05-12T08:33:43.000Z</published>
    <updated>2016-05-12T13:02:19.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> Redis是一个开源、支持网络、基于内存、键值对存储数据库，使用ANSI C编写， redis中文官方网站：[http://redis.cn/](http://redis.cn/) </em></strong><br><a id="more"></a></p>
<hr>
<h3 id="一、下载">一、下载</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ wget http:<span class="comment">//download.redis.io/releases/redis-3.2.0.tar.gz</span></div><div class="line">$ tar -xzf redis-<span class="number">3.2</span>.<span class="number">0</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></div></pre></td></tr></table></figure>
<h3 id="二、编译">二、编译</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>cd redis-<span class="number">3.2</span>.<span class="number">0</span></div><div class="line"><span class="variable">$ </span>make</div></pre></td></tr></table></figure>
<h3 id="三、安装">三、安装</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>make PREFIX=<span class="regexp">/usr/local</span><span class="regexp">/redis install</span></div></pre></td></tr></table></figure>
<p>这步完了之后，Redis就被安装到了/usr/local/redis/ 下面了</p>
<h3 id="四、测试">四、测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ make <span class="built_in">test</span></div></pre></td></tr></table></figure>
<blockquote>
<p>如果没安装有tcl那么会包下面这错误：<br>    You need tcl 8.5 or newer in order to run the Redis test​<br>   【安装Tcl-8.6.3】<br>​     [root@localhost202 src]# wget <a href="http://downloads.sourceforge.net/tcl/tcl8.6.3-src.tar.gz" target="_blank" rel="external">http://downloads.sourceforge.net/tcl/tcl8.6.3-src.tar.gz</a><br>     [root@localhost202 src]# tar -zxf tcl8.6.3-src.tar.gz<br>     [root@localhost202 src]# cd ​tcl8.6.3/unix/<br>     [root@localhost202 src]# ./configure<br>     [root@localhost202 src]# make<br>     [root@localhost202 src]# make install</p>
</blockquote>
<h3 id="五、配置">五、配置</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ cp src/redis-server src/redis-cli <span class="meta-keyword">/usr/</span>bin/bin</div><div class="line">$ cp ./redis.conf <span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/redis/</span></div><div class="line">$ vim <span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/redis/</span>redis.conf</div><div class="line"></div><div class="line">daemonize   yes      <span class="meta">#redis将以守护进程的方式运行，默认为no会暂用你的终端</span></div><div class="line">timeout <span class="number">300</span>​          <span class="meta">#当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</span></div><div class="line">requirepass password123</div></pre></td></tr></table></figure>
<h3 id="六、运行">六、运行</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ redis-server <span class="regexp">/usr/</span>local<span class="regexp">/redis/</span>redis.conf</div></pre></td></tr></table></figure>
<h3 id="七、防火墙里开启6379端口">七、防火墙里开启6379端口</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vi <span class="regexp">/etc/</span>sysconfig<span class="regexp">/iptables</span></div></pre></td></tr></table></figure>
<p>加入： -A INPUT -m state –state NEW -m tcp -p tcp –dport 6379 -j ACCEPT<br>重启防火墙<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>service iptables restart</div></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[Redis是一个开源、支持网络、基于内存、键值对存储数据库，使用ANSI C编写， redis中文官方网站：[http://redis.cn/](http://redis.cn/)]]>
    
    </summary>
    
      <category term="技术综合" scheme="http://miclee.cn/categories/%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[react-component]]></title>
    <link href="http://miclee.cn/2016/04/20/react-component/"/>
    <id>http://miclee.cn/2016/04/20/react-component/</id>
    <published>2016-04-20T11:01:42.000Z</published>
    <updated>2016-04-20T11:03:50.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> 可以这么说，一个 React 应用就是构建在 React 组件之上的。 </em></strong><br><a id="more"></a></p>
<hr>
<h1 id="React_组件">React 组件</h1><p>组件有两个核心概念：</p>
<ul>
<li>props</li>
<li>state</li>
</ul>
<p>一个组件就是通过这两个属性的值在 <code>render</code> 方法里面生成这个组件对应的 HTML 结构。</p>
<p><em>注意：组件生成的 HTML 结构只能有一个单一的根节点。</em></p>
<h2 id="props">props</h2><p>前面也提到很多次了，<code>props</code> 就是组件的属性，由外部通过 JSX<br>属性传入设置，一旦初始设置完成，就可以认为 <code>this.props</code> 是不可更改的，所以<strong>不要</strong>轻易更改设置 <code>this.props</code> 里面的值（虽然对于一个 JS 对象你可以做任何事）。</p>
<h2 id="state">state</h2><p><code>state</code> 是组件的当前状态，可以把组件简单看成一个“状态机”，根据状态 <code>state</code><br>呈现不同的 UI 展示。</p>
<p>一旦状态（数据）更改，组件就会自动调用 <code>render</code> 重新渲染 UI，这个更改的动作会通过<br><code>this.setState</code> 方法来触发。</p>
<h2 id="划分状态数据">划分状态数据</h2><p>一条原则：让组件尽可能地少状态。</p>
<p>这样组件逻辑就越容易维护。</p>
<p>什么样的数据属性可以当作状态？</p>
<p>当更改这个状态（数据）需要更新组件 UI 的就可以认为是 <code>state</code>，下面这些可以认为<strong>不是</strong>状态：</p>
<ul>
<li>可计算的数据：比如一个数组的长度</li>
<li>和 props 重复的数据：除非这个数据是要做变更的</li>
</ul>
<p>最后回过头来反复看几遍 <a href="http://facebook.github.io/react/docs/thinking-in-react.html" target="_blank" rel="external">Thinking in<br>React</a>，相信会对组件有更深刻的认识。</p>
<h2 id="无状态组件">无状态组件</h2><p>你也可以用纯粹的函数来定义无状态的组件(stateless function)，这种组件没有状态，没有生命周期，只是简单的接受 props 渲染生成 DOM 结构。无状态组件非常简单，开销很低，如果可能的话尽量使用无状态组件。比如使用箭头函数定义：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const HelloMessage = (props) =&gt; &lt;div&gt; Hello &#123;props.name&#125;&lt;/div&gt;;</div><div class="line">render(&lt;HelloMessage name="John" /&gt;, mountNode);</div></pre></td></tr></table></figure>
<p>因为无状态组件只是函数，所以它没有实例返回，这点在想用 refs<br>获取无状态组件的时候要注意，参见<a href="dom.md">DOM 操作</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[可以这么说，一个 React 应用就是构建在 React 组件之上的。]]>
    
    </summary>
    
      <category term="react" scheme="http://miclee.cn/tags/react/"/>
    
      <category term="react" scheme="http://miclee.cn/categories/react/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[React开发神器Webpack]]></title>
    <link href="http://miclee.cn/2016/04/20/react-webpack/"/>
    <id>http://miclee.cn/2016/04/20/react-webpack/</id>
    <published>2016-04-20T09:19:55.000Z</published>
    <updated>2016-04-20T12:01:03.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> Webpack是功能最为强大的前端模块管理和打包工具。虽然Webpack是一个通用的工具，并不只适合于React，但是很多React的文章或者项目都使用了Webpack，尤其是react-hot-loader这样的神器存在，让Webpack成为最主流的React开发工具。 </em></strong><br><a id="more"></a></p>
<hr>
<p>Webpack将项目中用到的一切静态资源都视之为模块，模块之间可以互相依赖。Webpack对它们进行统一的管理以及打包发布。</p>
<h2 id="一、安装Webpack">一、安装Webpack</h2><p>Webpack一般作为全局的npm模块安装：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> -g Webpack</div></pre></td></tr></table></figure>
<p>直接执行此命令会默认使用当前目录的webpack.config.js作为配置文件。如果要指定另外的配置文件，可以执行：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack —config webpack<span class="selector-class">.custom</span><span class="selector-class">.config</span><span class="selector-class">.js</span></div></pre></td></tr></table></figure>
<h2 id="二、Webpack模块加载器（Loaders）">二、Webpack模块加载器（Loaders）</h2><p>Webpack将所有静态资源都认为是模块，比如JavaScript，CSS，LESS，TypeScript，JSX，CoffeeScript，图片等等，从而可以对其进行统一管理。每一种资源都可以通过对应的加载器处理成模块。和大多数包管理器不一样的是，Webpack的加载器之间可以进行串联，一个加载器的输出可以成为另一个加载器的输入。比如LESS文件先通过less-load处理成css，然后再通过css-loader加载成css模块，最后由style-loader加载器对其做最后的处理，从而运行时可以通过style标签将其应用到最终的浏览器环境。</p>
<p>为了让Webpack识别什么样的资源应该用什么加载器去载入，需要在配置文件进行配置：通过正则表达式对文件名进行匹配。</p>
<h3 id="特别的，使用babel解析js或jsx">特别的，使用babel解析js或jsx</h3><figure class="highlight q"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">npm install --<span class="built_in">save</span>-<span class="built_in">dev</span> babel-loader</div><div class="line">npm install --<span class="built_in">save</span>-<span class="built_in">dev</span> babel-preset-react</div><div class="line">npm install --<span class="built_in">save</span>-<span class="built_in">dev</span> babel-preset-es2015</div></pre></td></tr></table></figure>
<h2 id="三、config文件">三、config文件</h2><p>配置文件通常放在项目根目录之下，其本身也是一个标准的CommonJS模块。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// webpack.config.js</span></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">entry</span>: <span class="string">'./js/main.js'</span>,</div><div class="line">  <span class="attr">output</span>: &#123;</div><div class="line">    <span class="attr">path</span>: <span class="string">'./build'</span>, <span class="comment">// 打包文件存放的绝对路径</span></div><div class="line">    publicPath: <span class="string">'/build'</span>, <span class="comment">// 网站运行时的访问路径</span></div><div class="line">    filename: <span class="string">'bundle.js'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">resolve</span>: &#123; <span class="comment">//resolve 指定可以被 import 的文件后缀。比如 Hello.jsx 这样的文件就可以直接用 import Hello from 'Hello' 引用。</span></div><div class="line">       extensions: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'.jsx'</span>]</div><div class="line">   &#125;,</div><div class="line">  <span class="attr">module</span>: &#123;</div><div class="line">    <span class="attr">loaders</span>: [</div><div class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.(js|jsx)$/</span>,</div><div class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</div><div class="line">        <span class="attr">loader</span>: <span class="string">'babel-loader'</span>,</div><div class="line">        <span class="attr">query</span>:</div><div class="line">        &#123;</div><div class="line">			    <span class="attr">presets</span>:[<span class="string">'es2015'</span>,<span class="string">'react'</span>]</div><div class="line">			  &#125;</div><div class="line">      &#125;, <span class="comment">//指定 babel-loader 编译后缀名为 .js 或者 .jsx 的文件</span></div><div class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</div><div class="line">        <span class="attr">loader</span>: <span class="string">'style-loader!css-loader'</span></div><div class="line">      &#125;,</div><div class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.(png|jpg)$/</span>,</div><div class="line">        <span class="attr">loader</span>: <span class="string">'url-loader?limit=8192'</span></div><div class="line">      &#125; <span class="comment">// inline base64 URLs for &lt;=8k images, direct URLs for the rest</span></div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="四、webpack服务器">四、webpack服务器</h2><p>在webpack里面有一个开发工具就是可以自动开启一个服务器。可以和webpack一样作为全局的npm模块安装：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> -g webpack-dev-<span class="keyword">server</span></div></pre></td></tr></table></figure></p>
<h2 id="五、实现热替换(HMR)功能">五、实现热替换(HMR)功能</h2><ul>
<li><p>Webpack本身具有运行时模块替换功能，称之为Hot Module Replacement (HMR)。</p>
<p>当某个模块代码发生变化时，Webpack实时打包将其推送到页面并进行替换，从而无需刷新页面就实现代码替换。这个过程相对比较复杂，需要进行多方面考虑和配置。</p>
</li>
<li><p>使用react-hot-loader加载器</p>
<p>针对React出现了一个第三方react-hot-loader加载器，使用这个加载器就可以轻松实现React组件的热替换，非常方便。其实正是因为React的每一次更新都是全局刷新的虚拟DOM机制，让React组件的热替换可以成为通用的加载器，从而极大提高开发效率。</p>
</li>
<li><p>使用监听模式</p>
<p>‘webpack –watch’命令，不过需要手动刷新页面，但不需要重启服务。</p>
<h3 id="react-hot-loader加载器具体实现：">react-hot-loader加载器具体实现：</h3><ul>
<li><p>1、安装依赖</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install react-hot-loader --<span class="built_in">save</span>-<span class="built_in">dev</span></div></pre></td></tr></table></figure>
</li>
<li><p>2、更改webpack.config.js<br>为了热加载React组件，我们需要在前端页面中加入相应的代码，用以接收Webpack推送过来的代码模块，进而可以通知所有相关React组件进行重新Render:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//webpack.config.js</span></div><div class="line">...</div><div class="line">entry: [</div><div class="line">  <span class="string">'webpack-dev-server/client?http://127.0.0.1:8080'</span>, <span class="comment">// WebpackDevServer host and port</span></div><div class="line">  <span class="string">'webpack/hot/only-dev-server'</span>,</div><div class="line">  <span class="string">'./js/main'</span> <span class="comment">// Your appʼs entry point</span></div><div class="line">]</div><div class="line">...</div></pre></td></tr></table></figure>
</li>
<li><p>3、下一步，我们需要让Webpack用react-hot-loader去加载React组件:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//webpack.config.js</span></div><div class="line">...</div><div class="line">loaders: [&#123;</div><div class="line">    <span class="attr">test</span>: <span class="regexp">/\.(js|jsx)$/</span>,</div><div class="line">    <span class="attr">loader</span>: <span class="string">'react-hot!babel'</span></div><div class="line">  &#125;,</div><div class="line">  …</div><div class="line">]</div><div class="line">...</div></pre></td></tr></table></figure>
</li>
<li><p>4、修改package.json文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">"scripts": &#123;</div><div class="line">  "build": "webpack",</div><div class="line">  "dev": "webpack-dev-server --devtool eval --progress --colors --hot --content-base"</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>参数含义：</p>
<ul>
<li>webpack-dev-server - 在 localhost:8080 建立一个 Web 服务器</li>
<li>devtool eval - 为你的代码创建源地址。当有任何报错的时候可以让你更加精确地定位到文件和行号</li>
<li>progress - 显示合并代码进度</li>
<li>colors - Yay，命令行中显示颜色！</li>
<li>hot - 开启HMR参数hot</li>
<li>content-base - 指向设置的输出目录,后面可以写你想指向的输出目录 不写默认为空目录</li>
</ul>
<ul>
<li>5、使用<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">run</span><span class="bash"> dev</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[Webpack是功能最为强大的前端模块管理和打包工具。虽然Webpack是一个通用的工具，并不只适合于React，但是很多React的文章或者项目都使用了Webpack，尤其是react-hot-loader这样的神器存在，让Webpack成为最主流的React开发工具。]]>
    
    </summary>
    
      <category term="react" scheme="http://miclee.cn/tags/react/"/>
    
      <category term="react" scheme="http://miclee.cn/categories/react/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Catalina_Base和Catalina_HOME的区别]]></title>
    <link href="http://miclee.cn/2016/02/23/Catalina-Base/"/>
    <id>http://miclee.cn/2016/02/23/Catalina-Base/</id>
    <published>2016-02-23T06:58:14.000Z</published>
    <updated>2016-02-23T07:00:59.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> catalina.home和catalina.base这两个属性仅在你需要安装多个Tomcat实例而不想安装多个软件备份的时候使用，这样能节省磁盘空间。 </em></strong><br><a id="more"></a></p>
<hr>
<p>以Tomcat6.0为例，其Tomcat目录结构如下：<br>bin (运行脚本）<br>conf (配置文件）<br>lib (核心库文件）<br>logs (日志目录)<br>temp (临时目录)<br>webapps (自动装载的应用程序的目录）<br>work (JVM临时文件目录[java.io.tmpdir]) </p>
<p>让我们看看这些目录那些可以被多个Tomcat实例公用，其实只有 bin 和 lib 目录,其它目录conf、logs、temp、webapps和work每个Tomcat实例必须拥有其自己独立的备份。<br>明白了上述关系就容易理解catalina.home和catalina.base的用途了。<br>catalina.home指向公用信息的位置，就是bin和lib的父目录。<br>catalina.base指向每个Tomcat目录私有信息的位置，就是conf、logs、temp、webapps和work的父目录。</p>
<h1 id="仅运行一个Tomcat实例时，这两个属性指向的位置是相同的。">仅运行一个Tomcat实例时，这两个属性指向的位置是相同的。</h1><p>我们可以从Tomcat 5.5 的配置文档（<a href="http://tomcat.apache.org/tomcat-5.5-doc/config/host.html" target="_blank" rel="external">http://tomcat.apache.org/tomcat-5.5-doc/config/host.html</a> ）中找到答案：</p>
<p>The description below uses the variable name $CATALINA_HOME to refer to the directory into which you have installed Tomcat 5, and is the base directory against which most relative paths are resolved. However, if you have configured Tomcat 5 for multiple instances by setting a CATALINA_BASE directory, you should use $CATALINA_BASE instead of $CATALINA_HOME for each of these references.</p>
<p>从这段描述可以看出CATALINA_HOME 和CATALINA_BASE 的区别。简单的说，CATALINA_HOME 是Tomcat 的安装目录，CATALINA_BASE 是Tomcat 的工作目录。如果我们想要运行Tomcat 的多个实例，但是不想安装多个Tomcat 软件副本。那么我们可以配置多个工作目录，每个运行实例独占一个工作目录，但是共享同一个安装目录。</p>
<p>Tomcat 每个运行实例需要使用自己的conf 、logs 、temp 、webapps 、work 和shared 目录，因此CATALINA_BASE 就指向这些目录。 而其他目录主要包括了Tomcat 的二进制文件和脚本，CATALINA_HOME 就指向这些目录。</p>
<p>如果我们希望再运行另一个Tomcat 实例，那么我们可以建立一个目录，把conf 、logs 、temp 、webapps 、work 和shared 拷贝到该目录下，然后让CATALINA_BASE 指向该目录即可。</p>
]]></content>
    <summary type="html">
    <![CDATA[catalina.home和catalina.base这两个属性仅在你需要安装多个Tomcat实例而不想安装多个软件备份的时候使用，这样能节省磁盘空间。]]>
    
    </summary>
    
      <category term="tomcat" scheme="http://miclee.cn/categories/tomcat/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[spring-boot哎哟不错(八) —— 使用jpa]]></title>
    <link href="http://miclee.cn/2016/01/13/spring-boot-8/"/>
    <id>http://miclee.cn/2016/01/13/spring-boot-8/</id>
    <published>2016-01-13T07:26:46.000Z</published>
    <updated>2016-01-13T07:55:23.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> JPA是Sun官方提出的Java持久化规范。它为Java开发人员提供了一种对象/关系映射工具来管理Java应用中的关系数据。JPA的宗旨是为POJO提供持久化标准规范，伴随 Java EE 5 发布以来，受到了各大厂商及开源社区的追捧，各种商用的和开源的 JPA 框架如雨后春笋般出现，为开发者提供了丰富的选择。它一改之前 EJB 2.x 中实体 Bean 笨重且难以使用的形象，充分吸收了在开源社区已经相对成熟的 ORM 思想。另外，它并不依赖于 EJB 容器，可以作为一个独立的持久层技术而存在。目前比较成熟的 JPA 框架主要包括 Jboss 的 Hibernate EntityManager、Oracle 捐献给 Eclipse 社区的 EclipseLink(曾经的toplink)、Apache 的 OpenJPA等。所以使用Jpa的一个好处是，可以更换实现而不必改动太多代码。 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="Spring-Boot持久层发展历史">Spring-Boot持久层发展历史</h2><p><img src="https://raw.githubusercontent.com/OfMicLee/img-hosting/master/java/spring-boot-jpa.png" alt="spring-boot-jpa"></p>
<h2 id="Spring-boot-jpa_常用配置">Spring-boot-jpa 常用配置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  jpa:</span></div><div class="line"><span class="attr">     database:</span> <span class="string">MYSQL</span></div><div class="line"><span class="attr">     show-sql:</span> <span class="literal">true</span></div><div class="line"><span class="attr">     hibernate:</span></div><div class="line"><span class="attr">           ddl-auto:</span> <span class="string">update</span></div><div class="line">           <span class="comment"># ddl-auto: none, create, create-drop, update, validate</span></div><div class="line"><span class="attr">           naming_strategy:</span> <span class="string">org.springframework.boot.orm.jpa.hibernate.SpringNamingStrategy</span></div><div class="line">           <span class="comment"># naming_strategy: org.hibernate.cfg.ImprovedNamingStrategy</span></div></pre></td></tr></table></figure>
<h3 id="ddl-auto">ddl-auto</h3><p>主要用于：自动创建|更新|验证数据库表结构。如果不是此方面的需求建议set value=”none”。</p>
<ul>
<li><p>create ：<br>每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。</p>
</li>
<li><p>create-drop ：<br>每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。</p>
</li>
<li><p>update：<br>最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据 model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等 应用第一次运行起来后才会。</p>
</li>
<li><p>validate ：<br>每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。</p>
</li>
</ul>
<blockquote>
<p>当为内嵌数据库时（hsqldb/h2/derby）默认为 create-drop<br>外部数据库默认 none</p>
</blockquote>
<h3 id="naming_strategy">naming_strategy</h3><p>设置和数据库的映射方式，主要表名，字段名，外键名等。<br>SpringNamingStrategy继承了ImprovedNamingStrategy，主要修复了外键名的问题，具体请见：<a href="http://stackoverflow.com/questions/7689206/ejb3namingstrategy-vs-improvednamingstrategy-foreign-key-naming" target="_blank" rel="external">http://stackoverflow.com/questions/7689206/ejb3namingstrategy-vs-improvednamingstrategy-foreign-key-naming</a></p>
]]></content>
    <summary type="html">
    <![CDATA[JPA是Sun官方提出的Java持久化规范。它为Java开发人员提供了一种对象/关系映射工具来管理Java应用中的关系数据。JPA的宗旨是为POJO提供持久化标准规范，伴随 Java EE 5 发布以来，受到了各大厂商及开源社区的追捧，各种商用的和开源的 JPA 框架如雨后春笋般出现，为开发者提供了丰富的选择。它一改之前 EJB 2.x 中实体 Bean 笨重且难以使用的形象，充分吸收了在开源社区已经相对成熟的 ORM 思想。另外，它并不依赖于 EJB 容器，可以作为一个独立的持久层技术而存在。目前比较成熟的 JPA 框架主要包括 Jboss 的 Hibernate EntityManager、Oracle 捐献给 Eclipse 社区的 EclipseLink(曾经的toplink)、Apache 的 OpenJPA等。所以使用Jpa的一个好处是，可以更换实现而不必改动太多代码。]]>
    
    </summary>
    
      <category term="spring" scheme="http://miclee.cn/categories/spring/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[maven scope 类型]]></title>
    <link href="http://miclee.cn/2015/12/28/maven-scope/"/>
    <id>http://miclee.cn/2015/12/28/maven-scope/</id>
    <published>2015-12-28T03:04:46.000Z</published>
    <updated>2016-04-07T03:45:14.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> 依赖范围控制哪些依赖在哪些classpath 中可用，哪些依赖包含在一个应用中。记录下以作备忘。 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="一、compile（编译范围）">一、compile（编译范围）</h2><p><strong>compile是默认的范围</strong>；如果没有提供一个范围，编译范围依赖在所有的classpath中可用，同时它们也会被打包。而且这些dependency会传递到依赖的项目中。</p>
<h2 id="二、provided（已提供范围）">二、provided（已提供范围）</h2><p>provided 指明了dependency 由JDK或者容器提供。例如如果开发了一个web 应用，可能在编译 classpath 中需要可用的Servlet API 来编译一个servlet，但是你不会想要在打包好的WAR 中包含这个Servlet API；这Servlet API JAR 由你的应用服务器或者servlet容器提供。已提供范围的依赖在编译classpath （不是运行时）可用。它们不是传递性的也不会被打包。</p>
<p>如：javax.servlet.jsp，jsp-api</p>
<h2 id="三、runtime（运行时范围）">三、runtime（运行时范围）</h2><p>runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如可能在编译的时候只需要JDBC API JAR，而只有在运行的时候才需要JDBC驱动实现。</p>
<p>如：mysql-connector-java</p>
<h2 id="四、test（测试范围）">四、test（测试范围）</h2><p>test范围依赖 在一般的编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用。典型的如junit。</p>
<h2 id="五、system（系统范围）">五、system（系统范围）</h2><p>system范围依赖与provided 类似，但是你必须显式的提供一个对于本地系统中JAR 文件的路径。这么做是为了允许基于本地对象编译，而这些对象是系统类库的一部分。这样的构件应该是一直可用的，Maven 也不会在仓库中去寻找它。如果你将一个依赖范围设置成系统范围，你必须同时提供一个 systemPath 元素。注意该范围是不推荐使用的（你应该一直尽量去从公共或定制的 Maven 仓库中引用依赖）。</p>
]]></content>
    <summary type="html">
    <![CDATA[依赖范围控制哪些依赖在哪些classpath 中可用，哪些依赖包含在一个应用中。记录下以作备忘。]]>
    
    </summary>
    
      <category term="maven" scheme="http://miclee.cn/tags/maven/"/>
    
      <category term="java" scheme="http://miclee.cn/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 和 Android 的后台推送原理]]></title>
    <link href="http://miclee.cn/2015/12/26/ios-android-push/"/>
    <id>http://miclee.cn/2015/12/26/ios-android-push/</id>
    <published>2015-12-26T07:42:15.000Z</published>
    <updated>2015-12-26T07:59:39.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> 因为手机平台本身、电量、网络流量的限制，移动互联网应用在设计上跟传统 PC 上的应用很大不一样，需要根据手机本身的特点，尽量的节省电量和流量，同时又要尽可能的保证数据能及时到达客户端。为了解决数据同步的问题，在手机平台上，常用的方法有2种。一种是定时去服务器上查询数据，也叫Polling，还有一种手机跟服务器之间维护一个 TCP 长连接，当服务器有数据时，实时推送到客户端，也就是我们说的 Push。从耗费的电量、流量和数据送达的及时性来说，Push都会有明显的优势，但 Push 的实现和维护成本相对较高。在移动无线网络下维护长连接，相对也有一些技术上的难度。本文介绍下IOS和Android目前不同的PUSH方案。 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="运行机制">运行机制</h2><p>iOS 系统的推送（APNS，即 Apple Push Notification Service）依托一个或几个系统常驻进程运作，是全局的（接管所有应用的消息推送），所以可看作是独立于应用之外，而且是设备和苹果服务器之间的通讯，而非应用的提供商服务器。如 腾讯 QQ 的服务器（Provider）会给苹果公司对应的服务器（APNs）发出通知，然后再中转传送到你的设备（Devices）之上。当你接收到通知，打开应用，才开始从腾讯服务器接收数据，跟你之前看到通知里内容一样，但却是经由两个不同的通道而来。</p>
<p>而 Android，就不同，更像是传统桌面电脑系统做法。每个需要后台推送的应用有各自的单独后台进程，才能和各自的服务器通讯，交换数据。另外其实 Android 也有类似 APNS 的 GCM（Google Cloud Message），属于开发者可选，非强制。所以你大概看出来区别，iOS 的消息推送机制面世之时是一种全新的解决方案（堪称平台中的平台），应用本身不能有常驻的后台进程，系统的开销少，内存使用更少，电量也更少（把更多的运算和资源开销放在云端，非设备端）。而 Android 的特点，虽然开销大，优点是更稳定快速，但不明显。</p>
<h2 id="实现原理">实现原理</h2><p>本质上，APNs 与 GCM 是类似的技术实现原理：即系统层有一个常驻的 TCP 长连接，一直保持的长连接，即使手机休眠的时候也在保持的长连接。这里对于大部分人来说，最不理解的就是，休眠时候都保持在那里的 TCP 长连接，不会耗电很厉害么？答案是：不会。这是手机的设计来做到的。TCP长连接有个心跳的时间，在国外可以很长比如30分钟，在国内则因为网络环境复杂一般10分钟。客户端发起的心跳，会短暂地消耗手机电能，但在这个心跳间隔期间，则消耗电能是很少的。当在心跳期间服务器端有推送信息过来时，客户端可以收到并做处理。</p>
<p>再说 APNs 的设计成功处。iOS 为了真正地为用户体验负责，不允许应用在后台活动。有了这个限制，但是对于终端设备，应用又是有必要“通知”到达用户的，随时与用户主动沟通起来的（典型的如聊天应用）。这就是 APNs 的逻辑所在：iOS 自己做个长驻后台保持连接。所有应用，有必要（申请）并且被允许（用户可以改设置）的话，可以通过 APNs 中转到达用户。这样就完善了！有可能很多人没有真正地体会到 iOS 不允许后台应用的好处。我是 Android 开发人员，Android 手机上一般只保留几个常用的应用，不常用就卸载。但是我的 iPhone / iPad 上则是，除非空间不足，一般不会删除应用。Android 就像 Windows，你要真的很费心去维护：有软件在干背后干坏事么？设备又给拖慢了，要清理。要考虑杀毒了。。。Android 因为后台可以长驻，尤其是国内的 Android 的手机上 Google自家的推送服务 GCM 处于基本不可用的状态。所以，各App各显神通。聊天类应用的话，大多数直接借用 XMPP 规范里的一些成果。少量如微信有IM底子的，自己开发协议。这些在实现原理上与 APNs / GCM 没有本质的区别，但有一定的技术门槛。而大多数普遍应用，要使用推送的话，则使用轮询的方式简单实现。其实，国外如 Urban Airship 自己实现了 Android 上的第三方提供的推送平台。近期国内如极光推送也实现了第三方的推送平台（技术与微信、GCM、APNs类似）。理论上，如果一个 Android 设备上多款应用都使用极光推送这种第三方推送平台的话，也可以如 APNs 一样达到节省电量、流量消耗的效果。</p>
]]></content>
    <summary type="html">
    <![CDATA[因为手机平台本身、电量、网络流量的限制，移动互联网应用在设计上跟传统 PC 上的应用很大不一样，需要根据手机本身的特点，尽量的节省电量和流量，同时又要尽可能的保证数据能及时到达客户端。为了解决数据同步的问题，在手机平台上，常用的方法有2种。一种是定时去服务器上查询数据，也叫Polling，还有一种手机跟服务器之间维护一个 TCP 长连接，当服务器有数据时，实时推送到客户端，也就是我们说的 Push。从耗费的电量、流量和数据送达的及时性来说，Push都会有明显的优势，但 Push 的实现和维护成本相对较高。在移动无线网络下维护长连接，相对也有一些技术上的难度。本文介绍下IOS和Android目前不同的PUSH方案。]]>
    
    </summary>
    
      <category term="push" scheme="http://miclee.cn/tags/push/"/>
    
      <category term="移动端" scheme="http://miclee.cn/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[spring-boot哎哟不错(七) —— 使用spring-boot 打包可执行jar和war包]]></title>
    <link href="http://miclee.cn/2015/12/25/spring-boot-7/"/>
    <id>http://miclee.cn/2015/12/25/spring-boot-7/</id>
    <published>2015-12-25T05:00:42.000Z</published>
    <updated>2015-12-25T05:35:25.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> 使用spring-boot 打包可执行jar和war包。spring-boot哎哟不错系列第七篇，哎哟不错系列只记录spring-boot使用过程中重要的部分。 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="一、官方说法">一、官方说法</h2><p>一旦spring-boot-maven-plugin被包含到你的pom.xml中，它就会自动尝试使用spring-boot:repackage目标重写存档以使它们能够执行。为了构建一个jar或war，你应该使用常规的packaging元素配置你的项目：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">    <span class="comment">&lt;!-- ... --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- ... --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure>
<p>生成的存档在package阶段会被Spring Boot增强。你想启动的main类即可以通过指定一个配置选项，也可以通过为manifest添加一个Main-Class属性这种常规的方式实现。如果你没有指定一个main类，该插件会搜索带有public static void main(String[] args)方法的类。</p>
<p>为了构建和运行一个项目的artifact，你可以输入以下命令：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mvn <span class="keyword">package</span></div><div class="line"><span class="title">$ java -jar target/mymodule-0.0.1-SNAPSHOT.jar</span></div></pre></td></tr></table></figure>
<p><strong>为了构建一个即是可执行的，又能部署到一个外部容器的war文件，你需要标记内嵌容器依赖为”provided”</strong>，例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">    <span class="comment">&lt;!-- ... --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- ... --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- ... --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="二、亲测">二、亲测</h2><h3 id="亲测一：JSP项目">亲测一：JSP项目</h3><p>存在设置情况下，各种运行情况（tomcat相关包在war包的lib-provided目录下）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ol>
<li>java -jar test.war   -&gt; OK</li>
<li>mvn spring-boot:run  -&gt; OK</li>
<li>tomcat 容器           -&gt; OK</li>
<li>run mainClass        -&gt; error 启动报错：java.lang.NoClassDefFoundError: javax/servlet/ServletContext，位于tomcat-embed-core，被打包到lib-provided。</li>
</ol>
<p>去掉设置或去掉provided（tomcat相关包在war包的lib目录下）:</p>
<ol>
<li>java -jar test.war   -&gt; OK</li>
<li>mvn spring-boot:run  -&gt; OK</li>
<li>tomcat 容器           -&gt; OK</li>
<li>run mainClass        -&gt; error 能启动，但访问404（无法解析JSP页面）</li>
</ol>
<h3 id="非JSP项目">非JSP项目</h3><p>非JSP项目去掉依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>存在设置情况下，各种运行情况（spring-boot-starter-tomcat-1.3.0.RELEASE.jar在war包的lib-provided目录下）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ol>
<li>java -jar test.war   -&gt; OK</li>
<li>mvn spring-boot:run  -&gt; OK</li>
<li>tomcat 容器           -&gt; OK</li>
<li>run mainClass        -&gt; OK</li>
</ol>
<p>去掉设置或去掉provided（spring-boot-starter-tomcat-1.3.0.RELEASE.jar在war包的lib包下）:</p>
<ol>
<li>java -jar test.war   -&gt; OK</li>
<li>mvn spring-boot:run  -&gt; OK</li>
<li>tomcat 容器           -&gt; OK</li>
<li>run mainClass        -&gt; OK</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[使用spring-boot 打包可执行jar和war包。spring-boot哎哟不错系列第七篇，哎哟不错系列只记录spring-boot使用过程中重要的部分。]]>
    
    </summary>
    
      <category term="spring" scheme="http://miclee.cn/tags/spring/"/>
    
      <category term="spring" scheme="http://miclee.cn/categories/spring/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[spring-boot哎哟不错(六) —— spring-boot 重要注解解析]]></title>
    <link href="http://miclee.cn/2015/12/23/spring-boot-6/"/>
    <id>http://miclee.cn/2015/12/23/spring-boot-6/</id>
    <published>2015-12-23T05:22:26.000Z</published>
    <updated>2016-04-07T02:44:37.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> spring-boot 重要注解解析。spring-boot哎哟不错系列第六篇，哎哟不错系列只记录spring-boot使用过程中重要的部分。 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="一、_@SpringBootApplication">一、 @SpringBootApplication</h2><ul>
<li><strong>spring-boot</strong> 定义的注解，属于包 <strong><em>org.springframework.boot.autoconfigure</em></strong>，先看源代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Indicates a &#123;<span class="doctag">@link</span> Configuration configuration&#125; class that declares one or more</div><div class="line"> * &#123;<span class="doctag">@link</span> Bean <span class="doctag">@Bean</span>&#125; methods and also triggers &#123;<span class="doctag">@link</span> EnableAutoConfiguration</div><div class="line"> * auto-configuration&#125; and &#123;<span class="doctag">@link</span> ComponentScan component scanning&#125;. This is a convenience</div><div class="line"> * annotation that is equivalent to declaring &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125;,</div><div class="line"> * &#123;<span class="doctag">@code</span> <span class="doctag">@EnableAutoConfiguration</span>&#125; and &#123;<span class="doctag">@code</span> <span class="doctag">@ComponentScan</span>&#125;.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> Phillip Webb</div><div class="line"> * <span class="doctag">@author</span> Stephane Nicoll</div><div class="line"> * <span class="doctag">@since</span> 1.2.0</div><div class="line"> */</div><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Inherited</span></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableAutoConfiguration</span></div><div class="line"><span class="meta">@ComponentScan</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Exclude specific auto-configuration classes such that they will never be applied.</div><div class="line">	 * <span class="doctag">@return</span> the classes to exclude</div><div class="line">	 */</div><div class="line">	Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Exclude specific auto-configuration class names such that they will never be</div><div class="line">	 * applied.</div><div class="line">	 * <span class="doctag">@return</span> the class names to exclude</div><div class="line">	 * <span class="doctag">@since</span> 1.3.0</div><div class="line">	 */</div><div class="line">	String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Base packages to scan for annotated components. Use &#123;<span class="doctag">@link</span> #scanBasePackageClasses&#125;</div><div class="line">	 * for a type-safe alternative to String-based package names.</div><div class="line">	 * <span class="doctag">@return</span> base packages to scan</div><div class="line">	 * <span class="doctag">@since</span> 1.3.0</div><div class="line">	 */</div><div class="line">	<span class="meta">@AliasFor</span>(annotation = ComponentScan.class, attribute = <span class="string">"basePackages"</span>)</div><div class="line">	String[] scanBasePackages() <span class="keyword">default</span> &#123;&#125;;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Type-safe alternative to &#123;<span class="doctag">@link</span> #scanBasePackages&#125; for specifying the packages to</div><div class="line">	 * scan for annotated components. The package of each class specified will be scanned.</div><div class="line">	 * &lt;p&gt;</div><div class="line">	 * Consider creating a special no-op marker class or interface in each package that</div><div class="line">	 * serves no purpose other than being referenced by this attribute.</div><div class="line">	 * <span class="doctag">@return</span> base packages to scan</div><div class="line">	 * <span class="doctag">@since</span> 1.3.0</div><div class="line">	 */</div><div class="line">	<span class="meta">@AliasFor</span>(annotation = ComponentScan.class, attribute = <span class="string">"basePackageClasses"</span>)</div><div class="line">	Class&lt;?&gt;[] scanBasePackageClasses() <span class="keyword">default</span> &#123;&#125;;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>元注解 @Target, @Retention, @Documented, @Inherited 的作用请见 <a href="http://miclee.cn/2015/12/22/spring-annotition/">spring注解原理剖析与实现</a>这篇博文。</p>
</li>
<li><p>很多Spring Boot开发者总是使用@Configuration，@EnableAutoConfiguration和@ComponentScan注解他们的main类。由于这些注解被如此频繁地一块使用，Spring Boot提供一个方便的@SpringBootApplication选择。所以@SpringBootApplication注解等价于以默认属性使用@Configuration，@EnableAutoConfiguration和@ComponentScan。下面延伸解析下这三个注解。</p>
</li>
</ul>
<h2 id="二、_@Configuration">二、 @Configuration</h2><ul>
<li><strong>spring</strong> 定义的注解，属于包 <strong><em>org.springframework.context.annotation</em></strong>，先看源代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration &#123;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Explicitly specify the name of the Spring bean definition associated</div><div class="line">	 * with this Configuration class.  If left unspecified (the common case),</div><div class="line">	 * a bean name will be automatically generated.</div><div class="line">	 * &lt;p&gt;The custom name applies only if the Configuration class is picked up via</div><div class="line">	 * component scanning or supplied directly to a &#123;<span class="doctag">@link</span> AnnotationConfigApplicationContext&#125;.</div><div class="line">	 * If the Configuration class is registered as a traditional XML bean definition,</div><div class="line">	 * the name/id of the bean element will take precedence.</div><div class="line">	 * <span class="doctag">@return</span> the specified bean name, if any</div><div class="line">	 * <span class="doctag">@see</span> org.springframework.beans.factory.support.DefaultBeanNameGenerator</div><div class="line">	 */</div><div class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>众所周知，Spring 框架是控制反转 (IOC) 或依赖性注入 (DI) 模式的推动因素，而这种推动是通过基于容器的配置实现的。过去，Spring 允许开发人员使用基于 XML 的配置，通过利用应用程序上下文 XML 文件来管理 bean 依赖性。此文件处于应用程序的外部，包含 bean 及其与该应用程序的依赖项的定义。尽管使用 XML 配置较为简单和便捷，但仍有另外一种方法可定义 bean 及其依赖项。这种方法也称为基于 Java 的配置。不同于 XML，基于 Java 的配置使您能够以编程方式管理 bean。这可通过运用多种注释来实现。</p>
<p>演示一个demo:</p>
<ol>
<li><p>xml版的bean定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"course"</span> <span class="attr">class</span>=<span class="string">"demo.Course"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"module"</span> <span class="attr">ref</span>=<span class="string">"module"</span>/&gt;</span></div><div class="line">  	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"module"</span> <span class="attr">class</span>=<span class="string">"demo.Module"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"assignment"</span> <span class="attr">ref</span>=<span class="string">"assignment"</span>/&gt;</span></div><div class="line">  	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"assignment"</span> <span class="attr">class</span>=<span class="string">"demo.Assignment"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>@Configuration 注解的配置类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppContext</span> </span>&#123;</div><div class="line">  	<span class="meta">@Bean</span></div><div class="line">  	<span class="function"><span class="keyword">public</span> Course <span class="title">course</span><span class="params">()</span> </span>&#123;</div><div class="line">  		Course course = <span class="keyword">new</span> Course();</div><div class="line">  		course.setModule(<span class="keyword">module</span>());</div><div class="line">  		<span class="keyword">return</span> course;</div><div class="line">  	&#125;</div><div class="line"></div><div class="line">  	<span class="meta">@Bean</span></div><div class="line">  	<span class="function"><span class="keyword">public</span> Module <span class="title">module</span><span class="params">()</span> </span>&#123;</div><div class="line">  		Module <span class="keyword">module</span> = <span class="keyword">new</span> Module();</div><div class="line">  		<span class="keyword">module</span>.setAssignment(assignment());</div><div class="line">  		<span class="keyword">return</span> <span class="keyword">module</span>;</div><div class="line">  	&#125;</div><div class="line"></div><div class="line">  	<span class="meta">@Bean</span></div><div class="line">  	<span class="function"><span class="keyword">public</span> Assignment <span class="title">assignment</span><span class="params">()</span> </span>&#123;</div><div class="line">  		<span class="keyword">return</span> <span class="keyword">new</span> Assignment();</div><div class="line">  	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>@Configuration 注释位于类的顶端。它告知 Spring 容器这个类是一个拥有 bean 定义和依赖项的配置类。 @Bean 注释用于定义 bean。上述注释位于实例化 bean 并设置依赖项的方法上方。方法名称与 bean id 或默认名称相同。该方法的返回类型是向 Spring 应用程序上下文注册的 bean。您可使用 bean 的 setter 方法来设置依赖项，容器将调用它们来连接相关项。基于 Java 的配置也被视为基于注释的配置。</p>
<blockquote>
<p>总体来说，就是告诉spring容器加载这个配置；<br>相对于xml的配置来说，这个注解的作用就是将spring-xxx.xml（某个配置文件）配置进web.xml</p>
</blockquote>
<h2 id="三、_@EnableAutoConfiguration">三、 @EnableAutoConfiguration</h2><ul>
<li><strong>spring-boot</strong> 定义的注解，属于包 <strong><em>org.springframework.boot.autoconfigure</em></strong>，先看源代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Inherited</span></div><div class="line"><span class="meta">@AutoConfigurationPackage</span></div><div class="line"><span class="meta">@Import</span>(EnableAutoConfigurationImportSelector.class)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Exclude specific auto-configuration classes such that they will never be applied.</div><div class="line">	 * <span class="doctag">@return</span> the classes to exclude</div><div class="line">	 */</div><div class="line">	Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Exclude specific auto-configuration class names such that they will never be</div><div class="line">	 * applied.</div><div class="line">	 * <span class="doctag">@return</span> the class names to exclude</div><div class="line">	 * <span class="doctag">@since</span> 1.3.0</div><div class="line">	 */</div><div class="line">	String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个注解告诉Spring Boot <strong><em>根据添加的jar依赖猜测你想如何配置Spring</em></strong>。比如spring-boot-starter-web添加了Tomcat和Spring MVC，所以auto-configuration将假定你正在开发一个web应用并相应地对Spring进行设置。</p>
<p>Starter POMs和Auto-Configuration：设计auto-configuration的目的是更好的使用”Starter POMs”，但这两个概念没有直接的联系。你可以自由地挑选starter POMs以外的jar依赖，并且Spring Boot将仍旧尽最大努力去自动配置你的应用。</p>
<h2 id="四、_@ComponentScan">四、 @ComponentScan</h2><ul>
<li><strong>spring</strong> 定义的注解，属于包 <strong><em>org.springframework.context.annotation</em></strong>，先看源代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ComponentScan &#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Alias for &#123;<span class="doctag">@link</span> #basePackages&#125;.</div><div class="line">	 * &lt;p&gt;Allows for more concise annotation declarations if no other attributes</div><div class="line">	 * are needed &amp;mdash; for example, &#123;<span class="doctag">@code</span> <span class="doctag">@ComponentScan</span>("org.my.pkg")&#125;</div><div class="line">	 * instead of &#123;<span class="doctag">@code</span> <span class="doctag">@ComponentScan</span>(basePackages = "org.my.pkg")&#125;.</div><div class="line">	 */</div><div class="line">	<span class="meta">@AliasFor</span>(<span class="string">"basePackages"</span>)</div><div class="line">	String[] value() <span class="keyword">default</span> &#123;&#125;;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Base packages to scan for annotated components.</div><div class="line">	 * &lt;p&gt;&#123;<span class="doctag">@link</span> #value&#125; is an alias for (and mutually exclusive with) this</div><div class="line">	 * attribute.</div><div class="line">	 * &lt;p&gt;Use &#123;<span class="doctag">@link</span> #basePackageClasses&#125; for a type-safe alternative to</div><div class="line">	 * String-based package names.</div><div class="line">	 */</div><div class="line">	<span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</div><div class="line">	String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</div><div class="line"></div><div class="line">	<span class="comment">//还有一些属性并不常用，所以不列举了。。。。。。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>@ComponentScan 注解的作用就是开启spring的注解扫描，与xml配置方式下的 <context:component-scan> 作用一样。<br>可以设置一个值指定basePackages，就是开始扫描的包。如果没有设置 <strong>默认从定义这个注解的类所属包开始一直到所有子包</strong>。</context:component-scan></li>
</ul>
<h2 id="五、_@Import">五、 @Import</h2><ul>
<li><strong>spring</strong> 定义的注解，属于包 <strong><em>org.springframework.context.annotation</em></strong>，先看源代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Import &#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * @&#123;<span class="doctag">@link</span> Configuration&#125;, &#123;<span class="doctag">@link</span> ImportSelector&#125;, &#123;<span class="doctag">@link</span> ImportBeanDefinitionRegistrar&#125;</div><div class="line">	 * or regular component classes to import.</div><div class="line">	 */</div><div class="line">	Class&lt;?&gt;[] value();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>@Import 与xml配置方式下的<import> 作用一样。支持导入的类型有：<ul>
<li>一个或多个拥有 @Configuration 注解的配置类</li>
<li>ImportSelector 接口的实现类</li>
<li>ImportBeanDefinitionRegistrar 的实现类</li>
</ul>
</import></li>
</ul>
<blockquote>
<p>如果Import注解中Class为ImportSelector子类，通过invokeAwareMethods(selector)设置aware值，如果类型为DeferredImportSelector则添加到deferredImportSelectors集合中，待前面的parser.parse(configCandidates)<br>方法中processDeferredImportSelectors()处理；如果不是，则执行selectImports方法，将获取到的结果递归调用processImports，解析selectImports得到的结果</p>
<p>如果Import注解中Class为ImportBeanDefinitionRegistrar子类，则添加到importBeanDefinitionRegistrars中，注意该部分的数据在执行完parser.parse(configCandidates)后调用this.reader.loadBeanDefinitions(configClasses)解析，否则执行配置信息的解析操作。</p>
</blockquote>
<h2 id="六、_@Conditional">六、 @Conditional</h2><ul>
<li><strong>spring</strong> 定义的注解，属于包 <strong><em>org.springframework.context.annotation</em></strong>，先看源代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Conditional &#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * All &#123;<span class="doctag">@link</span> Condition&#125;s that must &#123;<span class="doctag">@linkplain</span> Condition#matches match&#125;</div><div class="line">	 * in order for the component to be registered.</div><div class="line">	 */</div><div class="line">	Class&lt;? extends Condition&gt;[] value();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出value的值必须是实现了Condition接口的类，Condition接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Determine if the condition matches.</div><div class="line">	 * <span class="doctag">@param</span> context the condition context</div><div class="line">	 * <span class="doctag">@param</span> metadata metadata of the &#123;<span class="doctag">@link</span> org.springframework.core.type.AnnotationMetadata class&#125;</div><div class="line">	 * or &#123;<span class="doctag">@link</span> org.springframework.core.type.MethodMetadata method&#125; being checked.</div><div class="line">	 * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the condition matches and the component can be registered</div><div class="line">	 * or &#123;<span class="doctag">@code</span> false&#125; to veto registration.</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>matchs()返回true 表明该bean（注解了@Conditional的类）需要被创建，否则不创建。</p>
<blockquote>
<p>延伸几个 spring-boot提供的 @Conditional的子集，具体了Conditional的条件：</p>
<ul>
<li><strong>@ConditionalOnClass:</strong> 等同于 <strong><em>@Conditional(OnClassCondition.class)</em></strong>，表示存在对应的Class文件时才会去创建该bean</li>
<li><strong>@ConditionalOnMissingBean:</strong> 等同于 <strong><em>@Conditional(OnBeanCondition.class)</em></strong>，表示spring上下文里缺失某个bean时才会去创建该bean</li>
<li><strong>@ConditionalOnWebApplication:</strong> 等同于 <strong><em>@Conditional(OnWebApplicationCondition.class)</em></strong>，表示只有在WEB应用时才会创建该bean</li>
<li>更多请参考 <strong><em>org.springframework.boot.autoconfigure.condition</em></strong> 包下面的类</li>
</ul>
</blockquote>
<h2 id="七、_@EnableConfigurationProperties_&amp;&amp;_@ConfigurationProperties">七、 @EnableConfigurationProperties &amp;&amp; @ConfigurationProperties</h2><p>使用@Value(“${property}”)注解注入配置属性有时可能比较笨重，特别是需要使用多个properties或你的数据本身有层次结构。为了控制和校验你的应用配置，Spring Boot提供一个允许强类型beans的替代方法来使用properties。</p>
<p>示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"connection"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionSettings</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String username;</div><div class="line">    <span class="keyword">private</span> InetAddress remoteAddress;</div><div class="line">    <span class="comment">// ... getters and setters</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当@EnableConfigurationProperties注解应用到你的@Configuration时，任何被@ConfigurationProperties注解的beans将自动被Environment属性配置。这种风格的配置特别适合与SpringApplication的外部YAML配置进行配合使用。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># application.yml</span></div><div class="line"><span class="symbol">connection:</span></div><div class="line"><span class="symbol">    username:</span> admin</div><div class="line"><span class="symbol">    remoteAddress:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span></div><div class="line"><span class="meta"># additional configuration as required</span></div></pre></td></tr></table></figure>
<p>为了使用@ConfigurationProperties beans，你可以使用与其他任何bean相同的方式注入它们。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> ConnectionSettings connection;</div><div class="line">     <span class="comment">//...</span></div><div class="line">    <span class="meta">@PostConstruct</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openConnection</span><span class="params">()</span> </span>&#123;</div><div class="line">        Server server = <span class="keyword">new</span> Server();</div><div class="line">        <span class="keyword">this</span>.connection.configure(server);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可以通过在@EnableConfigurationProperties注解中直接简单的列出属性类来快捷的注册@ConfigurationProperties bean的定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="meta">@EnableConfigurationProperties</span>(ConnectionSettings.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> ConnectionSettings connection;</div><div class="line">     <span class="comment">//...</span></div><div class="line">    <span class="meta">@PostConstruct</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openConnection</span><span class="params">()</span> </span>&#123;</div><div class="line">        Server server = <span class="keyword">new</span> Server();</div><div class="line">        <span class="keyword">this</span>.connection.configure(server);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//@Component 这样ConnectionSettings类上面就不用标示 @Component注解了</span></div><div class="line"><span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"connection"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionSettings</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String username;</div><div class="line">    <span class="keyword">private</span> InetAddress remoteAddress;</div><div class="line">    <span class="comment">// ... getters and setters</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[spring-boot 重要注解解析。spring-boot哎哟不错系列第六篇，哎哟不错系列只记录spring-boot使用过程中重要的部分。]]>
    
    </summary>
    
      <category term="spring" scheme="http://miclee.cn/categories/spring/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[spring-boot哎哟不错(五) —— spring-boot 自定义配置详解]]></title>
    <link href="http://miclee.cn/2015/12/22/spring-boot-5/"/>
    <id>http://miclee.cn/2015/12/22/spring-boot-5/</id>
    <published>2015-12-22T07:39:10.000Z</published>
    <updated>2016-04-07T02:40:17.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> spring-boot 自定义配置详解。spring-boot哎哟不错系列第五篇，哎哟不错系列只记录spring-boot使用过程中重要的部分。 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="一、spring-boot支持的配置类型">一、spring-boot支持的配置类型</h2><ol>
<li><p><strong>.properties</strong> 以往常见，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">user.address.city=nanjing</div></pre></td></tr></table></figure>
</li>
<li><p><strong>.yml</strong> yaml格式的文件，如：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">user:</span></div><div class="line"><span class="attr">  address:</span></div><div class="line"><span class="attr">    city:</span> <span class="string">nanjing</span></div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>在yaml中缩进不要使用TAB，否则会解析错误</p>
</blockquote>
<h2 id="二、简单配置案例">二、简单配置案例</h2><ol>
<li><p>类路径下创建application.properties文件并定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">name = MicLee</div></pre></td></tr></table></figure>
</li>
<li><p>创建一个配置类来获取配置信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="meta">@Value</span>(<span class="string">"$&#123;name&#125;"</span>) String name;</div><div class="line"></div><div class="line">    <span class="comment">//TODO getter and setter</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在HelloWorldController.java调用配置bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/springboot"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldController</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> User user;</div><div class="line"></div><div class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/&#123;name&#125;"</span>, method = RequestMethod.GET)</div><div class="line">    <span class="meta">@ResponseBody</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayWorld</span><span class="params">(@PathVariable(<span class="string">"name"</span>)</span> String name) </span>&#123;</div><div class="line">        System.out.println(<span class="string">"userName:"</span> + user.getName());</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>启动工程，在命令行执行</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl http:<span class="regexp">//</span>localhost:<span class="number">8080</span><span class="regexp">/springboot/mi</span>clee</div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<ul>
<li>在spring boot中默认会加载<br>classpath:/ | classpath:/config/ | file:./ | file:./config/ 路径下以application命名的property或yaml文件；</li>
<li>参数spring.config.location设置配置文件存放位置；</li>
<li>参数spring.config.name设置配置文件名称；</li>
</ul>
</blockquote>
<h2 id="三、配置文件里获取随机数">三、配置文件里获取随机数</h2><p>在spring boot配置文件里能调用Random中的方法，如在application.properties中为user增加age参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">name=MicLee</div><div class="line">age=$&#123;random.int&#125;</div></pre></td></tr></table></figure></p>
<p>bean中同时增加参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="meta">@Value</span>(<span class="string">"$&#123;name&#125;"</span>) String name;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="meta">@Value</span>(<span class="string">"$&#123;age&#125;"</span>) Integer age;</div><div class="line"></div><div class="line">    <span class="comment">//TODO getter and setter</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>启动工程时会为age随机生成一个整数值：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$&#123;<span class="built_in">random</span>.<span class="keyword">int</span>(<span class="number">100</span>)&#125; : 限制生成的数字小于<span class="number">10</span></div><div class="line">$&#123;<span class="built_in">random</span>.<span class="keyword">int</span>[<span class="number">0</span>,<span class="number">100</span>]&#125; : 指定范围的数字</div></pre></td></tr></table></figure></p>
<h2 id="在配置文件中调用占位符">在配置文件中调用占位符</h2><p>修改配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">name=MicLee</div><div class="line">age=$&#123;random.int[0,100]&#125;</div><div class="line">remark=hello,my name is $&#123;name&#125;,age is $&#123;age&#125;.</div></pre></td></tr></table></figure></p>
<p>修改bean：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="meta">@Value</span>(<span class="string">"$&#123;name&#125;"</span>) String name;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="meta">@Value</span>(<span class="string">"$&#123;age&#125;"</span>) Integer age;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="meta">@Value</span>(<span class="string">"$&#123;remark&#125;"</span>) String remark;</div><div class="line">    <span class="comment">//TODO getter and setter</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="四、去掉_@Value_注解">四、去掉 @Value 注解</h2><p>在spring boot中属性的注入连 @Value 注解都不需要。<br>修改配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">name=MicLee</div><div class="line">age=$&#123;random.int[0,100]&#125;</div><div class="line">remark=hello,my name is $&#123;name&#125;,age is $&#123;age&#125;.</div><div class="line">user.address=China,Nanjing</div></pre></td></tr></table></figure></p>
<p>修改bean，增加注解 @ConfigurationProperties ：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"user"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="meta">@Value</span>(<span class="string">"$&#123;name&#125;"</span>) String name;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="meta">@Value</span>(<span class="string">"$&#123;age&#125;"</span>) Integer age;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="meta">@Value</span>(<span class="string">"$&#123;remark&#125;"</span>) String remark;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String address;</div><div class="line"></div><div class="line">    <span class="comment">//TODO getter and setter</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>使用@ConfigurationProperties需要指定prefix,同时bean中的属性和配置参数名保持一致。</p>
</blockquote>
<h2 id="五、实体嵌套配置">五、实体嵌套配置</h2><p>在User中定义一个Address实体同样可以快捷配置:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// User.java</span></div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"user"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="meta">@Value</span>(<span class="string">"$&#123;name&#125;"</span>) String name;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="meta">@Value</span>(<span class="string">"$&#123;age&#125;"</span>) Integer age;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="meta">@Value</span>(<span class="string">"$&#123;remark&#125;"</span>) String remark;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Address address;</div><div class="line"></div><div class="line">    <span class="comment">//TODO getter and setter</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Address.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String country;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String province;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String city;</div><div class="line"></div><div class="line">    <span class="comment">//TODO getter and setter</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>修改配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">name=MicLee</div><div class="line">age=$&#123;random.int[0,100]&#125;</div><div class="line">remark=hello,my name is $&#123;name&#125;,age is $&#123;age&#125;.</div><div class="line">user.address.country=China</div><div class="line">user.address.province=Jiangsu</div><div class="line">user.address.city=Nanjing</div></pre></td></tr></table></figure></p>
<p>这种嵌套关系如果通过yaml文件展示出来层次感会更强:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attr">user:</span></div><div class="line"><span class="attr">    address:</span></div><div class="line"><span class="attr">      country:</span><span class="string">China</span></div><div class="line"><span class="attr">      province:</span><span class="string">Jiangsu</span></div><div class="line"><span class="attr">      city:</span><span class="string">Nanjing</span></div></pre></td></tr></table></figure></p>
<h2 id="六、配置集合">六、配置集合</h2><p>一个人可能有多个联系地址，那么地址为集合:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// User.java</span></div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"user"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="meta">@Value</span>(<span class="string">"$&#123;name&#125;"</span>) String name;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="meta">@Value</span>(<span class="string">"$&#123;age&#125;"</span>) Integer age;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="meta">@Value</span>(<span class="string">"$&#123;remark&#125;"</span>) String remark;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Address address；</div><div class="line"></div><div class="line">    <span class="keyword">private</span> List&lt;Address&gt; addressList = <span class="keyword">new</span> ArrayList&lt;Address&gt;();</div><div class="line"></div><div class="line">    <span class="comment">//TODO getter and setter</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应的properties文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">user.addressList[0].country=China</div><div class="line">user.addressList[0].province=Jiangsu</div><div class="line">user.addressList[0].city=Nanjing</div><div class="line"></div><div class="line">user.addressList[1].country=China</div><div class="line">user.addressList[1].province=Anhui</div><div class="line">user.addressList[1].city=Anqing</div></pre></td></tr></table></figure></p>
<p>对应的yaml文件：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attr">user:</span></div><div class="line"><span class="attr">    -addressList:</span></div><div class="line"><span class="attr">      country:</span><span class="string">China</span></div><div class="line"><span class="attr">      province:</span><span class="string">Jiangsu</span></div><div class="line"><span class="attr">      city:</span><span class="string">Nanjing</span></div><div class="line"><span class="attr">    -addressList:</span></div><div class="line"><span class="attr">      country:</span><span class="string">China</span></div><div class="line"><span class="attr">      province:</span><span class="string">Anhui</span></div><div class="line"><span class="attr">      city:</span><span class="string">Anqing</span></div></pre></td></tr></table></figure></p>
<h2 id="七、多配置文件">七、多配置文件</h2><p>spring boot设置多配置文件很简单，可以在bean上使用注解 @Profile(“development”) 即调用application-development.properties|yml文件，也可以调用SpringApplication中的etAdditionalProfiles()方法，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Profile</span>(<span class="string">"development"</span>)</div><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        SpringApplication app = <span class="keyword">new</span> SpringApplication(Application.class);</div><div class="line">        <span class="comment">//   app.setAdditionalProfiles("development");</span></div><div class="line">        app.addListeners(<span class="keyword">new</span> MyApplicationStartedEventListener());</div><div class="line">        app.run(args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也可以通过启动时指定参数spring.profiles.active。</p>
<blockquote>
<p>在实际项目中最好是将配置参数抽离出来集中管理，比如利用淘宝的super-diamond ,consul,zk 等。</p>
</blockquote>
<h2 id="八、去掉@@Component注解">八、去掉@@Component注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//@Component  注解配置类User.java</span></div><div class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"user"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Integer age;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String remark;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String address;</div><div class="line"></div><div class="line">    <span class="comment">//TODO getter and setter</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//注解引入处 UserService.java</span></div><div class="line"><span class="meta">@EnableConfigurationProperties</span>(User.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> User user;</div><div class="line"></div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[spring-boot 自定义配置详解。spring-boot哎哟不错系列第五篇，哎哟不错系列只记录spring-boot使用过程中重要的部分。]]>
    
    </summary>
    
      <category term="spring" scheme="http://miclee.cn/categories/spring/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[spring注解原理剖析与实现]]></title>
    <link href="http://miclee.cn/2015/12/22/spring-annotition/"/>
    <id>http://miclee.cn/2015/12/22/spring-annotition/</id>
    <published>2015-12-22T05:47:51.000Z</published>
    <updated>2015-12-22T07:09:36.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> 讲述注解的基本概念和原理及其简单实用、以及自己实现一个 @Resource 注解来讲述其实现原理 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="一、注解的基本概念和原理">一、注解的基本概念和原理</h2><h3 id="1）概念">1）概念</h3><p>注解（Annotation）提供了一种安全的类似注释的机制，为我们在代码中添加信息提供了一种形式化得方法，使我们可以在稍后某个时刻方便的使用这些数据（通过解析注解来使用这些数据），用来将任何的信息或者元数据与程序元素（类、方法、成员变量等）进行关联。其实就是更加直观更加明了的说明，这些说明信息与程序业务逻辑没有关系，并且是供指定的工具或框架使用的。Annotation像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的申明语句中。</p>
<p>Annotation其实是一种接口。通过java的反射机制相关的API来访问Annotation信息。相关类（框架或工具中的类）根据这些信息来决定如何使用该程序元素或改变它们的行为。Java语言解释器在工作时会忽略这些Annotation，因此在JVM中这些Annotation是“不起作用”的，只能通过配套的工具才能对这些Annotation类型的信息进行访问和处理。</p>
<h3 id="2）Annotation和interface的异同">2）Annotation和interface的异同</h3><ol>
<li>Annotition的类型使用关键字 @interface 而不是interface。它继承了java.lang.annotition.Annotition接口，并非申明了一个interface。</li>
<li><p>Annotation类型、方法定义是独特的、受限制的：</p>
<ul>
<li><p>Annotation类型的方法必须申明为无参数、无异常抛出的。这些方法定义了 <strong>Annotation的成员：方法名为成员名，而方法返回值为成员的类型。</strong></p>
<blockquote>
<p>特别的，如果方法名为 value()， 则在注解的地方需要设置属性值时可以直接写入值，如：@Target({ElemenetType.TYPE}) 而不必写为 @Target(value={ElemenetType.TYPE})</p>
</blockquote>
</li>
<li><p>方法返回值必须为primitive类型、Class类型、枚举类型、Annotation类型或者由前面类型之一作为元素的一位数组。</p>
</li>
<li>方法的后面可以使用default关键字加一个默认数值来申明成员的默认值，null不能作为成员的默认值，这与我们在非Annotation类型中定义方法有很大不同。</li>
<li>Annotation类型和他的方法不能使用Annotation类型的参数，成员不能是generic。只有返回值类型是Class的方法可以在Annotation类型中使用generic，因为此方法能够用类转换将各种类型转换为Class。</li>
</ul>
</li>
<li>Annotation类型又与接口有着近似之处：它可以定义常量、静态成员类型（比如枚举类型定义）；Annotation类型也可以如接口一般被实现或者继承。</li>
</ol>
<h3 id="3）元注解_@Target,_@Retention,_@Documented,_@Inherited">3）元注解 @Target, @Retention, @Documented, @Inherited</h3><ol>
<li>@Target 表示该注解用于什么地方，可能的 ElemenetType 参数包括：<ul>
<li>ElemenetType.CONSTRUCTOR 构造器声明</li>
<li>ElemenetType.FIELD 域声明（包括 enum 实例）</li>
<li>ElemenetType.LOCAL_VARIABLE 局部变量声明</li>
<li>ElemenetType.METHOD 方法声明</li>
<li>ElemenetType.PACKAGE 包声明</li>
<li>ElemenetType.PARAMETER 参数声明</li>
<li>ElemenetType.TYPE 类，接口（包括注解类型）或enum声明</li>
</ul>
</li>
<li>@Retention 表示在什么级别保存该注解信息。可选的 RetentionPolicy 参数包括：<ul>
<li>RetentionPolicy.SOURCE 注解将被编译器丢弃</li>
<li>RetentionPolicy.CLASS 注解在class文件中可用，但会被VM丢弃</li>
<li>RetentionPolicy.RUNTIME VM将在运行期也保留注释，因此可以通过反射机制读取注解的信息</li>
</ul>
</li>
<li>@Documented 将此注解包含在 javadoc 中</li>
<li>@Inherited 允许子类继承父类中的注解</li>
</ol>
<h3 id="4）演示一个demo">4）演示一个demo</h3><ol>
<li><p>定义注解Test：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//该注解用于方法声明</span></div><div class="line"><span class="meta">@Target</span>(ElementType.METHOD)</div><div class="line"><span class="comment">//VM将在运行期也保留注释，因此可以通过反射机制读取注解的信息</span></div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="comment">//将此注解包含在javadoc中</span></div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="comment">//允许子类继承父类中的注解</span></div><div class="line"><span class="meta">@Inherited</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> "no description"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>使用注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_1</span></span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 被注释的三个方法</div><div class="line">     */</div><div class="line">    <span class="meta">@Test</span>(id = <span class="number">1</span>, description = <span class="string">"hello method1"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span>(id = <span class="number">2</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span>(id = <span class="number">3</span>, description = <span class="string">"last method3"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>解析注解:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Method[] methods = Test_1.class.getDeclaredMethods();</div><div class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</div><div class="line">            <span class="comment">//判断方法中是否有指定注解类型的注解</span></div><div class="line">            <span class="keyword">boolean</span> hasAnnotation = method.isAnnotationPresent(Test.class);</div><div class="line">            <span class="keyword">if</span> (hasAnnotation) &#123;</div><div class="line">                <span class="comment">//根据注解类型返回方法的指定类型注解</span></div><div class="line">                Test annotation = method.getAnnotation(Test.class);</div><div class="line">                System.out.println(<span class="string">"Test(method="</span> + method.getName() + <span class="string">",id="</span> + annotation.id()</div><div class="line">                                   + <span class="string">",description="</span> + annotation.description() + <span class="string">")"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="二、自定义_@Resource注解">二、自定义 @Resource注解</h2><h3 id="1）定义Annotition_@MicLeeResource">1）定义Annotition @MicLeeResource</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Target</span>( &#123; ElementType.FIELD, ElementType.METHOD &#125;)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MicLeeResource &#123;</div><div class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2）使用注解">2）使用注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeopleServiceImpl</span> <span class="keyword">implements</span> <span class="title">PeopleService</span> </span>&#123;</div><div class="line">    <span class="meta">@MicLeeResource</span></div><div class="line">    <span class="keyword">private</span> PeopleDao peopleDao;</div><div class="line">    <span class="keyword">private</span> String    name = <span class="string">"MicLee"</span>;</div><div class="line">    <span class="keyword">private</span> Integer   id   = <span class="number">1</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> peopleDao 或者注解在set方法上</div><div class="line">     */</div><div class="line">    <span class="comment">//@MicLeeResource</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPeopleDao</span><span class="params">(PeopleDao peopleDao)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.peopleDao = peopleDao;</div><div class="line">    &#125;</div><div class="line">…</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3）实现注入原理，在自定义spring容器中添加注解功能">3）实现注入原理，在自定义spring容器中添加注解功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MicLeeClassPathXMLApplicationContext</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//存放BeanDefinition的列表，在beans.xml中定义的bean可能不止一个</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;BeanDefinition&gt; beanDefines = <span class="keyword">new</span> ArrayList&lt;BeanDefinition&gt;();</div><div class="line">    <span class="comment">//将类名作为索引，将创建的Bean对象存入到Map中</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt;  sigletons   = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MicLeeClassPathXMLApplicationContext</span><span class="params">(String fileName)</span> </span>&#123;</div><div class="line">        <span class="comment">//读取xml配置文件</span></div><div class="line">        <span class="keyword">this</span>.readXML(fileName);</div><div class="line">        <span class="comment">//实例化bean</span></div><div class="line">        <span class="keyword">this</span>.instanceBeans();</div><div class="line">        <span class="comment">//处理注解方式</span></div><div class="line">        <span class="keyword">this</span>.annotationInject();</div><div class="line">        <span class="comment">//注入对象</span></div><div class="line">        <span class="keyword">this</span>.injectObject();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 使用注解方式注入对象方法实现</div><div class="line">     * <span class="doctag">@throws</span> IntrospectionException</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">annotationInject</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//循环所有bean对象</span></div><div class="line">        <span class="keyword">for</span> (String beanName : sigletons.keySet()) &#123;</div><div class="line">            <span class="comment">//获取bean对象</span></div><div class="line">            Object bean = sigletons.get(beanName);</div><div class="line">            <span class="comment">//如果bean不为空,取得bean的属性</span></div><div class="line">            <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">//按属性注入</span></div><div class="line">                    PropertyDescriptor[] ps = Introspector.getBeanInfo(bean.getClass())</div><div class="line">                        .getPropertyDescriptors();</div><div class="line">                    <span class="keyword">for</span> (PropertyDescriptor properdesc : ps) &#123;</div><div class="line">                        <span class="comment">//获取属性的setter方法</span></div><div class="line">                        Method setter = properdesc.getWriteMethod();</div><div class="line">                        <span class="comment">//判断注解是否存在</span></div><div class="line">                        <span class="keyword">if</span> (setter != <span class="keyword">null</span> &amp;&amp; setter.isAnnotationPresent(MicLeeResource.class)) &#123;</div><div class="line">                            <span class="comment">//取得注解</span></div><div class="line">                            MicLeeResource resource = setter.getAnnotation(MicLeeResource.class);</div><div class="line">                            Object value = <span class="keyword">null</span>;</div><div class="line">                            <span class="comment">//如果按名字找到</span></div><div class="line">                            <span class="keyword">if</span> (resource.name() != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(resource.name())) &#123;</div><div class="line">                                <span class="comment">//取得容器中的bean对象</span></div><div class="line">                                value = sigletons.get(resource.name());</div><div class="line"></div><div class="line">                            &#125; <span class="keyword">else</span> &#123;<span class="comment">//没有按名字找到，按类型寻找</span></div><div class="line">                                <span class="comment">//取得容器中的bean对象</span></div><div class="line">                                value = sigletons.get(resource.name());</div><div class="line">                                <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">                                    <span class="keyword">for</span> (String key : sigletons.keySet()) &#123;</div><div class="line">                                        <span class="keyword">if</span> (properdesc.getPropertyType().isAssignableFrom(</div><div class="line">                                            sigletons.get(key).getClass())) &#123;</div><div class="line">                                            value = sigletons.get(key);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        &#125;</div><div class="line">                                    &#125;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                            <span class="comment">//把引用对象注入到属性</span></div><div class="line">                            setter.setAccessible(<span class="keyword">true</span>);</div><div class="line">                            setter.invoke(bean, value);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//按字段注入</span></div><div class="line">                    Field[] fields = bean.getClass().getDeclaredFields();</div><div class="line">                    <span class="keyword">for</span> (Field field : fields) &#123;</div><div class="line">                        <span class="comment">//如果注解存在</span></div><div class="line">                        <span class="keyword">if</span> (field.isAnnotationPresent(MicLeeResource.class)) &#123;</div><div class="line">                            <span class="comment">//取得注解</span></div><div class="line">                            MicLeeResource resource = field.getAnnotation(MicLeeResource.class);</div><div class="line">                            Object value = <span class="keyword">null</span>;</div><div class="line">                            <span class="comment">//如果按名字找到</span></div><div class="line">                            <span class="keyword">if</span> (resource.name() != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(resource.name())) &#123;</div><div class="line">                                <span class="comment">//取得容器中的bean对象</span></div><div class="line">                                value = sigletons.get(resource.name());</div><div class="line">                            &#125; <span class="keyword">else</span> &#123;<span class="comment">//没有按名字找到，按类型寻找</span></div><div class="line">                                <span class="comment">//取得容器中的bean对象</span></div><div class="line">                                value = sigletons.get(field.getName());</div><div class="line">                                <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">                                    <span class="keyword">for</span> (String key : sigletons.keySet()) &#123;</div><div class="line">                                        <span class="keyword">if</span> (field.getType().isAssignableFrom(</div><div class="line">                                            sigletons.get(key).getClass())) &#123;</div><div class="line">                                            value = sigletons.get(key);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        &#125;</div><div class="line">                                    &#125;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                            <span class="comment">//允许访问private</span></div><div class="line">                            field.setAccessible(<span class="keyword">true</span>);</div><div class="line">                            field.set(bean, value);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (IntrospectionException e) &#123;</div><div class="line">                    <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</div><div class="line">                    <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">                    <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</div><div class="line">                    <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *为bean对象的属性注入值</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">injectObject</span><span class="params">()</span> </span>&#123;</div><div class="line">    ….</div><div class="line">    &#125;</div><div class="line">….</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>@MicLeeResource 注解本身不做任何事情，只是像xml文件一样起到配置作用。注解代表的是某种业务意义，注解背后处理器的工作原理如上源码实现：首先解析所有属性，判断属性上是否存在指定注解，如果存在则根据搜索规则取得bean，然后利用反射原理注入。如果标注在字段上面，也可以通过字段的反射技术取得注解，根据搜索规则取得bean，然后利用反射技术注入。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[讲述注解的基本概念和原理及其简单实用、以及自己实现一个 @Resource 注解来讲述其实现原理]]>
    
    </summary>
    
      <category term="annotation" scheme="http://miclee.cn/tags/annotation/"/>
    
      <category term="spring" scheme="http://miclee.cn/categories/spring/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[常用模板语言]]></title>
    <link href="http://miclee.cn/2015/12/18/template-language/"/>
    <id>http://miclee.cn/2015/12/18/template-language/</id>
    <published>2015-12-18T09:11:40.000Z</published>
    <updated>2016-04-07T03:45:14.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> 常用的模板引擎语言 </em></strong><br><a id="more"></a></p>
<hr>
<blockquote>
<p>在java领域，表现层技术主要有三种：jsp、freemarker、velocity<br>在javascript领域，主要有：EJS、Jade、doT、swig等等，参考<a href="http://garann.github.io/template-chooser/" target="_blank" rel="external">http://garann.github.io/template-chooser/</a></p>
</blockquote>
<h2 id="JSP">JSP</h2><h3 id="优点">优点</h3><ol>
<li>功能强大，可以写java代码</li>
<li>支持jsp标签（jsp tag）</li>
<li>支持表达式语言（el）</li>
<li>官方标准，用户群广，丰富的第三方jsp标签库</li>
<li>性能良好。jsp编译成class文件执行，有很好的性能表现<h3 id="缺点">缺点</h3>jsp没有明显缺点，非要挑点骨头那就是，由于可以编写java代码，如使用不当容易破坏mvc结构。</li>
</ol>
<h2 id="velocity是较早出现的用于代替jsp的模板语言">velocity是较早出现的用于代替jsp的模板语言</h2><h3 id="优点-1">优点</h3><ol>
<li>不能编写java代码，可以实现严格的mvc分离</li>
<li>性能良好，据说比jsp性能还要好些</li>
<li>使用表达式语言，据说jsp的表达式语言就是学velocity的<h3 id="缺点-1">缺点</h3></li>
<li>不是官方标准</li>
<li>用户群体和第三方标签库没有jsp多。</li>
<li>对jsp标签支持不够好</li>
</ol>
<h2 id="freemarker">freemarker</h2><h3 id="优点-2">优点</h3><ol>
<li>不能编写java代码，可以实现严格的mvc分离</li>
<li>性能。velocity应该是最好的，其次是jsp，普通的页面freemarker性能最差（虽然只是几毫秒到十几毫秒的差距）。但是在复杂页面上（包含大量判断. 日期金额格式化）的页面上，freemarker的性能比使用tag和el的jsp好。</li>
<li>对jsp标签支持良好</li>
<li>内置大量常用功能，比如html过滤，日期金额格式化等等，使用非常方便</li>
<li>宏定义（类似jsp标签）非常方便，优于jsp的tag</li>
<li>使用表达式语言<h3 id="缺点-2">缺点</h3></li>
<li>不是官方标准</li>
<li>用户群体和第三方标签库没有jsp多</li>
</ol>
<h2 id="Jade">Jade</h2><ul>
<li>Jade 很简洁，表达能力也很强，但不够直观，学习和适应成本高，大量的tab和空格容易出错。</li>
<li>Jade 处理模板时计算量大，在没有缓存的情况下性能低是肯定的。</li>
<li>Jade 对于一个不擅长前端、喜欢Bootstrap和Ctrl c + v 实在不能提高开发效率。</li>
<li>适合后端人员用</li>
</ul>
<h2 id="EJS">EJS</h2><p>简单易用的模板引擎，不过不支持继承，如果只是想要个模板往里面填充数据，是最好的选择</p>
]]></content>
    <summary type="html">
    <![CDATA[常用的模板引擎语言]]>
    
    </summary>
    
      <category term="template" scheme="http://miclee.cn/tags/template/"/>
    
      <category term="java" scheme="http://miclee.cn/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[spring-boot哎哟不错(三) —— 使用spring-boot开发WEB应用]]></title>
    <link href="http://miclee.cn/2015/12/18/spring-boot-3/"/>
    <id>http://miclee.cn/2015/12/18/spring-boot-3/</id>
    <published>2015-12-18T02:04:11.000Z</published>
    <updated>2015-12-24T00:56:54.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> Spring Boot非常适合开发WEB应用程序，你可以使用内嵌的Tomcat、Jetty或Undertow轻轻松松创建一个HTTP服务器。大多数的WEB应用都使用spring-boot-starter-web模块进行快速搭建和运行。spring-boot哎哟不错系列第三篇，哎哟不错系列只记录spring-boot使用过程中重要的部分。 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="Spring_Web_MVC_框架">Spring Web MVC 框架</h2><p>Spring MVC框架是一个富”模型，视图，控制器”的web框架。 Spring MVC允许你创建特定的 @Controller 或 @RestController beans来处理传入的HTTP请求。 使用 @RequestMapping 注解可以将控制器中的方法映射到相应的HTTP请求。以下是个典型的 @RestController ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/users"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRestController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/&#123;user&#125;"</span>, method=RequestMethod.GET)</div><div class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable Long user)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/&#123;user&#125;/customers"</span>, method=RequestMethod.GET)</div><div class="line">    <span class="function">List&lt;Customer&gt; <span class="title">getUserCustomers</span><span class="params">(@PathVariable Long user)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/&#123;user&#125;"</span>, method=RequestMethod.DELETE)</div><div class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">deleteUser</span><span class="params">(@PathVariable Long user)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Spring_MVC_auto-configuration">Spring MVC auto-configuration</h2><p>Spring Boot为Spring MVC提供适用于多数应用的自动配置功能。在Spring默认基础上，自动配置添加了以下特性：</p>
<ol>
<li>引入ContentNegotiatingViewResolver和BeanNameViewResolver beans。</li>
<li>对静态资源的支持，包括对WebJars的支持。</li>
<li>自动注册Converter，GenericConverter，Formatter beans。</li>
<li>对HttpMessageConverters的支持。</li>
<li>自动注册MessageCodeResolver。</li>
<li>对静态index.html的支持。</li>
<li>对自定义Favicon的支持。<br>如果想全面控制Spring MVC，你可以添加自己的@Configuration，并使用@EnableWebMvc对其注解。如果想保留Spring Boot MVC的特性，并只是添加其他的<a href="http://docs.spring.io/spring/docs/4.1.4.RELEASE/spring-framework-reference/htmlsingle/#mvc" target="_blank" rel="external">MVC配置</a>(拦截器，formatters，视图控制器等)，你可以添加自己的WebMvcConfigurerAdapter类型的@Bean（不使用@EnableWebMvc注解）</li>
</ol>
<h2 id="HttpMessageConverters">HttpMessageConverters</h2><p>Spring MVC使用HttpMessageConverter接口转换HTTP请求和响应。合理的缺省值被包含的恰到好处（out of the box），例如对象可以自动转换为JSON（使用Jackson库）或XML（如果Jackson XML扩展可用则使用它，否则使用JAXB）。字符串默认使用UTF-8编码。</p>
<p>如果需要添加或自定义转换器，你可以使用Spring Boot的HttpMessageConverters类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.web.HttpMessageConverters;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</div><div class="line"><span class="keyword">import</span> org.springframework.http.converter.*;</div><div class="line"></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> HttpMessageConverters <span class="title">customConverters</span><span class="params">()</span> </span>&#123;</div><div class="line">        HttpMessageConverter&lt;?&gt; additional = ...</div><div class="line">        HttpMessageConverter&lt;?&gt; another = ...</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpMessageConverters(additional, another);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>任何在上下文中出现的HttpMessageConverter bean将会添加到converters列表，你可以通过这种方式覆盖默认的转换器（converters）。</p>
<h2 id="MessageCodesResolver">MessageCodesResolver</h2><p>Spring MVC有一个策略，用于从绑定的errors产生用来渲染错误信息的错误码：MessageCodesResolver。如果设置spring.mvc.message-codes-resolver.format属性为PREFIX_ERROR_CODE或POSTFIX_ERROR_CODE（具体查看DefaultMessageCodesResolver.Format枚举值），Spring Boot会为你创建一个MessageCodesResolver。</p>
<h2 id="Static_静态内容">Static 静态内容</h2><p>默认情况下，Spring Boot从classpath下一个叫/static（/public，/resources或/META-INF/resources）的文件夹或从ServletContext根目录提供静态内容。这使用了Spring MVC的ResourceHttpRequestHandler，所以你可以通过添加自己的WebMvcConfigurerAdapter并覆写addResourceHandlers方法来改变这个行为（加载静态文件）。</p>
<p>在一个单独的web应用中，容器默认的servlet是开启的，如果Spring决定不处理某些请求，默认的servlet作为一个回退（降级）将从ServletContext根目录加载内容。大多数时候，这不会发生（除非你修改默认的MVC配置），因为Spring总能够通过DispatcherServlet处理请求。</p>
<p>此外，上述标准的静态资源位置有个例外情况是Webjars内容。任何在/webjars/** 路径下的资源都将从jar文件中提供，只要它们以Webjars的格式打包。</p>
<blockquote>
<p>注：如果你的应用将被打包成jar，那就不要使用src/main/webapp文件夹。尽管该文件夹是一个共同的标准，但它仅在打包成war的情况下起作用，并且如果产生一个jar，多数构建工具都会静悄悄的忽略它。</p>
</blockquote>
<h2 id="Template_engines_模板引擎">Template engines 模板引擎</h2><p>正如REST web服务，你也可以使用Spring MVC提供动态HTML内容。Spring MVC支持各种各样的模板技术，包括Velocity, FreeMarker和JSPs。很多其他的模板引擎也提供它们自己的Spring MVC集成。</p>
<p>Spring Boot为以下的模板引擎提供自动配置支持：</p>
<ul>
<li>FreeMarker</li>
<li>Groovy</li>
<li>Thymeleaf</li>
<li>Velocity</li>
<li>Mustache</li>
<li>JSPS</li>
</ul>
<blockquote>
<p>注：如果可能的话，应该忽略JSPs，因为在内嵌的servlet容器使用它们时存在一些<a href="http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-jsp-limitations" target="_blank" rel="external">已知的限制</a>:</p>
<ul>
<li>可执行的jar包不能工作（标准war包在tomcat里可以工作；可执行war包可以直接工作或部署在tomcat里）</li>
<li>不能使用Jetty作为内嵌式容器</li>
<li>不能使用Undertow作为容器</li>
</ul>
<p>使用jsp时必须增加Jasper模块依赖：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
</blockquote>
<p>Jasper子模块：这个子模块负责jsp页面的解析、jsp属性的验证，同时也负责将jsp页面动态转换为java代码并编译成class文件。在Tomcat源代码中，凡是属于org.apache.jasper包及其子包中的源代码都属于这个子模块；</p>
<p>当你使用这些引擎的任何一种，并采用默认的配置，你的模板将会从src/main/resources/templates目录下自动加载。</p>
<p>注：IntelliJ IDEA根据你运行应用的方式会对classpath进行不同的整理。在IDE里通过main方法运行你的应用跟从Maven或Gradle或打包好的jar中运行相比会导致不同的顺序。这可能导致Spring Boot不能从classpath下成功地找到模板。如果遇到这个问题，你可以在IDE里重新对classpath进行排序，将模块的类和资源放到第一位。或者，你可以配置模块的前缀为classpath*:/templates/，这样会查找classpath下的所有模板目录。</p>
<h2 id="Error_Handling_错误处理">Error Handling 错误处理</h2><p>Spring Boot默认提供一个/error映射用来以合适的方式处理所有的错误，并且它在servlet容器中注册了一个全局的 错误页面。对于机器客户端（相对于浏览器而言，浏览器偏重于人的行为），它会产生一个具有详细错误，HTTP状态，异常信息的JSON响应。对于浏览器客户端，它会产生一个白色标签样式（whitelabel）的错误视图，该视图将以HTML格式显示同样的数据（可以添加一个解析为erro的View来自定义它）。为了完全替换默认的行为，你可以实现ErrorController，并注册一个该类型的bean定义，或简单地添加一个ErrorAttributes类型的bean以使用现存的机制，只是替换显示的内容。</p>
<p>如果在某些条件下需要比较多的错误页面，内嵌的servlet容器提供了一个统一的Java DSL（领域特定语言）来自定义错误处理。 示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> EmbeddedServletContainerCustomizer <span class="title">containerCustomizer</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyCustomizer();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCustomizer</span> <span class="keyword">implements</span> <span class="title">EmbeddedServletContainerCustomizer</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableEmbeddedServletContainer container)</span> </span>&#123;</div><div class="line">        container.addErrorPages(<span class="keyword">new</span> ErrorPage(HttpStatus.BAD_REQUEST, <span class="string">"/400"</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你也可以使用常规的Spring MVC特性来处理错误，比如@ExceptionHandler方法和@ControllerAdvice。ErrorController将会捡起任何没有处理的异常。</p>
<p>N.B. 如果你为一个路径注册一个ErrorPage，最终被一个过滤器（Filter）处理（对于一些非Spring web框架，像Jersey和Wicket这很常见），然后过滤器需要显式注册为一个ERROR分发器（dispatcher）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">myFilter</span><span class="params">()</span> </span>&#123;</div><div class="line">    FilterRegistrationBean registration = <span class="keyword">new</span> FilterRegistrationBean();</div><div class="line">    registration.setFilter(<span class="keyword">new</span> MyFilter());</div><div class="line">    ...</div><div class="line">    registration.setDispatcherTypes(EnumSet.allOf(DispatcherType.class));</div><div class="line">    <span class="keyword">return</span> registration;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注：默认的FilterRegistrationBean没有包含ERROR分发器类型。</p>
<h2 id="Servlets和Filters">Servlets和Filters</h2><p>当使用内嵌的servlet容器时，你可以直接将servlet和filter注册为Spring的beans。在配置期间，如果你想引用来自application.properties的值，这是非常方便的。默认情况下，如果上下文只包含单一的Servlet，那它将被映射到根路径（/）。在多Servlet beans的情况下，bean的名称将被用作路径的前缀。过滤器会被映射到 /*。</p>
<p>如果基于约定（convention-based）的映射不够灵活，你可以使用ServletRegistrationBean和FilterRegistrationBean类实现完全的控制。如果你的bean实现了ServletContextInitializer接口，也可以直接注册它们。</p>
<h2 id="EmbeddedWebApplicationContext">EmbeddedWebApplicationContext</h2><p>Spring Boot底层使用了一个新的ApplicationContext类型，用于对内嵌servlet容器的支持。EmbeddedWebApplicationContext是一个特殊类型的WebApplicationContext，它通过搜索一个单一的EmbeddedServletContainerFactory bean来启动自己。通常，TomcatEmbeddedServletContainerFactory，JettyEmbeddedServletContainerFactory或UndertowEmbeddedServletContainerFactory将被自动配置。</p>
<p>注：你通常不需要知道这些实现类。大多数应用将被自动配置，并根据你的行为创建合适的ApplicationContext和EmbeddedServletContainerFactory。</p>
<h2 id="自定义内嵌servlet容器">自定义内嵌servlet容器</h2><p>常见的Servlet容器设置可以通过Spring Environment属性进行配置。通常，你会把这些属性定义到application.properties文件中。 常见的服务器设置包括：</p>
<p>server.port - 进来的HTTP请求的监听端口号<br>server.address - 绑定的接口地址<br>server.sessionTimeout - session超时时间<br>具体参考<a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java" target="_blank" rel="external">ServerProperties</a>。</p>
<p>编程方式的自定义<br>如果需要以编程的方式配置内嵌的servlet容器，你可以注册一个实现EmbeddedServletContainerCustomizer接口的Spring bean。EmbeddedServletContainerCustomizer提供对ConfigurableEmbeddedServletContainer的访问，ConfigurableEmbeddedServletContainer包含很多自定义的setter方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.boot.context.embedded.*;</div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</div><div class="line"></div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizationBean</span> <span class="keyword">implements</span> <span class="title">EmbeddedServletContainerCustomizer</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableEmbeddedServletContainer container)</span> </span>&#123;</div><div class="line">        container.setPort(<span class="number">9000</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>直接自定义ConfigurableEmbeddedServletContainer<br>如果上面的自定义手法过于受限，你可以自己注册TomcatEmbeddedServletContainerFactory，JettyEmbeddedServletContainerFactory或UndertowEmbeddedServletContainerFactory。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> EmbeddedServletContainerFactory <span class="title">servletContainer</span><span class="params">()</span> </span>&#123;</div><div class="line">    TomcatEmbeddedServletContainerFactory factory = <span class="keyword">new</span> TomcatEmbeddedServletContainerFactory();</div><div class="line">    factory.setPort(<span class="number">9000</span>);</div><div class="line">    factory.setSessionTimeout(<span class="number">10</span>, TimeUnit.MINUTES);</div><div class="line">    factory.addErrorPages(<span class="keyword">new</span> ErrorPage(HttpStatus.NOT_FOUND, <span class="string">"/notfound.html"</span>);</div><div class="line">    <span class="keyword">return</span> factory;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很多可选的配置都提供了setter方法，也提供了一些受保护的钩子方法以满足你的某些特殊需求。具体参考相关文档。</p>
]]></content>
    <summary type="html">
    <![CDATA[Spring Boot非常适合开发WEB应用程序，你可以使用内嵌的Tomcat、Jetty或Undertow轻轻松松创建一个HTTP服务器。大多数的WEB应用都使用spring-boot-starter-web模块进行快速搭建和运行。spring-boot哎哟不错系列第三篇，哎哟不错系列只记录spring-boot使用过程中重要的部分。]]>
    
    </summary>
    
      <category term="spring" scheme="http://miclee.cn/tags/spring/"/>
    
      <category term="spring" scheme="http://miclee.cn/categories/spring/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[spring-boot哎哟不错(二) —— HelloWorld]]></title>
    <link href="http://miclee.cn/2015/12/17/spring-boot-2/"/>
    <id>http://miclee.cn/2015/12/17/spring-boot-2/</id>
    <published>2015-12-17T07:06:38.000Z</published>
    <updated>2015-12-25T02:44:22.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> 动手构建基于spring-boot的hello world。spring-boot哎哟不错系列第二篇，哎哟不错系列只记录spring-boot使用过程中重要的部分。 </em></strong><br><a id="more"></a></p>
<hr>
<h3 id="1-1_创建项目">1.1 创建项目</h3><p>按照约定我们使用Maven来创建一个空项目：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mvn archetype:generate\</div><div class="line">-<span class="ruby">DgroupId=com.mycompany.app\</span></div><div class="line">-<span class="ruby">DartifactId=hello-spring-boot\</span></div><div class="line">-<span class="ruby">DarchetypeArtifactId=maven-archetype-quickstart\</span></div><div class="line">-<span class="ruby">DinteractiveMode=<span class="literal">false</span></span></div></pre></td></tr></table></figure>
<p>不出意外的话，我们应该会得到一个这样的目录：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── pom.xml</div><div class="line">└── src</div><div class="line">    ├── main</div><div class="line">    │   └── java</div><div class="line">    │       └── com</div><div class="line">    │           └── mycompany</div><div class="line">    │               └── <span class="keyword">app</span></div><div class="line">    │                   └── <span class="keyword">App</span>.java</div><div class="line">    └── <span class="keyword">test</span></div><div class="line">        └── java</div><div class="line">            └── com</div><div class="line">                └── mycompany</div><div class="line">                    └── <span class="keyword">app</span></div><div class="line">                        └── AppTest.java</div></pre></td></tr></table></figure>
<p>接下来就应该添加项目依赖了：在<code>pom.xml</code>中添加</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后再添加一个SpringBoot的Maven插件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div></pre></td></tr></table></figure>
<p>编写代码<code>com.mycompany.app.Application</code>如下：（注意包名哦）</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.mycompany.app;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</div><div class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.RequestMapping;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.RestController;</div><div class="line"></div><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> static void main(String[] args) &#123;</div><div class="line">        SpringApplication.run(Application.<span class="keyword">class</span>, args);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/hello"</span>)</span></div><div class="line">    <span class="keyword">public</span> String hello() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"hello, spring-boot."</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码完成！我们把它运行起来吧。简单使用指令<code>mvn spring-boot:run</code>。<br>看到一大堆屏幕输入以后，有提示出现了：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">...</span> <span class="string">...</span></div><div class="line"><span class="number">2015</span><span class="bullet">-07</span><span class="bullet">-31</span> <span class="number">16</span><span class="string">:26:36.722</span>  <span class="string">INFO</span> <span class="number">10037</span> <span class="meta">---</span> <span class="string">[</span>           <span class="string">main]</span> <span class="string">o.s.j.e.a.AnnotationMBeanExporter</span>        <span class="string">:</span> <span class="string">Registering</span> <span class="string">beans</span> <span class="string">for</span> <span class="string">JMX</span> <span class="string">exposure</span> <span class="string">on</span> <span class="string">startup</span></div><div class="line"><span class="number">2015</span><span class="bullet">-07</span><span class="bullet">-31</span> <span class="number">16</span><span class="string">:26:36.780</span>  <span class="string">INFO</span> <span class="number">10037</span> <span class="meta">---</span> <span class="string">[</span>           <span class="string">main]</span> <span class="string">s.b.c.e.t.TomcatEmbeddedServletContainer</span> <span class="string">:</span> <span class="string">Tomcat</span> <span class="string">started</span> <span class="string">on</span> <span class="string">port(s):</span> <span class="number">8080</span> <span class="string">(http)</span></div><div class="line"><span class="number">2015</span><span class="bullet">-07</span><span class="bullet">-31</span> <span class="number">16</span><span class="string">:26:36.781</span>  <span class="string">INFO</span> <span class="number">10037</span> <span class="meta">---</span> <span class="string">[</span>           <span class="string">main]</span> <span class="string">com.mycompany.app.Application</span>            <span class="string">:</span> <span class="string">Started</span> <span class="string">Application</span> <span class="string">in</span> <span class="number">2.312</span> <span class="string">seconds</span> <span class="string">(JVM</span> <span class="string">running</span> <span class="string">for</span> <span class="number">2.717</span><span class="string">)</span></div></pre></td></tr></table></figure>
<p>用浏览器访问以下<code>http://127.0.0.1/hello</code>，看看。</p>
<p>恭喜你！你的第一个SpringBoot程序运行起来了。<br><br>不过在欣喜之余，有没有感到有一丝不安？这个项目里没有<code>xml</code>的Spring配置文件；没有日志配置文件；甚至连<code>web.xml</code>都没有，一个基于<code>Servlet</code>和<code>Spring MVC</code>技术的程序就启动起来了。<br>你一定猜到了，这就是所谓的<code>约定优于配置</code>，麻雀虽小，五脏俱全，该有的组件当然都是存在于Spring上下文的，只不过都是采用的默认配置方式。下一个小节，小老弟展示给你看。</p>
<h3 id="1-2_SpringBoot到底做了什么？">1.2 SpringBoot到底做了什么？</h3><p>到了祭出SpringBoot的一个<code>starter</code>的时候了。所谓<code>starter</code>的，其实就是SpringBoot的插件啦。 注意，我指的是SpringBoot插件，可不是说“SpringBoot相关Maven插件”，这个概念请理解。<br>我们在<a href="https://github.com/yingzhuo/play-with-spring-boot/blob/master/chapter13/index.md" target="_blank" rel="external">第13章</a>，将自己从头到尾自己写一个具有完整功能的<code>spring-boot-starter</code>。<br><br>这个<code>starter</code>的Maven坐标如下：快把它加到<code>pom.xml</code>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这个插件功能比较强大，它“默默地”给你的SpringBoot程序，加上了一些<code>Controller</code>，来帮你达到监控等目的。好，加好了就可以，其他什么事情都不用做。<br>重新启动这个项目<code>mvn spring-boot:run</code>，再访问以下<code>http://127.0.0.1/beans</code>，看看。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  &#123;</div><div class="line">  <span class="attr">"context"</span> : <span class="string">"application"</span>,</div><div class="line">  <span class="attr">"parent"</span> : <span class="literal">null</span>,</div><div class="line">  <span class="attr">"beans"</span> : [ &#123;</div><div class="line">    <span class="attr">"bean"</span> : <span class="string">"application"</span>,</div><div class="line">    <span class="attr">"scope"</span> : <span class="string">"singleton"</span>,</div><div class="line">    <span class="attr">"type"</span> : <span class="string">"com.mycompany.app.Application$$EnhancerBySpringCGLIB$$a295be6a"</span>,</div><div class="line">    <span class="attr">"resource"</span> : <span class="string">"null"</span>,</div><div class="line">    <span class="attr">"dependencies"</span> : [ ]</div><div class="line">  &#125;, &#123;</div><div class="line">    <span class="attr">"bean"</span> : <span class="string">"org.springframework.boot.autoconfigure.PropertyPlaceholderAutoConfiguration"</span>,</div><div class="line">    <span class="attr">"scope"</span> : <span class="string">"singleton"</span>,</div><div class="line">    <span class="attr">"type"</span> : <span class="string">"org.springframework.boot.autoconfigure.PropertyPlaceholderAutoConfiguration$$EnhancerBySpringCGLIB$$1a9215c6"</span>,</div><div class="line">    <span class="attr">"resource"</span> : <span class="string">"null"</span>,</div><div class="line">    <span class="attr">"dependencies"</span> : [ ]</div><div class="line">  &#125;, &#123;</div><div class="line">    <span class="attr">"bean"</span> : <span class="string">"org.springframework.boot.autoconfigure.condition.BeanTypeRegistry"</span>,</div><div class="line">    <span class="attr">"scope"</span> : <span class="string">"singleton"</span>,</div><div class="line">    <span class="attr">"type"</span> : <span class="string">"org.springframework.boot.autoconfigure.condition.BeanTypeRegistry$OptimizedBeanTypeRegistry"</span>,</div><div class="line">    <span class="attr">"resource"</span> : <span class="string">"null"</span>,</div><div class="line">    <span class="attr">"dependencies"</span> : [ ]</div><div class="line">  &#125;, &#123;</div><div class="line">    <span class="attr">"bean"</span> : <span class="string">"propertySourcesPlaceholderConfigurer"</span>,</div><div class="line">    <span class="attr">"scope"</span> : <span class="string">"singleton"</span>,</div><div class="line">    <span class="attr">"type"</span> : <span class="string">"org.springframework.context.support.PropertySourcesPlaceholderConfigurer"</span>,</div><div class="line">    <span class="attr">"resource"</span> : <span class="string">"class path resource [org/springframework/boot/autoconfigure/PropertyPlaceholderAutoConfiguration.class]"</span>,</div><div class="line">    <span class="attr">"dependencies"</span> : [ ]</div><div class="line">  &#125;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>不知道你发现了没有，我上面的的JSON是非常漂亮地被格式化了，非常方便阅读，你的浏览器看到的JSON，都是挤作一个团儿，非常难受吧。</p>
<p>添加一个文件：<code>classpath:/META-INF/application.properties</code>，并添加仅仅一条配置。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">spring<span class="selector-class">.jackson</span><span class="selector-class">.serialization</span><span class="selector-class">.indent_output</span>=true</div></pre></td></tr></table></figure>
<p>注意！小老弟是因为受篇幅的限制只列出了三项，这个一定要亲手试一试。在你遇到问题时，请使用此功能，你一定要非常了解你的Spring上下文中到底<br>有些什么组件，如果不是这样的话，可是很容易踩到坑的。 小老弟严肃地开发时，这些bean的源代码，都是一定要大致浏览一遍的。这里先告诉各位一个基本方法，<br>以后我们谈到具体某种技术的时候，再来详细剖析也不迟。</p>
<h3 id="1-3_SpringBoot配置文件">1.3 SpringBoot配置文件</h3><p>正如上一个部分的小节你看到的：<code>classpath:META-INF/application.properties</code>。使用SpringBoot的一个好处就是你可以从成吨的<code>.xml</code>配置文件中稍微<br>解放出一点点。SpringBoot提供两种配置方式，<code>.properties</code>(你已经看到了)，另一种配置方式是<code>.yml</code>。你要是问我哪种方式更好，那么我告诉你，两种差不多。<br>你要问我为什么在整个文章坚持使用<code>.properties</code>，我还真没法回答你，小老弟我是南方人，虽然甜粽子也好吃，但我更偏好咸粽子。<br>想使用<code>.yml</code>方式配置的朋友自己看官方文档吧。</p>
<p>诸如上面提到的<code>spring.jackson.serialization.indent_output</code>我姑且称呼为“SpringBoot预设配置”，SpringBoot提供的预设配置非常丰富，而且相当一部分是有默认值的。<br>如果你还是SpringBoot新手，那么你可能看得一头雾水。没关系，以后慢慢解释。官方文档附录收录了所有预设配置，请<a href="http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#common-application-properties" target="_blank" rel="external">点击</a>这里。</p>
<p>除了“SpringBoot预设配置”之外，我们能自定义吗？当然可以了。此外SpringBoot还提供了一个有用的元注释<code>@EnableConfigurationProperties</code> <br><br>它完整的名称是<code>org.springframework.boot.context.properties.EnableConfigurationProperties</code>，它的用法非常简单了。</p>
<p>假设你的配置：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foo<span class="selector-class">.bar</span><span class="selector-class">.name</span>=BillGates</div><div class="line">foo<span class="selector-class">.bar</span><span class="selector-class">.age</span>=<span class="number">60</span></div><div class="line">foo<span class="selector-class">.bar</span><span class="selector-class">.phone-number</span>=<span class="number">13812345678</span></div></pre></td></tr></table></figure></p>
<p>你可以使用这样一个Bean来封装这样的配置:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"foo.bar"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfigBean</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">    <span class="keyword">private</span> String phoneNumber;</div><div class="line"></div><div class="line">    <span class="comment">// getter and setter</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你就可以让SpringBoot自动帮你把配置绑定到<code>MyConfigBean</code>上了。就像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;MyConfigBean.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Resource</span></div><div class="line">    <span class="keyword">private</span> MyConfigBean myConfigBean;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>非常方便吧？光是这样还不够好，其实你的<code>ConfigBean</code>里还可以添加上<code>hibernate-validator</code>(JSR-303)元注释，用来验证配置的正确性。这里就不举例子了，自己试一试就知道了。<br><br>其实还有一种配置项的读取方法，SpringBoot把所有的配置放在一个<code>Placeholder Configurer</code>这种方式出现的非常早了，早在Spring2.x时代貌似就有了。你如果对<code>xml</code>方式配置Spring的话，<br>你可能对下面一个片段比较熟悉。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driverClass&#125;"</span> /&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span> /&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span> /&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果你现在依然用<code>xml</code>来配置Spring的话，你的<code>application.properties</code>依然能这么用，这毫无问题。如果你使用“Java Code”配置Spring的话，你可以使用<code>@Value</code>元注释。<br>(这是Spring提供的功能，和SpringBoot关系并不大)就像是下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;foo.bar.name&#125;"</span>)</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;foo.bar.age&#125;"</span>)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;foo.bar.phone-number&#125;"</span>)</div><div class="line">    <span class="keyword">private</span> phoneNumber;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> MyStupidBean <span class="title">myStupidBean</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyStupidBean(name, age, phoneNumber);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1-4_Spring配置文件">1.4 Spring配置文件</h3><p>小老弟整个教程都将采用”Java Code”配置方式，但是你要是非要用<code>xml</code>或者你更激进一点喜欢使用<code>groovy dsl</code>，也不是不行。你可以这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@ImportResource</span>(&#123;<span class="string">"classpath:conf1.xml"</span>, <span class="string">"classpath:conf2.groovy"</span>&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        SpringApplication.run(Application.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>配置方式，并没有孰优孰劣之分。不要因为这个与别人争吵，挑一个你自己喜欢的方式就可以了。</p>
<h3 id="1-5_关于Bean的Scan。">1.5 关于Bean的Scan。</h3><p>小老弟习惯用Bean的扫描，如果不用的话，所有的业务Bean，比如说”DAO”，”SERVICE”都需要一个个手工配置的，我觉得这并没有什么实际的好处。<br>事实上，<code>@SpringBootApplication</code>元注释“封装”了<code>@ComponentScan</code>，你使用<code>@SpringBootApplication</code>的同时，包扫描就自动打开了。<br>那么，我们的问题就来了，从哪个package开始扫描呢？是这样的，它扫描启动main方法所在的那个类所在的包及其所有的子包。稍微有点绕吧，没看懂的再看一遍。</p>
<p>如果你正在开发一个基于SpringBoot的应用。那么官方给出的最佳实践是这样。看一看下面的目录结构。</p>
<ul>
<li>com.mycompany.myapp<ul>
<li>dao<ul>
<li>impl</li>
</ul>
</li>
<li>service<ul>
<li>impl</li>
</ul>
</li>
<li>controller</li>
<li>domain</li>
</ul>
</li>
</ul>
<p>大约就是这样的，你的启动程序及其Spring的所有配置类都直接放在<code>com.mycompany.myapp</code>package下。其他的业务相关的组件，让它们被扫描到上下文就好了。<br>SpringBoot建议你保持配置的清爽。 小老弟的所有配套示例代码，也基本上是使用这样一个package结构。</p>
<p>请意识到，上面小节给出的”hello world”程序，<code>com.mycompany.app.Application</code>即是一个配置类，又同时是一个<code>Spring MVC Controller</code>，这只是为了使代码简短而生造的一个例子。</p>
]]></content>
    <summary type="html">
    <![CDATA[动手构建基于spring-boot的hello world。spring-boot哎哟不错系列第二篇，哎哟不错系列只记录spring-boot使用过程中重要的部分。]]>
    
    </summary>
    
      <category term="spring-boot" scheme="http://miclee.cn/tags/spring-boot/"/>
    
      <category term="spring" scheme="http://miclee.cn/categories/spring/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为什么要使用SLF4J而不是Log4J]]></title>
    <link href="http://miclee.cn/2015/12/17/slf4j/"/>
    <id>http://miclee.cn/2015/12/17/slf4j/</id>
    <published>2015-12-17T05:36:11.000Z</published>
    <updated>2016-04-07T03:45:14.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> 每一个Java程序员都知道日志对于任何一个Java应用程序，尤其是服务端程序是至关重要的，而很多程序员也已经熟悉各种不同的日志库如java.util.logging、Apache log4j、logback。但如果你还不知道SLF4J（Simple logging facade for Java）的话，那么是时候去在你项目中学习使用SLF4J了。 在这篇文章中，我们将学习为什么使用SLF4J比log4j或者java.util.logging要优秀。 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="介绍">介绍</h2><p>SLF4J不同于其他日志类库，与其它有很大的不同。SLF4J(Simple logging Facade for Java)不是一个真正的日志实现，而是一个抽象层（ abstraction layer），它允许你在后台使用任意一个日志类库。如果是在编写供内外部都可以使用的API或者通用类库，那么你真不会希望使用你类库的客户端必须使用你选择的日志类库。</p>
<p>如果一个项目已经使用了log4j，而你加载了一个类库，比方说 Apache Active MQ——它依赖于于另外一个日志类库logback，那么你就需要把它也加载进去。但如果Apache Active MQ使用了SLF4J，你可以继续使用你的日志类库而无语忍受加载和维护一个新的日志框架的痛苦。</p>
<p>总的来说，SLF4J使你的代码独立于任意一个特定的日志API，这是一个对于开发API的开发者很好的思想。虽然抽象日志类库的思想已经不是新鲜的事物而且Apache commons logging也已经在使用这种思想了，但现在SLF4J正迅速成为Java世界的日志标准。让我们再看看几个使用SLF4J而不是log4j、logback或者java.util.logging的理由。</p>
<h2 id="SLF4J对比Log4J，logback和java-util-Logging的优势">SLF4J对比Log4J，logback和java.util.Logging的优势</h2><p>正如我之前说的，在你的代码中使用SLF4J写日志语句的主要出发点是使得你的程序独立于任意特定的日志类库，依赖于特定类可能需要不同与你已有的配置，并且导致更多维护的麻烦。但除此之外，还要一个SLF4J API的特性使得我坚持使用SLF4J而抛弃我长期间钟爱的Lof4j的理由，是被称为占位符(place holder)，在代码中表示为“{}”的特性。占位符是一个非常类似于在String的format()方法中的%s，因为它会在运行时被某个提供的实际字符串所替换。这不仅降低了你代码中字符串连接次数，而且还节省了新建的String对象。即使你可能没需要那些对象，但这个依旧成立，取决于你的生产环境的日志级别，例如在DEBUG或者INFO级别的字符串连接。因为String对象是不可修改的并且它们建立在一个String池中，它们消耗堆内存( heap memory)而且大多数时间他们是不被需要的，例如当你的应用程序在生产环境以ERROR级别运行时候，一个String使用在DEBUG语句就是不被需要的。通过使用SLF4J,你可以在运行时延迟字符串的建立，这意味着只有需要的String对象才被建立。而如果你已经使用log4j，那么你已经对于在if条件中使用debug语句这种变通方案十分熟悉了，但SLF4J的占位符就比这个好用得多。</p>
<p>这是你在Log4j中使用的方案，但肯定这一点都不有趣并且降低了代码可读性因为增加了不必要的繁琐重复代码(boiler-plate code)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">    logger.debug(<span class="string">"Processing trade with id: "</span> + id + <span class="string">" symbol: "</span> + symbol);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另一方面，如果你使用SLF4J的话，你可以得到在极简洁的格式的结果，就像以下展示的一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">logger.debug(<span class="string">"Processing trade with id: &#123;&#125; and symbol : &#123;&#125; "</span>, id, symbol);</div></pre></td></tr></table></figure>
<p>在SLF4J，我们不需要字符串连接而且不会导致暂时不需要的字符串消耗。取而代之的，我们在一个以占位符和以参数传递实际值的模板格式下写日志信息。你可能会在想万一我有很个参数怎么办？嗯，那么你可以选择使用变量参数版本的日志方法或者用以Object数组传递。这是一个相当的方便和高效方法的打日志方法。记住，在生产最终日志信息的字符串之前，这个方法会检查一个特定的日志级别是不是打开了，这不仅降低了内存消耗而且预先降低了CPU去处理字符串连接命令的时间。这里是使用SLF4J日志方法的代码，来自于slf4j-log4j12-1.6.1.jar中的Log4j的适配器类Log4jLoggerAdapter。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String format, Object arg1, Object arg2)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">        FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);</div><div class="line">        logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同时，我们也很值得知道打日志是对应用程序的性能有着很大影响的，在生产环节上只进行必要的日志记录是我们所建议的。</p>
<h2 id="怎么用SLF4J做Log4J的日志记录">怎么用SLF4J做Log4J的日志记录</h2><p>除了以上好处，我想还有一个告诫，就是为了使用SLF4J，你不仅需要包含SLF4J的API jar包，例如 slf4j-api-1.6.1.jar，还需要相关Jar包，这取决于你在后台使用的日志类库。如果你想要使用和Log4J 一起使用SLF4J ，Simple Logging Facade for Java,，你需要包含以下的Jar包在你的classpath中，取决于哪个SLF4J和你在使用的Log4J的版本。例如：</p>
<ul>
<li>slf4j-api-1.6.1.jar – JAR for SLF4J API</li>
<li>log4j-1.2.16.jar – JAR for Log4J API</li>
<li>slf4j-log4j12-1.6.1.jar – Log4J Adapter for SLF4J</li>
</ul>
<p>如果你在使用Maven去管理你的项目依赖，你只需要包含SLF4J JAR包，maven会包含它的依赖的相关包。为了和SLF4J一起中使用Log4J，你可以包含以下的依赖在你项目中的pom.xml。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>还有，如果你对于使用变量参数版本（variable argument version ）的日志方法感兴趣的话，那么就导入SLF4J 1.7的版本吧。</p>
<h2 id="总结">总结</h2><p>总结这次说的，我建议使用SLF4J的而不是直接使用 Log4j, commons logging, logback 或者 java.util.logging 已经足够充分了。</p>
<ol>
<li>在你的开源或内部类库中使用SLF4J会使得它独立于任何一个特定的日志实现，这意味着不需要管理多个日志配置或者多个日志类库，你的客户端会很感激这点。</li>
<li>SLF4J提供了基于占位符的日志方法，这通过去除检查isDebugEnabled(), isInfoEnabled()等等，提高了代码可读性。</li>
<li>通过使用SLF4J的日志方法，你可以延迟构建日志信息（Srting）的开销，直到你真正需要，这对于内存和CPU都是高效的。</li>
<li>作为附注，更少的暂时的字符串意味着垃圾回收器（Garbage Collector）需要做更好的工作，这意味着你的应用程序有为更好的吞吐量和性能。</li>
<li>这些好处只是冰山一角，你将在开始使用SL4J和阅读其中代码的时候知道更多的好处。我强烈建议，任何一个新的Java程序员，都应该使用SLF4J做日志而不是使用包括Log4J在内的其他日志API。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[每一个Java程序员都知道日志对于任何一个Java应用程序，尤其是服务端程序是至关重要的，而很多程序员也已经熟悉各种不同的日志库如java.util.logging、Apache log4j、logback。但如果你还不知道SLF4J（Simple logging facade for Java）的话，那么是时候去在你项目中学习使用SLF4J了。 在这篇文章中，我们将学习为什么使用SLF4J比log4j或者java.util.logging要优秀。]]>
    
    </summary>
    
      <category term="slf4j" scheme="http://miclee.cn/tags/slf4j/"/>
    
      <category term="java" scheme="http://miclee.cn/categories/java/"/>
    
  </entry>
  
</feed>
