<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[MicLee's Bolg]]></title>
  <subtitle><![CDATA[技术创造价值，分享带来快乐]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://miclee.cn/"/>
  <updated>2016-04-20T10:51:57.000Z</updated>
  <id>http://miclee.cn/</id>
  
  <author>
    <name><![CDATA[MicLee]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[React开发神器Webpack]]></title>
    <link href="http://miclee.cn/2016/04/20/React%E5%BC%80%E5%8F%91%E7%A5%9E%E5%99%A8Webpack/"/>
    <id>http://miclee.cn/2016/04/20/React开发神器Webpack/</id>
    <published>2016-04-20T09:19:55.000Z</published>
    <updated>2016-04-20T10:51:57.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> Webpack是功能最为强大的前端模块管理和打包工具。虽然Webpack是一个通用的工具，并不只适合于React，但是很多React的文章或者项目都使用了Webpack，尤其是react-hot-loader这样的神器存在，让Webpack成为最主流的React开发工具。 </em></strong><br><a id="more"></a></p>
<hr>
<p>Webpack将项目中用到的一切静态资源都视之为模块，模块之间可以互相依赖。Webpack对它们进行统一的管理以及打包发布。</p>
<h2 id="一、安装Webpack">一、安装Webpack</h2><p>Webpack一般作为全局的npm模块安装：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> Webpack</span></span><br></pre></td></tr></table></figure>
<p>直接执行此命令会默认使用当前目录的webpack.config.js作为配置文件。如果要指定另外的配置文件，可以执行：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack —config webpack<span class="class">.custom</span><span class="class">.config</span><span class="class">.js</span></span><br></pre></td></tr></table></figure>
<h2 id="二、Webpack模块加载器（Loaders）">二、Webpack模块加载器（Loaders）</h2><p>Webpack将所有静态资源都认为是模块，比如JavaScript，CSS，LESS，TypeScript，JSX，CoffeeScript，图片等等，从而可以对其进行统一管理。每一种资源都可以通过对应的加载器处理成模块。和大多数包管理器不一样的是，Webpack的加载器之间可以进行串联，一个加载器的输出可以成为另一个加载器的输入。比如LESS文件先通过less-load处理成css，然后再通过css-loader加载成css模块，最后由style-loader加载器对其做最后的处理，从而运行时可以通过style标签将其应用到最终的浏览器环境。</p>
<p>为了让Webpack识别什么样的资源应该用什么加载器去载入，需要在配置文件进行配置：通过正则表达式对文件名进行匹配。</p>
<h2 id="三、config文件">三、config文件</h2><p>配置文件通常放在项目根目录之下，其本身也是一个标准的CommonJS模块。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: <span class="string">'./build'</span>, <span class="comment">// 打包文件存放的绝对路径</span></span><br><span class="line">    publicPath: <span class="string">'/build'</span>, <span class="comment">// 网站运行时的访问路径</span></span><br><span class="line">    filename: <span class="string">'bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123; <span class="comment">//resolve 指定可以被 import 的文件后缀。比如 Hello.jsx 这样的文件就可以直接用 import Hello from 'Hello' 引用。</span></span><br><span class="line">       extensions: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'.jsx'</span>]</span><br><span class="line">   &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    loaders: [</span><br><span class="line">      &#123; test: <span class="regexp">/\.(js|jsx)$/</span>, loader: <span class="string">'babel'</span> &#125;, <span class="comment">//指定 babel-loader 编译后缀名为 .js 或者 .jsx的文件。</span></span><br><span class="line">      &#123; test: <span class="regexp">/\.less$/</span>, loader: <span class="string">'style-loader!css-loader!less-loader'</span> &#125;,</span><br><span class="line">      &#123; test: <span class="regexp">/\.css$/</span>, loader: <span class="string">'style-loader!css-loader'</span> &#125;,</span><br><span class="line">      &#123; test: <span class="regexp">/\.(png|jpg)$/</span>, loader: <span class="string">'url-loader?limit=8192'</span> &#125; <span class="comment">// inline base64 URLs for &lt;=8k images, direct URLs for the rest</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="四、webpack服务器">四、webpack服务器</h2><p>在webpack里面有一个开发工具就是可以自动开启一个服务器。可以和webpack一样作为全局的npm模块安装：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> webpack-dev-<span class="keyword">server</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="五、实现热替换(HMR)功能">五、实现热替换(HMR)功能</h2><ul>
<li><p>Webpack本身具有运行时模块替换功能，称之为Hot Module Replacement (HMR)。</p>
<p>当某个模块代码发生变化时，Webpack实时打包将其推送到页面并进行替换，从而无需刷新页面就实现代码替换。这个过程相对比较复杂，需要进行多方面考虑和配置。</p>
</li>
<li><p>使用react-hot-loader加载器</p>
<p>针对React出现了一个第三方react-hot-loader加载器，使用这个加载器就可以轻松实现React组件的热替换，非常方便。其实正是因为React的每一次更新都是全局刷新的虚拟DOM机制，让React组件的热替换可以成为通用的加载器，从而极大提高开发效率。</p>
</li>
<li><p>使用监听模式</p>
<p>‘webpack –watch’命令，不过需要手动刷新页面，但不需要重启服务。</p>
<h3 id="react-hot-loader加载器具体实现：">react-hot-loader加载器具体实现：</h3><ul>
<li><p>1、安装依赖</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react-hot-loader --<span class="built_in">save</span>-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2、更改webpack.config.js<br>为了热加载React组件，我们需要在前端页面中加入相应的代码，用以接收Webpack推送过来的代码模块，进而可以通知所有相关React组件进行重新Render:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line">...</span><br><span class="line">entry: [</span><br><span class="line">  <span class="string">'webpack-dev-server/client?http://127.0.0.1:8080'</span>, <span class="comment">// WebpackDevServer host and port</span></span><br><span class="line">  <span class="string">'webpack/hot/only-dev-server'</span>,</span><br><span class="line">  <span class="string">'./main'</span> <span class="comment">// Your appʼs entry point</span></span><br><span class="line">]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>3、下一步，我们需要让Webpack用react-hot-loader去加载React组件:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line">...</span><br><span class="line">loaders: [&#123;</span><br><span class="line">    test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">    loader: <span class="string">'react-hot!babel'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  …</span><br><span class="line">]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>4、修改package.json文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "build": "webpack",</span><br><span class="line">  "dev": "webpack-dev-server --devtool eval --progress --colors --hot --content-base"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>参数含义：</p>
<ul>
<li>webpack-dev-server - 在 localhost:8080 建立一个 Web 服务器</li>
<li>devtool eval - 为你的代码创建源地址。当有任何报错的时候可以让你更加精确地定位到文件和行号</li>
<li>progress - 显示合并代码进度</li>
<li>colors - Yay，命令行中显示颜色！</li>
<li>hot - 开启HMR参数hot</li>
<li>content-base - 指向设置的输出目录,后面可以写你想指向的输出目录 不写默认为空目录</li>
</ul>
<ul>
<li>5、使用<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="command">run</span> dev</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[Webpack是功能最为强大的前端模块管理和打包工具。虽然Webpack是一个通用的工具，并不只适合于React，但是很多React的文章或者项目都使用了Webpack，尤其是react-hot-loader这样的神器存在，让Webpack成为最主流的React开发工具。]]>
    
    </summary>
    
      <category term="react" scheme="http://miclee.cn/tags/react/"/>
    
      <category term="react" scheme="http://miclee.cn/categories/react/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Catalina_Base和Catalina_HOME的区别]]></title>
    <link href="http://miclee.cn/2016/02/23/Catalina-Base/"/>
    <id>http://miclee.cn/2016/02/23/Catalina-Base/</id>
    <published>2016-02-23T06:58:14.000Z</published>
    <updated>2016-02-23T07:00:59.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> catalina.home和catalina.base这两个属性仅在你需要安装多个Tomcat实例而不想安装多个软件备份的时候使用，这样能节省磁盘空间。 </em></strong><br><a id="more"></a></p>
<hr>
<p>以Tomcat6.0为例，其Tomcat目录结构如下：<br>bin (运行脚本）<br>conf (配置文件）<br>lib (核心库文件）<br>logs (日志目录)<br>temp (临时目录)<br>webapps (自动装载的应用程序的目录）<br>work (JVM临时文件目录[java.io.tmpdir]) </p>
<p>让我们看看这些目录那些可以被多个Tomcat实例公用，其实只有 bin 和 lib 目录,其它目录conf、logs、temp、webapps和work每个Tomcat实例必须拥有其自己独立的备份。<br>明白了上述关系就容易理解catalina.home和catalina.base的用途了。<br>catalina.home指向公用信息的位置，就是bin和lib的父目录。<br>catalina.base指向每个Tomcat目录私有信息的位置，就是conf、logs、temp、webapps和work的父目录。</p>
<h1 id="仅运行一个Tomcat实例时，这两个属性指向的位置是相同的。">仅运行一个Tomcat实例时，这两个属性指向的位置是相同的。</h1><p>我们可以从Tomcat 5.5 的配置文档（<a href="http://tomcat.apache.org/tomcat-5.5-doc/config/host.html" target="_blank" rel="external">http://tomcat.apache.org/tomcat-5.5-doc/config/host.html</a> ）中找到答案：</p>
<p>The description below uses the variable name $CATALINA_HOME to refer to the directory into which you have installed Tomcat 5, and is the base directory against which most relative paths are resolved. However, if you have configured Tomcat 5 for multiple instances by setting a CATALINA_BASE directory, you should use $CATALINA_BASE instead of $CATALINA_HOME for each of these references.</p>
<p>从这段描述可以看出CATALINA_HOME 和CATALINA_BASE 的区别。简单的说，CATALINA_HOME 是Tomcat 的安装目录，CATALINA_BASE 是Tomcat 的工作目录。如果我们想要运行Tomcat 的多个实例，但是不想安装多个Tomcat 软件副本。那么我们可以配置多个工作目录，每个运行实例独占一个工作目录，但是共享同一个安装目录。</p>
<p>Tomcat 每个运行实例需要使用自己的conf 、logs 、temp 、webapps 、work 和shared 目录，因此CATALINA_BASE 就指向这些目录。 而其他目录主要包括了Tomcat 的二进制文件和脚本，CATALINA_HOME 就指向这些目录。</p>
<p>如果我们希望再运行另一个Tomcat 实例，那么我们可以建立一个目录，把conf 、logs 、temp 、webapps 、work 和shared 拷贝到该目录下，然后让CATALINA_BASE 指向该目录即可。</p>
]]></content>
    <summary type="html">
    <![CDATA[catalina.home和catalina.base这两个属性仅在你需要安装多个Tomcat实例而不想安装多个软件备份的时候使用，这样能节省磁盘空间。]]>
    
    </summary>
    
      <category term="tomcat" scheme="http://miclee.cn/categories/tomcat/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[spring-boot哎哟不错(八) —— 使用jpa]]></title>
    <link href="http://miclee.cn/2016/01/13/spring-boot-8/"/>
    <id>http://miclee.cn/2016/01/13/spring-boot-8/</id>
    <published>2016-01-13T07:26:46.000Z</published>
    <updated>2016-01-13T07:55:23.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> JPA是Sun官方提出的Java持久化规范。它为Java开发人员提供了一种对象/关系映射工具来管理Java应用中的关系数据。JPA的宗旨是为POJO提供持久化标准规范，伴随 Java EE 5 发布以来，受到了各大厂商及开源社区的追捧，各种商用的和开源的 JPA 框架如雨后春笋般出现，为开发者提供了丰富的选择。它一改之前 EJB 2.x 中实体 Bean 笨重且难以使用的形象，充分吸收了在开源社区已经相对成熟的 ORM 思想。另外，它并不依赖于 EJB 容器，可以作为一个独立的持久层技术而存在。目前比较成熟的 JPA 框架主要包括 Jboss 的 Hibernate EntityManager、Oracle 捐献给 Eclipse 社区的 EclipseLink(曾经的toplink)、Apache 的 OpenJPA等。所以使用Jpa的一个好处是，可以更换实现而不必改动太多代码。 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="Spring-Boot持久层发展历史">Spring-Boot持久层发展历史</h2><p><img src="https://raw.githubusercontent.com/OfMicLee/img-hosting/master/java/spring-boot-jpa.png" alt="spring-boot-jpa"></p>
<h2 id="Spring-boot-jpa_常用配置">Spring-boot-jpa 常用配置</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring:&#10;  jpa:&#10;     database: MYSQL&#10;     show-sql: true&#10;     hibernate:&#10;           ddl-auto: update&#10;           # ddl-auto: none, create, create-drop, update, validate&#10;           naming_strategy: org.springframework.boot.orm.jpa.hibernate.SpringNamingStrategy&#10;           # naming_strategy: org.hibernate.cfg.ImprovedNamingStrategy</span><br></pre></td></tr></table></figure>
<h3 id="ddl-auto">ddl-auto</h3><p>主要用于：自动创建|更新|验证数据库表结构。如果不是此方面的需求建议set value=”none”。</p>
<ul>
<li><p>create ：<br>每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。</p>
</li>
<li><p>create-drop ：<br>每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。</p>
</li>
<li><p>update：<br>最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据 model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等 应用第一次运行起来后才会。</p>
</li>
<li><p>validate ：<br>每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。</p>
</li>
</ul>
<blockquote>
<p>当为内嵌数据库时（hsqldb/h2/derby）默认为 create-drop<br>外部数据库默认 none</p>
</blockquote>
<h3 id="naming_strategy">naming_strategy</h3><p>设置和数据库的映射方式，主要表名，字段名，外键名等。<br>SpringNamingStrategy继承了ImprovedNamingStrategy，主要修复了外键名的问题，具体请见：<a href="http://stackoverflow.com/questions/7689206/ejb3namingstrategy-vs-improvednamingstrategy-foreign-key-naming" target="_blank" rel="external">http://stackoverflow.com/questions/7689206/ejb3namingstrategy-vs-improvednamingstrategy-foreign-key-naming</a></p>
]]></content>
    <summary type="html">
    <![CDATA[JPA是Sun官方提出的Java持久化规范。它为Java开发人员提供了一种对象/关系映射工具来管理Java应用中的关系数据。JPA的宗旨是为POJO提供持久化标准规范，伴随 Java EE 5 发布以来，受到了各大厂商及开源社区的追捧，各种商用的和开源的 JPA 框架如雨后春笋般出现，为开发者提供了丰富的选择。它一改之前 EJB 2.x 中实体 Bean 笨重且难以使用的形象，充分吸收了在开源社区已经相对成熟的 ORM 思想。另外，它并不依赖于 EJB 容器，可以作为一个独立的持久层技术而存在。目前比较成熟的 JPA 框架主要包括 Jboss 的 Hibernate EntityManager、Oracle 捐献给 Eclipse 社区的 EclipseLink(曾经的toplink)、Apache 的 OpenJPA等。所以使用Jpa的一个好处是，可以更换实现而不必改动太多代码。]]>
    
    </summary>
    
      <category term="spring" scheme="http://miclee.cn/categories/spring/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[maven scope 类型]]></title>
    <link href="http://miclee.cn/2015/12/28/maven-scope/"/>
    <id>http://miclee.cn/2015/12/28/maven-scope/</id>
    <published>2015-12-28T03:04:46.000Z</published>
    <updated>2016-04-07T03:45:14.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> 依赖范围控制哪些依赖在哪些classpath 中可用，哪些依赖包含在一个应用中。记录下以作备忘。 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="一、compile（编译范围）">一、compile（编译范围）</h2><p><strong>compile是默认的范围</strong>；如果没有提供一个范围，编译范围依赖在所有的classpath中可用，同时它们也会被打包。而且这些dependency会传递到依赖的项目中。</p>
<h2 id="二、provided（已提供范围）">二、provided（已提供范围）</h2><p>provided 指明了dependency 由JDK或者容器提供。例如如果开发了一个web 应用，可能在编译 classpath 中需要可用的Servlet API 来编译一个servlet，但是你不会想要在打包好的WAR 中包含这个Servlet API；这Servlet API JAR 由你的应用服务器或者servlet容器提供。已提供范围的依赖在编译classpath （不是运行时）可用。它们不是传递性的也不会被打包。</p>
<p>如：javax.servlet.jsp，jsp-api</p>
<h2 id="三、runtime（运行时范围）">三、runtime（运行时范围）</h2><p>runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如可能在编译的时候只需要JDBC API JAR，而只有在运行的时候才需要JDBC驱动实现。</p>
<p>如：mysql-connector-java</p>
<h2 id="四、test（测试范围）">四、test（测试范围）</h2><p>test范围依赖 在一般的编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用。典型的如junit。</p>
<h2 id="五、system（系统范围）">五、system（系统范围）</h2><p>system范围依赖与provided 类似，但是你必须显式的提供一个对于本地系统中JAR 文件的路径。这么做是为了允许基于本地对象编译，而这些对象是系统类库的一部分。这样的构件应该是一直可用的，Maven 也不会在仓库中去寻找它。如果你将一个依赖范围设置成系统范围，你必须同时提供一个 systemPath 元素。注意该范围是不推荐使用的（你应该一直尽量去从公共或定制的 Maven 仓库中引用依赖）。</p>
]]></content>
    <summary type="html">
    <![CDATA[依赖范围控制哪些依赖在哪些classpath 中可用，哪些依赖包含在一个应用中。记录下以作备忘。]]>
    
    </summary>
    
      <category term="maven" scheme="http://miclee.cn/tags/maven/"/>
    
      <category term="java" scheme="http://miclee.cn/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 和 Android 的后台推送原理]]></title>
    <link href="http://miclee.cn/2015/12/26/ios-android-push/"/>
    <id>http://miclee.cn/2015/12/26/ios-android-push/</id>
    <published>2015-12-26T07:42:15.000Z</published>
    <updated>2015-12-26T07:59:39.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> 因为手机平台本身、电量、网络流量的限制，移动互联网应用在设计上跟传统 PC 上的应用很大不一样，需要根据手机本身的特点，尽量的节省电量和流量，同时又要尽可能的保证数据能及时到达客户端。为了解决数据同步的问题，在手机平台上，常用的方法有2种。一种是定时去服务器上查询数据，也叫Polling，还有一种手机跟服务器之间维护一个 TCP 长连接，当服务器有数据时，实时推送到客户端，也就是我们说的 Push。从耗费的电量、流量和数据送达的及时性来说，Push都会有明显的优势，但 Push 的实现和维护成本相对较高。在移动无线网络下维护长连接，相对也有一些技术上的难度。本文介绍下IOS和Android目前不同的PUSH方案。 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="运行机制">运行机制</h2><p>iOS 系统的推送（APNS，即 Apple Push Notification Service）依托一个或几个系统常驻进程运作，是全局的（接管所有应用的消息推送），所以可看作是独立于应用之外，而且是设备和苹果服务器之间的通讯，而非应用的提供商服务器。如 腾讯 QQ 的服务器（Provider）会给苹果公司对应的服务器（APNs）发出通知，然后再中转传送到你的设备（Devices）之上。当你接收到通知，打开应用，才开始从腾讯服务器接收数据，跟你之前看到通知里内容一样，但却是经由两个不同的通道而来。</p>
<p>而 Android，就不同，更像是传统桌面电脑系统做法。每个需要后台推送的应用有各自的单独后台进程，才能和各自的服务器通讯，交换数据。另外其实 Android 也有类似 APNS 的 GCM（Google Cloud Message），属于开发者可选，非强制。所以你大概看出来区别，iOS 的消息推送机制面世之时是一种全新的解决方案（堪称平台中的平台），应用本身不能有常驻的后台进程，系统的开销少，内存使用更少，电量也更少（把更多的运算和资源开销放在云端，非设备端）。而 Android 的特点，虽然开销大，优点是更稳定快速，但不明显。</p>
<h2 id="实现原理">实现原理</h2><p>本质上，APNs 与 GCM 是类似的技术实现原理：即系统层有一个常驻的 TCP 长连接，一直保持的长连接，即使手机休眠的时候也在保持的长连接。这里对于大部分人来说，最不理解的就是，休眠时候都保持在那里的 TCP 长连接，不会耗电很厉害么？答案是：不会。这是手机的设计来做到的。TCP长连接有个心跳的时间，在国外可以很长比如30分钟，在国内则因为网络环境复杂一般10分钟。客户端发起的心跳，会短暂地消耗手机电能，但在这个心跳间隔期间，则消耗电能是很少的。当在心跳期间服务器端有推送信息过来时，客户端可以收到并做处理。</p>
<p>再说 APNs 的设计成功处。iOS 为了真正地为用户体验负责，不允许应用在后台活动。有了这个限制，但是对于终端设备，应用又是有必要“通知”到达用户的，随时与用户主动沟通起来的（典型的如聊天应用）。这就是 APNs 的逻辑所在：iOS 自己做个长驻后台保持连接。所有应用，有必要（申请）并且被允许（用户可以改设置）的话，可以通过 APNs 中转到达用户。这样就完善了！有可能很多人没有真正地体会到 iOS 不允许后台应用的好处。我是 Android 开发人员，Android 手机上一般只保留几个常用的应用，不常用就卸载。但是我的 iPhone / iPad 上则是，除非空间不足，一般不会删除应用。Android 就像 Windows，你要真的很费心去维护：有软件在干背后干坏事么？设备又给拖慢了，要清理。要考虑杀毒了。。。Android 因为后台可以长驻，尤其是国内的 Android 的手机上 Google自家的推送服务 GCM 处于基本不可用的状态。所以，各App各显神通。聊天类应用的话，大多数直接借用 XMPP 规范里的一些成果。少量如微信有IM底子的，自己开发协议。这些在实现原理上与 APNs / GCM 没有本质的区别，但有一定的技术门槛。而大多数普遍应用，要使用推送的话，则使用轮询的方式简单实现。其实，国外如 Urban Airship 自己实现了 Android 上的第三方提供的推送平台。近期国内如极光推送也实现了第三方的推送平台（技术与微信、GCM、APNs类似）。理论上，如果一个 Android 设备上多款应用都使用极光推送这种第三方推送平台的话，也可以如 APNs 一样达到节省电量、流量消耗的效果。</p>
]]></content>
    <summary type="html">
    <![CDATA[因为手机平台本身、电量、网络流量的限制，移动互联网应用在设计上跟传统 PC 上的应用很大不一样，需要根据手机本身的特点，尽量的节省电量和流量，同时又要尽可能的保证数据能及时到达客户端。为了解决数据同步的问题，在手机平台上，常用的方法有2种。一种是定时去服务器上查询数据，也叫Polling，还有一种手机跟服务器之间维护一个 TCP 长连接，当服务器有数据时，实时推送到客户端，也就是我们说的 Push。从耗费的电量、流量和数据送达的及时性来说，Push都会有明显的优势，但 Push 的实现和维护成本相对较高。在移动无线网络下维护长连接，相对也有一些技术上的难度。本文介绍下IOS和Android目前不同的PUSH方案。]]>
    
    </summary>
    
      <category term="push" scheme="http://miclee.cn/tags/push/"/>
    
      <category term="移动端" scheme="http://miclee.cn/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[spring-boot哎哟不错(七) —— 使用spring-boot 打包可执行jar和war包]]></title>
    <link href="http://miclee.cn/2015/12/25/spring-boot-7/"/>
    <id>http://miclee.cn/2015/12/25/spring-boot-7/</id>
    <published>2015-12-25T05:00:42.000Z</published>
    <updated>2015-12-25T05:35:25.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> 使用spring-boot 打包可执行jar和war包。spring-boot哎哟不错系列第七篇，哎哟不错系列只记录spring-boot使用过程中重要的部分。 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="一、官方说法">一、官方说法</h2><p>一旦spring-boot-maven-plugin被包含到你的pom.xml中，它就会自动尝试使用spring-boot:repackage目标重写存档以使它们能够执行。为了构建一个jar或war，你应该使用常规的packaging元素配置你的项目：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">project</span> <span class="attribute">xmlns</span>=<span class="value">"http://maven.apache.org/POM/4.0.0"</span> <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="title">packaging</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>生成的存档在package阶段会被Spring Boot增强。你想启动的main类即可以通过指定一个配置选项，也可以通过为manifest添加一个Main-Class属性这种常规的方式实现。如果你没有指定一个main类，该插件会搜索带有public static void main(String[] args)方法的类。</p>
<p>为了构建和运行一个项目的artifact，你可以输入以下命令：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mvn <span class="keyword">package</span></span><br><span class="line">$ java -jar <span class="keyword">target</span>/mymodule-<span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>
<p><strong>为了构建一个即是可执行的，又能部署到一个外部容器的war文件，你需要标记内嵌容器依赖为”provided”</strong>，例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">project</span> <span class="attribute">xmlns</span>=<span class="value">"http://maven.apache.org/POM/4.0.0"</span> <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="title">packaging</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="title">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="二、亲测">二、亲测</h2><h3 id="亲测一：JSP项目">亲测一：JSP项目</h3><p>存在设置情况下，各种运行情况（tomcat相关包在war包的lib-provided目录下）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="title">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>java -jar test.war   -&gt; OK</li>
<li>mvn spring-boot:run  -&gt; OK</li>
<li>tomcat 容器           -&gt; OK</li>
<li>run mainClass        -&gt; error 启动报错：java.lang.NoClassDefFoundError: javax/servlet/ServletContext，位于tomcat-embed-core，被打包到lib-provided。</li>
</ol>
<p>去掉设置或去掉provided（tomcat相关包在war包的lib目录下）:</p>
<ol>
<li>java -jar test.war   -&gt; OK</li>
<li>mvn spring-boot:run  -&gt; OK</li>
<li>tomcat 容器           -&gt; OK</li>
<li>run mainClass        -&gt; error 能启动，但访问404（无法解析JSP页面）</li>
</ol>
<h3 id="非JSP项目">非JSP项目</h3><p>非JSP项目去掉依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="title">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>存在设置情况下，各种运行情况（spring-boot-starter-tomcat-1.3.0.RELEASE.jar在war包的lib-provided目录下）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="title">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>java -jar test.war   -&gt; OK</li>
<li>mvn spring-boot:run  -&gt; OK</li>
<li>tomcat 容器           -&gt; OK</li>
<li>run mainClass        -&gt; OK</li>
</ol>
<p>去掉设置或去掉provided（spring-boot-starter-tomcat-1.3.0.RELEASE.jar在war包的lib包下）:</p>
<ol>
<li>java -jar test.war   -&gt; OK</li>
<li>mvn spring-boot:run  -&gt; OK</li>
<li>tomcat 容器           -&gt; OK</li>
<li>run mainClass        -&gt; OK</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[使用spring-boot 打包可执行jar和war包。spring-boot哎哟不错系列第七篇，哎哟不错系列只记录spring-boot使用过程中重要的部分。]]>
    
    </summary>
    
      <category term="spring" scheme="http://miclee.cn/tags/spring/"/>
    
      <category term="spring" scheme="http://miclee.cn/categories/spring/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[spring-boot哎哟不错(六) —— spring-boot 重要注解解析]]></title>
    <link href="http://miclee.cn/2015/12/23/spring-boot-6/"/>
    <id>http://miclee.cn/2015/12/23/spring-boot-6/</id>
    <published>2015-12-23T05:22:26.000Z</published>
    <updated>2016-04-07T02:44:37.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> spring-boot 重要注解解析。spring-boot哎哟不错系列第六篇，哎哟不错系列只记录spring-boot使用过程中重要的部分。 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="一、_@SpringBootApplication">一、 @SpringBootApplication</h2><ul>
<li><strong>spring-boot</strong> 定义的注解，属于包 <strong><em>org.springframework.boot.autoconfigure</em></strong>，先看源代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Indicates a &#123;<span class="doctag">@link</span> Configuration configuration&#125; class that declares one or more</span><br><span class="line"> * &#123;<span class="doctag">@link</span> Bean <span class="doctag">@Bean</span>&#125; methods and also triggers &#123;<span class="doctag">@link</span> EnableAutoConfiguration</span><br><span class="line"> * auto-configuration&#125; and &#123;<span class="doctag">@link</span> ComponentScan component scanning&#125;. This is a convenience</span><br><span class="line"> * annotation that is equivalent to declaring &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125;,</span><br><span class="line"> * &#123;<span class="doctag">@code</span> <span class="doctag">@EnableAutoConfiguration</span>&#125; and &#123;<span class="doctag">@code</span> <span class="doctag">@ComponentScan</span>&#125;.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@author</span> Phillip Webb</span><br><span class="line"> * <span class="doctag">@author</span> Stephane Nicoll</span><br><span class="line"> * <span class="doctag">@since</span> 1.2.0</span><br><span class="line"> */</span></span><br><span class="line"><span class="annotation">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="annotation">@Documented</span></span><br><span class="line"><span class="annotation">@Inherited</span></span><br><span class="line"><span class="annotation">@Configuration</span></span><br><span class="line"><span class="annotation">@EnableAutoConfiguration</span></span><br><span class="line"><span class="annotation">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> SpringBootApplication &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * Exclude specific auto-configuration classes such that they will never be applied.</span><br><span class="line">	 * <span class="doctag">@return</span> the classes to exclude</span><br><span class="line">	 */</span></span><br><span class="line">	Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * Exclude specific auto-configuration class names such that they will never be</span><br><span class="line">	 * applied.</span><br><span class="line">	 * <span class="doctag">@return</span> the class names to exclude</span><br><span class="line">	 * <span class="doctag">@since</span> 1.3.0</span><br><span class="line">	 */</span></span><br><span class="line">	String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * Base packages to scan for annotated components. Use &#123;<span class="doctag">@link</span> #scanBasePackageClasses&#125;</span><br><span class="line">	 * for a type-safe alternative to String-based package names.</span><br><span class="line">	 * <span class="doctag">@return</span> base packages to scan</span><br><span class="line">	 * <span class="doctag">@since</span> 1.3.0</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="annotation">@AliasFor</span>(annotation = ComponentScan.class, attribute = <span class="string">"basePackages"</span>)</span><br><span class="line">	String[] scanBasePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * Type-safe alternative to &#123;<span class="doctag">@link</span> #scanBasePackages&#125; for specifying the packages to</span><br><span class="line">	 * scan for annotated components. The package of each class specified will be scanned.</span><br><span class="line">	 * &lt;p&gt;</span><br><span class="line">	 * Consider creating a special no-op marker class or interface in each package that</span><br><span class="line">	 * serves no purpose other than being referenced by this attribute.</span><br><span class="line">	 * <span class="doctag">@return</span> base packages to scan</span><br><span class="line">	 * <span class="doctag">@since</span> 1.3.0</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="annotation">@AliasFor</span>(annotation = ComponentScan.class, attribute = <span class="string">"basePackageClasses"</span>)</span><br><span class="line">	Class&lt;?&gt;[] scanBasePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>元注解 @Target, @Retention, @Documented, @Inherited 的作用请见 <a href="http://miclee.cn/2015/12/22/spring-annotition/">spring注解原理剖析与实现</a>这篇博文。</p>
</li>
<li><p>很多Spring Boot开发者总是使用@Configuration，@EnableAutoConfiguration和@ComponentScan注解他们的main类。由于这些注解被如此频繁地一块使用，Spring Boot提供一个方便的@SpringBootApplication选择。所以@SpringBootApplication注解等价于以默认属性使用@Configuration，@EnableAutoConfiguration和@ComponentScan。下面延伸解析下这三个注解。</p>
</li>
</ul>
<h2 id="二、_@Configuration">二、 @Configuration</h2><ul>
<li><strong>spring</strong> 定义的注解，属于包 <strong><em>org.springframework.context.annotation</em></strong>，先看源代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="annotation">@Documented</span></span><br><span class="line"><span class="annotation">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> Configuration &#123;</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * Explicitly specify the name of the Spring bean definition associated</span><br><span class="line">	 * with this Configuration class.  If left unspecified (the common case),</span><br><span class="line">	 * a bean name will be automatically generated.</span><br><span class="line">	 * &lt;p&gt;The custom name applies only if the Configuration class is picked up via</span><br><span class="line">	 * component scanning or supplied directly to a &#123;<span class="doctag">@link</span> AnnotationConfigApplicationContext&#125;.</span><br><span class="line">	 * If the Configuration class is registered as a traditional XML bean definition,</span><br><span class="line">	 * the name/id of the bean element will take precedence.</span><br><span class="line">	 * <span class="doctag">@return</span> the specified bean name, if any</span><br><span class="line">	 * <span class="doctag">@see</span> org.springframework.beans.factory.support.DefaultBeanNameGenerator</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>众所周知，Spring 框架是控制反转 (IOC) 或依赖性注入 (DI) 模式的推动因素，而这种推动是通过基于容器的配置实现的。过去，Spring 允许开发人员使用基于 XML 的配置，通过利用应用程序上下文 XML 文件来管理 bean 依赖性。此文件处于应用程序的外部，包含 bean 及其与该应用程序的依赖项的定义。尽管使用 XML 配置较为简单和便捷，但仍有另外一种方法可定义 bean 及其依赖项。这种方法也称为基于 Java 的配置。不同于 XML，基于 Java 的配置使您能够以编程方式管理 bean。这可通过运用多种注释来实现。</p>
<p>演示一个demo:</p>
<ol>
<li><p>xml版的bean定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">beans</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"course"</span> <span class="attribute">class</span>=<span class="value">"demo.Course"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"module"</span> <span class="attribute">ref</span>=<span class="value">"module"</span>/&gt;</span></span><br><span class="line">  	<span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"module"</span> <span class="attribute">class</span>=<span class="value">"demo.Module"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"assignment"</span> <span class="attribute">ref</span>=<span class="value">"assignment"</span>/&gt;</span></span><br><span class="line">  	<span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"assignment"</span> <span class="attribute">class</span>=<span class="value">"demo.Assignment"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>@Configuration 注解的配置类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppContext</span> </span>&#123;</span><br><span class="line">  	<span class="annotation">@Bean</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> Course <span class="title">course</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  		Course course = <span class="keyword">new</span> Course();</span><br><span class="line">  		course.setModule(module());</span><br><span class="line">  		<span class="keyword">return</span> course;</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="annotation">@Bean</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> Module <span class="title">module</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  		Module module = <span class="keyword">new</span> Module();</span><br><span class="line">  		module.setAssignment(assignment());</span><br><span class="line">  		<span class="keyword">return</span> module;</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="annotation">@Bean</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> Assignment <span class="title">assignment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  		<span class="keyword">return</span> <span class="keyword">new</span> Assignment();</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>@Configuration 注释位于类的顶端。它告知 Spring 容器这个类是一个拥有 bean 定义和依赖项的配置类。 @Bean 注释用于定义 bean。上述注释位于实例化 bean 并设置依赖项的方法上方。方法名称与 bean id 或默认名称相同。该方法的返回类型是向 Spring 应用程序上下文注册的 bean。您可使用 bean 的 setter 方法来设置依赖项，容器将调用它们来连接相关项。基于 Java 的配置也被视为基于注释的配置。</p>
<blockquote>
<p>总体来说，就是告诉spring容器加载这个配置；<br>相对于xml的配置来说，这个注解的作用就是将spring-xxx.xml（某个配置文件）配置进web.xml</p>
</blockquote>
<h2 id="三、_@EnableAutoConfiguration">三、 @EnableAutoConfiguration</h2><ul>
<li><strong>spring-boot</strong> 定义的注解，属于包 <strong><em>org.springframework.boot.autoconfigure</em></strong>，先看源代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="annotation">@Documented</span></span><br><span class="line"><span class="annotation">@Inherited</span></span><br><span class="line"><span class="annotation">@AutoConfigurationPackage</span></span><br><span class="line"><span class="annotation">@Import</span>(EnableAutoConfigurationImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * Exclude specific auto-configuration classes such that they will never be applied.</span><br><span class="line">	 * <span class="doctag">@return</span> the classes to exclude</span><br><span class="line">	 */</span></span><br><span class="line">	Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * Exclude specific auto-configuration class names such that they will never be</span><br><span class="line">	 * applied.</span><br><span class="line">	 * <span class="doctag">@return</span> the class names to exclude</span><br><span class="line">	 * <span class="doctag">@since</span> 1.3.0</span><br><span class="line">	 */</span></span><br><span class="line">	String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个注解告诉Spring Boot <strong><em>根据添加的jar依赖猜测你想如何配置Spring</em></strong>。比如spring-boot-starter-web添加了Tomcat和Spring MVC，所以auto-configuration将假定你正在开发一个web应用并相应地对Spring进行设置。</p>
<p>Starter POMs和Auto-Configuration：设计auto-configuration的目的是更好的使用”Starter POMs”，但这两个概念没有直接的联系。你可以自由地挑选starter POMs以外的jar依赖，并且Spring Boot将仍旧尽最大努力去自动配置你的应用。</p>
<h2 id="四、_@ComponentScan">四、 @ComponentScan</h2><ul>
<li><strong>spring</strong> 定义的注解，属于包 <strong><em>org.springframework.context.annotation</em></strong>，先看源代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="annotation">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="annotation">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> ComponentScan &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * Alias for &#123;<span class="doctag">@link</span> #basePackages&#125;.</span><br><span class="line">	 * &lt;p&gt;Allows for more concise annotation declarations if no other attributes</span><br><span class="line">	 * are needed &amp;mdash; for example, &#123;<span class="doctag">@code</span> <span class="doctag">@ComponentScan</span>("org.my.pkg")&#125;</span><br><span class="line">	 * instead of &#123;<span class="doctag">@code</span> <span class="doctag">@ComponentScan</span>(basePackages = "org.my.pkg")&#125;.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="annotation">@AliasFor</span>(<span class="string">"basePackages"</span>)</span><br><span class="line">	String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * Base packages to scan for annotated components.</span><br><span class="line">	 * &lt;p&gt;&#123;<span class="doctag">@link</span> #value&#125; is an alias for (and mutually exclusive with) this</span><br><span class="line">	 * attribute.</span><br><span class="line">	 * &lt;p&gt;Use &#123;<span class="doctag">@link</span> #basePackageClasses&#125; for a type-safe alternative to</span><br><span class="line">	 * String-based package names.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="annotation">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">	String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//还有一些属性并不常用，所以不列举了。。。。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>@ComponentScan 注解的作用就是开启spring的注解扫描，与xml配置方式下的 <context:component-scan> 作用一样。<br>可以设置一个值指定basePackages，就是开始扫描的包。如果没有设置 <strong>默认从定义这个注解的类所属包开始一直到所有子包</strong>。</context:component-scan></li>
</ul>
<h2 id="五、_@Import">五、 @Import</h2><ul>
<li><strong>spring</strong> 定义的注解，属于包 <strong><em>org.springframework.context.annotation</em></strong>，先看源代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="annotation">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> Import &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * @&#123;<span class="doctag">@link</span> Configuration&#125;, &#123;<span class="doctag">@link</span> ImportSelector&#125;, &#123;<span class="doctag">@link</span> ImportBeanDefinitionRegistrar&#125;</span><br><span class="line">	 * or regular component classes to import.</span><br><span class="line">	 */</span></span><br><span class="line">	Class&lt;?&gt;[] value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>@Import 与xml配置方式下的<import> 作用一样。支持导入的类型有：<ul>
<li>一个或多个拥有 @Configuration 注解的配置类</li>
<li>ImportSelector 接口的实现类</li>
<li>ImportBeanDefinitionRegistrar 的实现类</li>
</ul>
</import></li>
</ul>
<blockquote>
<p>如果Import注解中Class为ImportSelector子类，通过invokeAwareMethods(selector)设置aware值，如果类型为DeferredImportSelector则添加到deferredImportSelectors集合中，待前面的parser.parse(configCandidates)<br>方法中processDeferredImportSelectors()处理；如果不是，则执行selectImports方法，将获取到的结果递归调用processImports，解析selectImports得到的结果</p>
<p>如果Import注解中Class为ImportBeanDefinitionRegistrar子类，则添加到importBeanDefinitionRegistrars中，注意该部分的数据在执行完parser.parse(configCandidates)后调用this.reader.loadBeanDefinitions(configClasses)解析，否则执行配置信息的解析操作。</p>
</blockquote>
<h2 id="六、_@Conditional">六、 @Conditional</h2><ul>
<li><strong>spring</strong> 定义的注解，属于包 <strong><em>org.springframework.context.annotation</em></strong>，先看源代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="annotation">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> Conditional &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * All &#123;<span class="doctag">@link</span> Condition&#125;s that must &#123;<span class="doctag">@linkplain</span> Condition#matches match&#125;</span><br><span class="line">	 * in order for the component to be registered.</span><br><span class="line">	 */</span></span><br><span class="line">	Class&lt;? extends Condition&gt;[] value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出value的值必须是实现了Condition接口的类，Condition接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * Determine if the condition matches.</span><br><span class="line">	 * <span class="doctag">@param</span> context the condition context</span><br><span class="line">	 * <span class="doctag">@param</span> metadata metadata of the &#123;<span class="doctag">@link</span> org.springframework.core.type.AnnotationMetadata class&#125;</span><br><span class="line">	 * or &#123;<span class="doctag">@link</span> org.springframework.core.type.MethodMetadata method&#125; being checked.</span><br><span class="line">	 * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the condition matches and the component can be registered</span><br><span class="line">	 * or &#123;<span class="doctag">@code</span> false&#125; to veto registration.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>matchs()返回true 表明该bean（注解了@Conditional的类）需要被创建，否则不创建。</p>
<blockquote>
<p>延伸几个 spring-boot提供的 @Conditional的子集，具体了Conditional的条件：</p>
<ul>
<li><strong>@ConditionalOnClass:</strong> 等同于 <strong><em>@Conditional(OnClassCondition.class)</em></strong>，表示存在对应的Class文件时才会去创建该bean</li>
<li><strong>@ConditionalOnMissingBean:</strong> 等同于 <strong><em>@Conditional(OnBeanCondition.class)</em></strong>，表示spring上下文里缺失某个bean时才会去创建该bean</li>
<li><strong>@ConditionalOnWebApplication:</strong> 等同于 <strong><em>@Conditional(OnWebApplicationCondition.class)</em></strong>，表示只有在WEB应用时才会创建该bean</li>
<li>更多请参考 <strong><em>org.springframework.boot.autoconfigure.condition</em></strong> 包下面的类</li>
</ul>
</blockquote>
<h2 id="七、_@EnableConfigurationProperties_&amp;&amp;_@ConfigurationProperties">七、 @EnableConfigurationProperties &amp;&amp; @ConfigurationProperties</h2><p>使用@Value(“${property}”)注解注入配置属性有时可能比较笨重，特别是需要使用多个properties或你的数据本身有层次结构。为了控制和校验你的应用配置，Spring Boot提供一个允许强类型beans的替代方法来使用properties。</p>
<p>示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span></span><br><span class="line"><span class="annotation">@ConfigurationProperties</span>(prefix=<span class="string">"connection"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionSettings</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> InetAddress remoteAddress;</span><br><span class="line">    <span class="comment">// ... getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当@EnableConfigurationProperties注解应用到你的@Configuration时，任何被@ConfigurationProperties注解的beans将自动被Environment属性配置。这种风格的配置特别适合与SpringApplication的外部YAML配置进行配合使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># application.yml</span></span><br><span class="line">connection:</span><br><span class="line">    username: admin</span><br><span class="line">    remoteAddress: <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line"><span class="preprocessor"># additional configuration as required</span></span><br></pre></td></tr></table></figure>
<p>为了使用@ConfigurationProperties beans，你可以使用与其他任何bean相同的方式注入它们。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ConnectionSettings connection;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">    <span class="annotation">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Server server = <span class="keyword">new</span> Server();</span><br><span class="line">        <span class="keyword">this</span>.connection.configure(server);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以通过在@EnableConfigurationProperties注解中直接简单的列出属性类来快捷的注册@ConfigurationProperties bean的定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Service</span></span><br><span class="line"><span class="annotation">@EnableConfigurationProperties</span>(ConnectionSettings.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ConnectionSettings connection;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">    <span class="annotation">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Server server = <span class="keyword">new</span> Server();</span><br><span class="line">        <span class="keyword">this</span>.connection.configure(server);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Component 这样ConnectionSettings类上面就不用标示 @Component注解了</span></span><br><span class="line"><span class="annotation">@ConfigurationProperties</span>(prefix=<span class="string">"connection"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionSettings</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> InetAddress remoteAddress;</span><br><span class="line">    <span class="comment">// ... getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[spring-boot 重要注解解析。spring-boot哎哟不错系列第六篇，哎哟不错系列只记录spring-boot使用过程中重要的部分。]]>
    
    </summary>
    
      <category term="spring" scheme="http://miclee.cn/categories/spring/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[spring-boot哎哟不错(五) —— spring-boot 自定义配置详解]]></title>
    <link href="http://miclee.cn/2015/12/22/spring-boot-5/"/>
    <id>http://miclee.cn/2015/12/22/spring-boot-5/</id>
    <published>2015-12-22T07:39:10.000Z</published>
    <updated>2016-04-07T02:40:17.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> spring-boot 自定义配置详解。spring-boot哎哟不错系列第五篇，哎哟不错系列只记录spring-boot使用过程中重要的部分。 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="一、spring-boot支持的配置类型">一、spring-boot支持的配置类型</h2><ol>
<li><p><strong>.properties</strong> 以往常见，如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.address.city=nanjing</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>.yml</strong> yaml格式的文件，如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user:&#10;  address:&#10;    city: nanjing</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>在yaml中缩进不要使用TAB，否则会解析错误</p>
</blockquote>
<h2 id="二、简单配置案例">二、简单配置案例</h2><ol>
<li><p>类路径下创建application.properties文件并定义：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = MicLee</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个配置类来获取配置信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="annotation">@Value</span>(<span class="string">"$&#123;name&#125;"</span>) String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在HelloWorldController.java调用配置bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@RestController</span></span><br><span class="line"><span class="annotation">@RequestMapping</span>(<span class="string">"/springboot"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldController</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@RequestMapping</span>(value = <span class="string">"/&#123;name&#125;"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="annotation">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayWorld</span><span class="params">(@PathVariable(<span class="string">"name"</span>)</span> String name) </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"userName:"</span> + user.getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动工程，在命令行执行</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">http:</span><span class="comment">//localhost:8080/springboot/miclee</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<ul>
<li>在spring boot中默认会加载<br>classpath:/ | classpath:/config/ | file:./ | file:./config/ 路径下以application命名的property或yaml文件；</li>
<li>参数spring.config.location设置配置文件存放位置；</li>
<li>参数spring.config.name设置配置文件名称；</li>
</ul>
</blockquote>
<h2 id="三、配置文件里获取随机数">三、配置文件里获取随机数</h2><p>在spring boot配置文件里能调用Random中的方法，如在application.properties中为user增加age参数：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=MicLee&#10;age=$&#123;random.int&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean中同时增加参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="annotation">@Value</span>(<span class="string">"$&#123;name&#125;"</span>) String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="annotation">@Value</span>(<span class="string">"$&#123;age&#125;"</span>) Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>启动工程时会为age随机生成一个整数值：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;random.<span class="keyword">int</span>(<span class="number">100</span>)&#125; : 限制生成的数字小于<span class="number">10</span></span><br><span class="line">$&#123;random.<span class="keyword">int</span>[<span class="number">0</span>,<span class="number">100</span>]&#125; : 指定范围的数字</span><br></pre></td></tr></table></figure></p>
<h2 id="在配置文件中调用占位符">在配置文件中调用占位符</h2><p>修改配置文件：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=MicLee&#10;age=$&#123;random.int[0,100]&#125;&#10;remark=hello,my name is $&#123;name&#125;,age is $&#123;age&#125;.</span><br></pre></td></tr></table></figure></p>
<p>修改bean：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="annotation">@Value</span>(<span class="string">"$&#123;name&#125;"</span>) String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="annotation">@Value</span>(<span class="string">"$&#123;age&#125;"</span>) Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="annotation">@Value</span>(<span class="string">"$&#123;remark&#125;"</span>) String remark;</span><br><span class="line">    <span class="comment">//TODO getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="四、去掉_@Value_注解">四、去掉 @Value 注解</h2><p>在spring boot中属性的注入连 @Value 注解都不需要。<br>修改配置文件：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=MicLee&#10;age=$&#123;random.int[0,100]&#125;&#10;remark=hello,my name is $&#123;name&#125;,age is $&#123;age&#125;.&#10;user.address=China,Nanjing</span><br></pre></td></tr></table></figure></p>
<p>修改bean，增加注解 @ConfigurationProperties ：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span></span><br><span class="line"><span class="annotation">@ConfigurationProperties</span>(prefix = <span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="annotation">@Value</span>(<span class="string">"$&#123;name&#125;"</span>) String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="annotation">@Value</span>(<span class="string">"$&#123;age&#125;"</span>) Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="annotation">@Value</span>(<span class="string">"$&#123;remark&#125;"</span>) String remark;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>使用@ConfigurationProperties需要指定prefix,同时bean中的属性和配置参数名保持一致。</p>
</blockquote>
<h2 id="五、实体嵌套配置">五、实体嵌套配置</h2><p>在User中定义一个Address实体同样可以快捷配置:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User.java</span></span><br><span class="line"><span class="annotation">@Component</span></span><br><span class="line"><span class="annotation">@ConfigurationProperties</span>(prefix = <span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="annotation">@Value</span>(<span class="string">"$&#123;name&#125;"</span>) String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="annotation">@Value</span>(<span class="string">"$&#123;age&#125;"</span>) Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="annotation">@Value</span>(<span class="string">"$&#123;remark&#125;"</span>) String remark;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String country;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String province;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改配置文件：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=MicLee&#10;age=$&#123;random.int[0,100]&#125;&#10;remark=hello,my name is $&#123;name&#125;,age is $&#123;age&#125;.&#10;user.address.country=China&#10;user.address.province=Jiangsu&#10;user.address.city=Nanjing</span><br></pre></td></tr></table></figure></p>
<p>这种嵌套关系如果通过yaml文件展示出来层次感会更强:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user:&#10;    address:&#10;      country:China&#10;      province:Jiangsu&#10;      city:Nanjing</span><br></pre></td></tr></table></figure></p>
<h2 id="六、配置集合">六、配置集合</h2><p>一个人可能有多个联系地址，那么地址为集合:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User.java</span></span><br><span class="line"><span class="annotation">@Component</span></span><br><span class="line"><span class="annotation">@ConfigurationProperties</span>(prefix = <span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="annotation">@Value</span>(<span class="string">"$&#123;name&#125;"</span>) String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="annotation">@Value</span>(<span class="string">"$&#123;age&#125;"</span>) Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="annotation">@Value</span>(<span class="string">"$&#123;remark&#125;"</span>) String remark;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Address address；</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Address&gt; addressList = <span class="keyword">new</span> ArrayList&lt;Address&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对应的properties文件：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.addressList[0].country=China&#10;user.addressList[0].province=Jiangsu&#10;user.addressList[0].city=Nanjing&#10;&#10;user.addressList[1].country=China&#10;user.addressList[1].province=Anhui&#10;user.addressList[1].city=Anqing</span><br></pre></td></tr></table></figure></p>
<p>对应的yaml文件：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user:&#10;    -addressList:&#10;      country:China&#10;      province:Jiangsu&#10;      city:Nanjing&#10;    -addressList:&#10;      country:China&#10;      province:Anhui&#10;      city:Anqing</span><br></pre></td></tr></table></figure></p>
<h2 id="七、多配置文件">七、多配置文件</h2><p>spring boot设置多配置文件很简单，可以在bean上使用注解 @Profile(“development”) 即调用application-development.properties|yml文件，也可以调用SpringApplication中的etAdditionalProfiles()方法，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Profile</span>(<span class="string">"development"</span>)</span><br><span class="line"><span class="annotation">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication app = <span class="keyword">new</span> SpringApplication(Application.class);</span><br><span class="line">        <span class="comment">//   app.setAdditionalProfiles("development");</span></span><br><span class="line">        app.addListeners(<span class="keyword">new</span> MyApplicationStartedEventListener());</span><br><span class="line">        app.run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以通过启动时指定参数spring.profiles.active。</p>
<blockquote>
<p>在实际项目中最好是将配置参数抽离出来集中管理，比如利用淘宝的super-diamond ,consul,zk 等。</p>
</blockquote>
<h2 id="八、去掉@@Component注解">八、去掉@@Component注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Component  注解配置类User.java</span></span><br><span class="line"><span class="annotation">@ConfigurationProperties</span>(prefix = <span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String remark;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注解引入处 UserService.java</span></span><br><span class="line"><span class="annotation">@EnableConfigurationProperties</span>(User.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[spring-boot 自定义配置详解。spring-boot哎哟不错系列第五篇，哎哟不错系列只记录spring-boot使用过程中重要的部分。]]>
    
    </summary>
    
      <category term="spring" scheme="http://miclee.cn/categories/spring/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[spring注解原理剖析与实现]]></title>
    <link href="http://miclee.cn/2015/12/22/spring-annotition/"/>
    <id>http://miclee.cn/2015/12/22/spring-annotition/</id>
    <published>2015-12-22T05:47:51.000Z</published>
    <updated>2015-12-22T07:09:36.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> 讲述注解的基本概念和原理及其简单实用、以及自己实现一个 @Resource 注解来讲述其实现原理 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="一、注解的基本概念和原理">一、注解的基本概念和原理</h2><h3 id="1）概念">1）概念</h3><p>注解（Annotation）提供了一种安全的类似注释的机制，为我们在代码中添加信息提供了一种形式化得方法，使我们可以在稍后某个时刻方便的使用这些数据（通过解析注解来使用这些数据），用来将任何的信息或者元数据与程序元素（类、方法、成员变量等）进行关联。其实就是更加直观更加明了的说明，这些说明信息与程序业务逻辑没有关系，并且是供指定的工具或框架使用的。Annotation像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的申明语句中。</p>
<p>Annotation其实是一种接口。通过java的反射机制相关的API来访问Annotation信息。相关类（框架或工具中的类）根据这些信息来决定如何使用该程序元素或改变它们的行为。Java语言解释器在工作时会忽略这些Annotation，因此在JVM中这些Annotation是“不起作用”的，只能通过配套的工具才能对这些Annotation类型的信息进行访问和处理。</p>
<h3 id="2）Annotation和interface的异同">2）Annotation和interface的异同</h3><ol>
<li>Annotition的类型使用关键字 @interface 而不是interface。它继承了java.lang.annotition.Annotition接口，并非申明了一个interface。</li>
<li><p>Annotation类型、方法定义是独特的、受限制的：</p>
<ul>
<li><p>Annotation类型的方法必须申明为无参数、无异常抛出的。这些方法定义了 <strong>Annotation的成员：方法名为成员名，而方法返回值为成员的类型。</strong></p>
<blockquote>
<p>特别的，如果方法名为 value()， 则在注解的地方需要设置属性值时可以直接写入值，如：@Target({ElemenetType.TYPE}) 而不必写为 @Target(value={ElemenetType.TYPE})</p>
</blockquote>
</li>
<li><p>方法返回值必须为primitive类型、Class类型、枚举类型、Annotation类型或者由前面类型之一作为元素的一位数组。</p>
</li>
<li>方法的后面可以使用default关键字加一个默认数值来申明成员的默认值，null不能作为成员的默认值，这与我们在非Annotation类型中定义方法有很大不同。</li>
<li>Annotation类型和他的方法不能使用Annotation类型的参数，成员不能是generic。只有返回值类型是Class的方法可以在Annotation类型中使用generic，因为此方法能够用类转换将各种类型转换为Class。</li>
</ul>
</li>
<li>Annotation类型又与接口有着近似之处：它可以定义常量、静态成员类型（比如枚举类型定义）；Annotation类型也可以如接口一般被实现或者继承。</li>
</ol>
<h3 id="3）元注解_@Target,_@Retention,_@Documented,_@Inherited">3）元注解 @Target, @Retention, @Documented, @Inherited</h3><ol>
<li>@Target 表示该注解用于什么地方，可能的 ElemenetType 参数包括：<ul>
<li>ElemenetType.CONSTRUCTOR 构造器声明</li>
<li>ElemenetType.FIELD 域声明（包括 enum 实例）</li>
<li>ElemenetType.LOCAL_VARIABLE 局部变量声明</li>
<li>ElemenetType.METHOD 方法声明</li>
<li>ElemenetType.PACKAGE 包声明</li>
<li>ElemenetType.PARAMETER 参数声明</li>
<li>ElemenetType.TYPE 类，接口（包括注解类型）或enum声明</li>
</ul>
</li>
<li>@Retention 表示在什么级别保存该注解信息。可选的 RetentionPolicy 参数包括：<ul>
<li>RetentionPolicy.SOURCE 注解将被编译器丢弃</li>
<li>RetentionPolicy.CLASS 注解在class文件中可用，但会被VM丢弃</li>
<li>RetentionPolicy.RUNTIME VM将在运行期也保留注释，因此可以通过反射机制读取注解的信息</li>
</ul>
</li>
<li>@Documented 将此注解包含在 javadoc 中</li>
<li>@Inherited 允许子类继承父类中的注解</li>
</ol>
<h3 id="4）演示一个demo">4）演示一个demo</h3><ol>
<li><p>定义注解Test：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该注解用于方法声明</span></span><br><span class="line"><span class="annotation">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="comment">//VM将在运行期也保留注释，因此可以通过反射机制读取注解的信息</span></span><br><span class="line"><span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="comment">//将此注解包含在javadoc中</span></span><br><span class="line"><span class="annotation">@Documented</span></span><br><span class="line"><span class="comment">//允许子类继承父类中的注解</span></span><br><span class="line"><span class="annotation">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> Test &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> "no description"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_1</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 被注释的三个方法</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@Test</span>(id = <span class="number">1</span>, description = <span class="string">"hello method1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Test</span>(id = <span class="number">2</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Test</span>(id = <span class="number">3</span>, description = <span class="string">"last method3"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解析注解:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Method[] methods = Test_1.class.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="comment">//判断方法中是否有指定注解类型的注解</span></span><br><span class="line">            <span class="keyword">boolean</span> hasAnnotation = method.isAnnotationPresent(Test.class);</span><br><span class="line">            <span class="keyword">if</span> (hasAnnotation) &#123;</span><br><span class="line">                <span class="comment">//根据注解类型返回方法的指定类型注解</span></span><br><span class="line">                Test annotation = method.getAnnotation(Test.class);</span><br><span class="line">                System.out.println(<span class="string">"Test(method="</span> + method.getName() + <span class="string">",id="</span> + annotation.id()</span><br><span class="line">                                   + <span class="string">",description="</span> + annotation.description() + <span class="string">")"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="二、自定义_@Resource注解">二、自定义 @Resource注解</h2><h3 id="1）定义Annotition_@MicLeeResource">1）定义Annotition @MicLeeResource</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="annotation">@Target</span>( &#123; ElementType.FIELD, ElementType.METHOD &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> MicLeeResource &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2）使用注解">2）使用注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeopleServiceImpl</span> <span class="keyword">implements</span> <span class="title">PeopleService</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@MicLeeResource</span></span><br><span class="line">    <span class="keyword">private</span> PeopleDao peopleDao;</span><br><span class="line">    <span class="keyword">private</span> String    name = <span class="string">"MicLee"</span>;</span><br><span class="line">    <span class="keyword">private</span> Integer   id   = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * <span class="doctag">@param</span> peopleDao 或者注解在set方法上</span><br><span class="line">     */</span></span><br><span class="line">    <span class="comment">//@MicLeeResource</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPeopleDao</span><span class="params">(PeopleDao peopleDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.peopleDao = peopleDao;</span><br><span class="line">    &#125;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3）实现注入原理，在自定义spring容器中添加注解功能">3）实现注入原理，在自定义spring容器中添加注解功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MicLeeClassPathXMLApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放BeanDefinition的列表，在beans.xml中定义的bean可能不止一个</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;BeanDefinition&gt; beanDefines = <span class="keyword">new</span> ArrayList&lt;BeanDefinition&gt;();</span><br><span class="line">    <span class="comment">//将类名作为索引，将创建的Bean对象存入到Map中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt;  sigletons   = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MicLeeClassPathXMLApplicationContext</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//读取xml配置文件</span></span><br><span class="line">        <span class="keyword">this</span>.readXML(fileName);</span><br><span class="line">        <span class="comment">//实例化bean</span></span><br><span class="line">        <span class="keyword">this</span>.instanceBeans();</span><br><span class="line">        <span class="comment">//处理注解方式</span></span><br><span class="line">        <span class="keyword">this</span>.annotationInject();</span><br><span class="line">        <span class="comment">//注入对象</span></span><br><span class="line">        <span class="keyword">this</span>.injectObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 使用注解方式注入对象方法实现</span><br><span class="line">     * <span class="doctag">@throws</span> IntrospectionException</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">annotationInject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//循环所有bean对象</span></span><br><span class="line">        <span class="keyword">for</span> (String beanName : sigletons.keySet()) &#123;</span><br><span class="line">            <span class="comment">//获取bean对象</span></span><br><span class="line">            Object bean = sigletons.get(beanName);</span><br><span class="line">            <span class="comment">//如果bean不为空,取得bean的属性</span></span><br><span class="line">            <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//按属性注入</span></span><br><span class="line">                    PropertyDescriptor[] ps = Introspector.getBeanInfo(bean.getClass())</span><br><span class="line">                        .getPropertyDescriptors();</span><br><span class="line">                    <span class="keyword">for</span> (PropertyDescriptor properdesc : ps) &#123;</span><br><span class="line">                        <span class="comment">//获取属性的setter方法</span></span><br><span class="line">                        Method setter = properdesc.getWriteMethod();</span><br><span class="line">                        <span class="comment">//判断注解是否存在</span></span><br><span class="line">                        <span class="keyword">if</span> (setter != <span class="keyword">null</span> &amp;&amp; setter.isAnnotationPresent(MicLeeResource.class)) &#123;</span><br><span class="line">                            <span class="comment">//取得注解</span></span><br><span class="line">                            MicLeeResource resource = setter.getAnnotation(MicLeeResource.class);</span><br><span class="line">                            Object value = <span class="keyword">null</span>;</span><br><span class="line">                            <span class="comment">//如果按名字找到</span></span><br><span class="line">                            <span class="keyword">if</span> (resource.name() != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(resource.name())) &#123;</span><br><span class="line">                                <span class="comment">//取得容器中的bean对象</span></span><br><span class="line">                                value = sigletons.get(resource.name());</span><br><span class="line"></span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;<span class="comment">//没有按名字找到，按类型寻找</span></span><br><span class="line">                                <span class="comment">//取得容器中的bean对象</span></span><br><span class="line">                                value = sigletons.get(resource.name());</span><br><span class="line">                                <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    <span class="keyword">for</span> (String key : sigletons.keySet()) &#123;</span><br><span class="line">                                        <span class="keyword">if</span> (properdesc.getPropertyType().isAssignableFrom(</span><br><span class="line">                                            sigletons.get(key).getClass())) &#123;</span><br><span class="line">                                            value = sigletons.get(key);</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//把引用对象注入到属性</span></span><br><span class="line">                            setter.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                            setter.invoke(bean, value);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//按字段注入</span></span><br><span class="line">                    Field[] fields = bean.getClass().getDeclaredFields();</span><br><span class="line">                    <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">                        <span class="comment">//如果注解存在</span></span><br><span class="line">                        <span class="keyword">if</span> (field.isAnnotationPresent(MicLeeResource.class)) &#123;</span><br><span class="line">                            <span class="comment">//取得注解</span></span><br><span class="line">                            MicLeeResource resource = field.getAnnotation(MicLeeResource.class);</span><br><span class="line">                            Object value = <span class="keyword">null</span>;</span><br><span class="line">                            <span class="comment">//如果按名字找到</span></span><br><span class="line">                            <span class="keyword">if</span> (resource.name() != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(resource.name())) &#123;</span><br><span class="line">                                <span class="comment">//取得容器中的bean对象</span></span><br><span class="line">                                value = sigletons.get(resource.name());</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;<span class="comment">//没有按名字找到，按类型寻找</span></span><br><span class="line">                                <span class="comment">//取得容器中的bean对象</span></span><br><span class="line">                                value = sigletons.get(field.getName());</span><br><span class="line">                                <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    <span class="keyword">for</span> (String key : sigletons.keySet()) &#123;</span><br><span class="line">                                        <span class="keyword">if</span> (field.getType().isAssignableFrom(</span><br><span class="line">                                            sigletons.get(key).getClass())) &#123;</span><br><span class="line">                                            value = sigletons.get(key);</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//允许访问private</span></span><br><span class="line">                            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                            field.set(bean, value);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IntrospectionException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *为bean对象的属性注入值</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">injectObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ….</span><br><span class="line">    &#125;</span><br><span class="line">….</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>@MicLeeResource 注解本身不做任何事情，只是像xml文件一样起到配置作用。注解代表的是某种业务意义，注解背后处理器的工作原理如上源码实现：首先解析所有属性，判断属性上是否存在指定注解，如果存在则根据搜索规则取得bean，然后利用反射原理注入。如果标注在字段上面，也可以通过字段的反射技术取得注解，根据搜索规则取得bean，然后利用反射技术注入。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[讲述注解的基本概念和原理及其简单实用、以及自己实现一个 @Resource 注解来讲述其实现原理]]>
    
    </summary>
    
      <category term="annotation" scheme="http://miclee.cn/tags/annotation/"/>
    
      <category term="spring" scheme="http://miclee.cn/categories/spring/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[常用模板语言]]></title>
    <link href="http://miclee.cn/2015/12/18/template-language/"/>
    <id>http://miclee.cn/2015/12/18/template-language/</id>
    <published>2015-12-18T09:11:40.000Z</published>
    <updated>2016-04-07T03:45:14.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> 常用的模板引擎语言 </em></strong><br><a id="more"></a></p>
<hr>
<blockquote>
<p>在java领域，表现层技术主要有三种：jsp、freemarker、velocity<br>在javascript领域，主要有：EJS、Jade、doT、swig等等，参考<a href="http://garann.github.io/template-chooser/" target="_blank" rel="external">http://garann.github.io/template-chooser/</a></p>
</blockquote>
<h2 id="JSP">JSP</h2><h3 id="优点">优点</h3><ol>
<li>功能强大，可以写java代码</li>
<li>支持jsp标签（jsp tag）</li>
<li>支持表达式语言（el）</li>
<li>官方标准，用户群广，丰富的第三方jsp标签库</li>
<li>性能良好。jsp编译成class文件执行，有很好的性能表现<h3 id="缺点">缺点</h3>jsp没有明显缺点，非要挑点骨头那就是，由于可以编写java代码，如使用不当容易破坏mvc结构。</li>
</ol>
<h2 id="velocity是较早出现的用于代替jsp的模板语言">velocity是较早出现的用于代替jsp的模板语言</h2><h3 id="优点-1">优点</h3><ol>
<li>不能编写java代码，可以实现严格的mvc分离</li>
<li>性能良好，据说比jsp性能还要好些</li>
<li>使用表达式语言，据说jsp的表达式语言就是学velocity的<h3 id="缺点-1">缺点</h3></li>
<li>不是官方标准</li>
<li>用户群体和第三方标签库没有jsp多。</li>
<li>对jsp标签支持不够好</li>
</ol>
<h2 id="freemarker">freemarker</h2><h3 id="优点-2">优点</h3><ol>
<li>不能编写java代码，可以实现严格的mvc分离</li>
<li>性能。velocity应该是最好的，其次是jsp，普通的页面freemarker性能最差（虽然只是几毫秒到十几毫秒的差距）。但是在复杂页面上（包含大量判断. 日期金额格式化）的页面上，freemarker的性能比使用tag和el的jsp好。</li>
<li>对jsp标签支持良好</li>
<li>内置大量常用功能，比如html过滤，日期金额格式化等等，使用非常方便</li>
<li>宏定义（类似jsp标签）非常方便，优于jsp的tag</li>
<li>使用表达式语言<h3 id="缺点-2">缺点</h3></li>
<li>不是官方标准</li>
<li>用户群体和第三方标签库没有jsp多</li>
</ol>
<h2 id="Jade">Jade</h2><ul>
<li>Jade 很简洁，表达能力也很强，但不够直观，学习和适应成本高，大量的tab和空格容易出错。</li>
<li>Jade 处理模板时计算量大，在没有缓存的情况下性能低是肯定的。</li>
<li>Jade 对于一个不擅长前端、喜欢Bootstrap和Ctrl c + v 实在不能提高开发效率。</li>
<li>适合后端人员用</li>
</ul>
<h2 id="EJS">EJS</h2><p>简单易用的模板引擎，不过不支持继承，如果只是想要个模板往里面填充数据，是最好的选择</p>
]]></content>
    <summary type="html">
    <![CDATA[常用的模板引擎语言]]>
    
    </summary>
    
      <category term="template" scheme="http://miclee.cn/tags/template/"/>
    
      <category term="java" scheme="http://miclee.cn/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[spring-boot哎哟不错(三) —— 使用spring-boot开发WEB应用]]></title>
    <link href="http://miclee.cn/2015/12/18/spring-boot-3/"/>
    <id>http://miclee.cn/2015/12/18/spring-boot-3/</id>
    <published>2015-12-18T02:04:11.000Z</published>
    <updated>2015-12-24T00:56:54.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> Spring Boot非常适合开发WEB应用程序，你可以使用内嵌的Tomcat、Jetty或Undertow轻轻松松创建一个HTTP服务器。大多数的WEB应用都使用spring-boot-starter-web模块进行快速搭建和运行。spring-boot哎哟不错系列第三篇，哎哟不错系列只记录spring-boot使用过程中重要的部分。 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="Spring_Web_MVC_框架">Spring Web MVC 框架</h2><p>Spring MVC框架是一个富”模型，视图，控制器”的web框架。 Spring MVC允许你创建特定的 @Controller 或 @RestController beans来处理传入的HTTP请求。 使用 @RequestMapping 注解可以将控制器中的方法映射到相应的HTTP请求。以下是个典型的 @RestController ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@RestController</span></span><br><span class="line"><span class="annotation">@RequestMapping</span>(value=<span class="string">"/users"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@RequestMapping</span>(value=<span class="string">"/&#123;user&#125;"</span>, method=RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable Long user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@RequestMapping</span>(value=<span class="string">"/&#123;user&#125;/customers"</span>, method=RequestMethod.GET)</span><br><span class="line">    <span class="function">List&lt;Customer&gt; <span class="title">getUserCustomers</span><span class="params">(@PathVariable Long user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@RequestMapping</span>(value=<span class="string">"/&#123;user&#125;"</span>, method=RequestMethod.DELETE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">deleteUser</span><span class="params">(@PathVariable Long user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Spring_MVC_auto-configuration">Spring MVC auto-configuration</h2><p>Spring Boot为Spring MVC提供适用于多数应用的自动配置功能。在Spring默认基础上，自动配置添加了以下特性：</p>
<ol>
<li>引入ContentNegotiatingViewResolver和BeanNameViewResolver beans。</li>
<li>对静态资源的支持，包括对WebJars的支持。</li>
<li>自动注册Converter，GenericConverter，Formatter beans。</li>
<li>对HttpMessageConverters的支持。</li>
<li>自动注册MessageCodeResolver。</li>
<li>对静态index.html的支持。</li>
<li>对自定义Favicon的支持。<br>如果想全面控制Spring MVC，你可以添加自己的@Configuration，并使用@EnableWebMvc对其注解。如果想保留Spring Boot MVC的特性，并只是添加其他的<a href="http://docs.spring.io/spring/docs/4.1.4.RELEASE/spring-framework-reference/htmlsingle/#mvc" target="_blank" rel="external">MVC配置</a>(拦截器，formatters，视图控制器等)，你可以添加自己的WebMvcConfigurerAdapter类型的@Bean（不使用@EnableWebMvc注解）</li>
</ol>
<h2 id="HttpMessageConverters">HttpMessageConverters</h2><p>Spring MVC使用HttpMessageConverter接口转换HTTP请求和响应。合理的缺省值被包含的恰到好处（out of the box），例如对象可以自动转换为JSON（使用Jackson库）或XML（如果Jackson XML扩展可用则使用它，否则使用JAXB）。字符串默认使用UTF-8编码。</p>
<p>如果需要添加或自定义转换器，你可以使用Spring Boot的HttpMessageConverters类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.web.HttpMessageConverters;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.*;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpMessageConverters <span class="title">customConverters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HttpMessageConverter&lt;?&gt; additional = ...</span><br><span class="line">        HttpMessageConverter&lt;?&gt; another = ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpMessageConverters(additional, another);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何在上下文中出现的HttpMessageConverter bean将会添加到converters列表，你可以通过这种方式覆盖默认的转换器（converters）。</p>
<h2 id="MessageCodesResolver">MessageCodesResolver</h2><p>Spring MVC有一个策略，用于从绑定的errors产生用来渲染错误信息的错误码：MessageCodesResolver。如果设置spring.mvc.message-codes-resolver.format属性为PREFIX_ERROR_CODE或POSTFIX_ERROR_CODE（具体查看DefaultMessageCodesResolver.Format枚举值），Spring Boot会为你创建一个MessageCodesResolver。</p>
<h2 id="Static_静态内容">Static 静态内容</h2><p>默认情况下，Spring Boot从classpath下一个叫/static（/public，/resources或/META-INF/resources）的文件夹或从ServletContext根目录提供静态内容。这使用了Spring MVC的ResourceHttpRequestHandler，所以你可以通过添加自己的WebMvcConfigurerAdapter并覆写addResourceHandlers方法来改变这个行为（加载静态文件）。</p>
<p>在一个单独的web应用中，容器默认的servlet是开启的，如果Spring决定不处理某些请求，默认的servlet作为一个回退（降级）将从ServletContext根目录加载内容。大多数时候，这不会发生（除非你修改默认的MVC配置），因为Spring总能够通过DispatcherServlet处理请求。</p>
<p>此外，上述标准的静态资源位置有个例外情况是Webjars内容。任何在/webjars/** 路径下的资源都将从jar文件中提供，只要它们以Webjars的格式打包。</p>
<blockquote>
<p>注：如果你的应用将被打包成jar，那就不要使用src/main/webapp文件夹。尽管该文件夹是一个共同的标准，但它仅在打包成war的情况下起作用，并且如果产生一个jar，多数构建工具都会静悄悄的忽略它。</p>
</blockquote>
<h2 id="Template_engines_模板引擎">Template engines 模板引擎</h2><p>正如REST web服务，你也可以使用Spring MVC提供动态HTML内容。Spring MVC支持各种各样的模板技术，包括Velocity, FreeMarker和JSPs。很多其他的模板引擎也提供它们自己的Spring MVC集成。</p>
<p>Spring Boot为以下的模板引擎提供自动配置支持：</p>
<ul>
<li>FreeMarker</li>
<li>Groovy</li>
<li>Thymeleaf</li>
<li>Velocity</li>
<li>Mustache</li>
<li>JSPS</li>
</ul>
<blockquote>
<p>注：如果可能的话，应该忽略JSPs，因为在内嵌的servlet容器使用它们时存在一些<a href="http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-jsp-limitations" target="_blank" rel="external">已知的限制</a>:</p>
<ul>
<li>可执行的jar包不能工作（标准war包在tomcat里可以工作；可执行war包可以直接工作或部署在tomcat里）</li>
<li>不能使用Jetty作为内嵌式容器</li>
<li>不能使用Undertow作为容器</li>
</ul>
<p>使用jsp时必须增加Jasper模块依赖：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="title">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>Jasper子模块：这个子模块负责jsp页面的解析、jsp属性的验证，同时也负责将jsp页面动态转换为java代码并编译成class文件。在Tomcat源代码中，凡是属于org.apache.jasper包及其子包中的源代码都属于这个子模块；</p>
<p>当你使用这些引擎的任何一种，并采用默认的配置，你的模板将会从src/main/resources/templates目录下自动加载。</p>
<p>注：IntelliJ IDEA根据你运行应用的方式会对classpath进行不同的整理。在IDE里通过main方法运行你的应用跟从Maven或Gradle或打包好的jar中运行相比会导致不同的顺序。这可能导致Spring Boot不能从classpath下成功地找到模板。如果遇到这个问题，你可以在IDE里重新对classpath进行排序，将模块的类和资源放到第一位。或者，你可以配置模块的前缀为classpath*:/templates/，这样会查找classpath下的所有模板目录。</p>
<h2 id="Error_Handling_错误处理">Error Handling 错误处理</h2><p>Spring Boot默认提供一个/error映射用来以合适的方式处理所有的错误，并且它在servlet容器中注册了一个全局的 错误页面。对于机器客户端（相对于浏览器而言，浏览器偏重于人的行为），它会产生一个具有详细错误，HTTP状态，异常信息的JSON响应。对于浏览器客户端，它会产生一个白色标签样式（whitelabel）的错误视图，该视图将以HTML格式显示同样的数据（可以添加一个解析为erro的View来自定义它）。为了完全替换默认的行为，你可以实现ErrorController，并注册一个该类型的bean定义，或简单地添加一个ErrorAttributes类型的bean以使用现存的机制，只是替换显示的内容。</p>
<p>如果在某些条件下需要比较多的错误页面，内嵌的servlet容器提供了一个统一的Java DSL（领域特定语言）来自定义错误处理。 示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EmbeddedServletContainerCustomizer <span class="title">containerCustomizer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyCustomizer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCustomizer</span> <span class="keyword">implements</span> <span class="title">EmbeddedServletContainerCustomizer</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableEmbeddedServletContainer container)</span> </span>&#123;</span><br><span class="line">        container.addErrorPages(<span class="keyword">new</span> ErrorPage(HttpStatus.BAD_REQUEST, <span class="string">"/400"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以使用常规的Spring MVC特性来处理错误，比如@ExceptionHandler方法和@ControllerAdvice。ErrorController将会捡起任何没有处理的异常。</p>
<p>N.B. 如果你为一个路径注册一个ErrorPage，最终被一个过滤器（Filter）处理（对于一些非Spring web框架，像Jersey和Wicket这很常见），然后过滤器需要显式注册为一个ERROR分发器（dispatcher）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">myFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FilterRegistrationBean registration = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">    registration.setFilter(<span class="keyword">new</span> MyFilter());</span><br><span class="line">    ...</span><br><span class="line">    registration.setDispatcherTypes(EnumSet.allOf(DispatcherType.class));</span><br><span class="line">    <span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：默认的FilterRegistrationBean没有包含ERROR分发器类型。</p>
<h2 id="Servlets和Filters">Servlets和Filters</h2><p>当使用内嵌的servlet容器时，你可以直接将servlet和filter注册为Spring的beans。在配置期间，如果你想引用来自application.properties的值，这是非常方便的。默认情况下，如果上下文只包含单一的Servlet，那它将被映射到根路径（/）。在多Servlet beans的情况下，bean的名称将被用作路径的前缀。过滤器会被映射到 /*。</p>
<p>如果基于约定（convention-based）的映射不够灵活，你可以使用ServletRegistrationBean和FilterRegistrationBean类实现完全的控制。如果你的bean实现了ServletContextInitializer接口，也可以直接注册它们。</p>
<h2 id="EmbeddedWebApplicationContext">EmbeddedWebApplicationContext</h2><p>Spring Boot底层使用了一个新的ApplicationContext类型，用于对内嵌servlet容器的支持。EmbeddedWebApplicationContext是一个特殊类型的WebApplicationContext，它通过搜索一个单一的EmbeddedServletContainerFactory bean来启动自己。通常，TomcatEmbeddedServletContainerFactory，JettyEmbeddedServletContainerFactory或UndertowEmbeddedServletContainerFactory将被自动配置。</p>
<p>注：你通常不需要知道这些实现类。大多数应用将被自动配置，并根据你的行为创建合适的ApplicationContext和EmbeddedServletContainerFactory。</p>
<h2 id="自定义内嵌servlet容器">自定义内嵌servlet容器</h2><p>常见的Servlet容器设置可以通过Spring Environment属性进行配置。通常，你会把这些属性定义到application.properties文件中。 常见的服务器设置包括：</p>
<p>server.port - 进来的HTTP请求的监听端口号<br>server.address - 绑定的接口地址<br>server.sessionTimeout - session超时时间<br>具体参考<a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java" target="_blank" rel="external">ServerProperties</a>。</p>
<p>编程方式的自定义<br>如果需要以编程的方式配置内嵌的servlet容器，你可以注册一个实现EmbeddedServletContainerCustomizer接口的Spring bean。EmbeddedServletContainerCustomizer提供对ConfigurableEmbeddedServletContainer的访问，ConfigurableEmbeddedServletContainer包含很多自定义的setter方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.context.embedded.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizationBean</span> <span class="keyword">implements</span> <span class="title">EmbeddedServletContainerCustomizer</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableEmbeddedServletContainer container)</span> </span>&#123;</span><br><span class="line">        container.setPort(<span class="number">9000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接自定义ConfigurableEmbeddedServletContainer<br>如果上面的自定义手法过于受限，你可以自己注册TomcatEmbeddedServletContainerFactory，JettyEmbeddedServletContainerFactory或UndertowEmbeddedServletContainerFactory。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EmbeddedServletContainerFactory <span class="title">servletContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TomcatEmbeddedServletContainerFactory factory = <span class="keyword">new</span> TomcatEmbeddedServletContainerFactory();</span><br><span class="line">    factory.setPort(<span class="number">9000</span>);</span><br><span class="line">    factory.setSessionTimeout(<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">    factory.addErrorPages(<span class="keyword">new</span> ErrorPage(HttpStatus.NOT_FOUND, <span class="string">"/notfound.html"</span>);</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很多可选的配置都提供了setter方法，也提供了一些受保护的钩子方法以满足你的某些特殊需求。具体参考相关文档。</p>
]]></content>
    <summary type="html">
    <![CDATA[Spring Boot非常适合开发WEB应用程序，你可以使用内嵌的Tomcat、Jetty或Undertow轻轻松松创建一个HTTP服务器。大多数的WEB应用都使用spring-boot-starter-web模块进行快速搭建和运行。spring-boot哎哟不错系列第三篇，哎哟不错系列只记录spring-boot使用过程中重要的部分。]]>
    
    </summary>
    
      <category term="spring" scheme="http://miclee.cn/tags/spring/"/>
    
      <category term="spring" scheme="http://miclee.cn/categories/spring/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[spring-boot哎哟不错(二) —— HelloWorld]]></title>
    <link href="http://miclee.cn/2015/12/17/spring-boot-2/"/>
    <id>http://miclee.cn/2015/12/17/spring-boot-2/</id>
    <published>2015-12-17T07:06:38.000Z</published>
    <updated>2015-12-25T02:44:22.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> 动手构建基于spring-boot的hello world。spring-boot哎哟不错系列第二篇，哎哟不错系列只记录spring-boot使用过程中重要的部分。 </em></strong><br><a id="more"></a></p>
<hr>
<h3 id="1-1_创建项目">1.1 创建项目</h3><p>按照约定我们使用Maven来创建一个空项目：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate\</span><br><span class="line">-<span class="ruby"><span class="constant">DgroupId</span>=com.mycompany.app\</span><br><span class="line"></span>-<span class="ruby"><span class="constant">DartifactId</span>=hello-spring-boot\</span><br><span class="line"></span>-<span class="ruby"><span class="constant">DarchetypeArtifactId</span>=maven-archetype-quickstart\</span><br><span class="line"></span>-<span class="ruby"><span class="constant">DinteractiveMode</span>=<span class="keyword">false</span></span></span><br></pre></td></tr></table></figure>
<p>不出意外的话，我们应该会得到一个这样的目录：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    ├── main</span><br><span class="line">    │   └── java</span><br><span class="line">    │       └── com</span><br><span class="line">    │           └── mycompany</span><br><span class="line">    │               └── <span class="keyword">app</span></span><br><span class="line">    │                   └── <span class="keyword">App</span>.java</span><br><span class="line">    └── <span class="keyword">test</span></span><br><span class="line">        └── java</span><br><span class="line">            └── com</span><br><span class="line">                └── mycompany</span><br><span class="line">                    └── <span class="keyword">app</span></span><br><span class="line">                        └── AppTest.java</span><br></pre></td></tr></table></figure>
<p>接下来就应该添加项目依赖了：在<code>pom.xml</code>中添加</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.2.5.RELEASE<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后再添加一个SpringBoot的Maven插件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.2.5.RELEASE<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>编写代码<code>com.mycompany.app.Application</code>如下：（注意包名哦）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mycompany.app;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@RestController</span></span><br><span class="line"><span class="annotation">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello, spring-boot."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码完成！我们把它运行起来吧。简单使用指令<code>mvn spring-boot:run</code>。<br>看到一大堆屏幕输入以后，有提示出现了：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">... ...</span><br><span class="line"><span class="number">2015</span>-<span class="number">07</span>-<span class="number">31</span> <span class="number">16</span>:<span class="number">26</span>:<span class="number">36.722</span>  INFO <span class="number">10037</span> --- [           main] o<span class="class">.s</span><span class="class">.j</span><span class="class">.e</span><span class="class">.a</span><span class="class">.AnnotationMBeanExporter</span>        : Registering beans <span class="keyword">for</span> JMX exposure on startup</span><br><span class="line"><span class="number">2015</span>-<span class="number">07</span>-<span class="number">31</span> <span class="number">16</span>:<span class="number">26</span>:<span class="number">36.780</span>  INFO <span class="number">10037</span> --- [           main] s<span class="class">.b</span><span class="class">.c</span><span class="class">.e</span><span class="class">.t</span><span class="class">.TomcatEmbeddedServletContainer</span> : Tomcat started on <span class="function"><span class="title">port</span><span class="params">(s)</span></span>: <span class="number">8080</span> (http)</span><br><span class="line"><span class="number">2015</span>-<span class="number">07</span>-<span class="number">31</span> <span class="number">16</span>:<span class="number">26</span>:<span class="number">36.781</span>  INFO <span class="number">10037</span> --- [           main] com<span class="class">.mycompany</span><span class="class">.app</span><span class="class">.Application</span>            : Started Application <span class="keyword">in</span> <span class="number">2.312</span> seconds (JVM running <span class="keyword">for</span> <span class="number">2.717</span>)</span><br></pre></td></tr></table></figure>
<p>用浏览器访问以下<code>http://127.0.0.1/hello</code>，看看。</p>
<p>恭喜你！你的第一个SpringBoot程序运行起来了。<br><br>不过在欣喜之余，有没有感到有一丝不安？这个项目里没有<code>xml</code>的Spring配置文件；没有日志配置文件；甚至连<code>web.xml</code>都没有，一个基于<code>Servlet</code>和<code>Spring MVC</code>技术的程序就启动起来了。<br>你一定猜到了，这就是所谓的<code>约定优于配置</code>，麻雀虽小，五脏俱全，该有的组件当然都是存在于Spring上下文的，只不过都是采用的默认配置方式。下一个小节，小老弟展示给你看。</p>
<h3 id="1-2_SpringBoot到底做了什么？">1.2 SpringBoot到底做了什么？</h3><p>到了祭出SpringBoot的一个<code>starter</code>的时候了。所谓<code>starter</code>的，其实就是SpringBoot的插件啦。 注意，我指的是SpringBoot插件，可不是说“SpringBoot相关Maven插件”，这个概念请理解。<br>我们在<a href="https://github.com/yingzhuo/play-with-spring-boot/blob/master/chapter13/index.md" target="_blank" rel="external">第13章</a>，将自己从头到尾自己写一个具有完整功能的<code>spring-boot-starter</code>。<br><br>这个<code>starter</code>的Maven坐标如下：快把它加到<code>pom.xml</code>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.2.5.RELEASE<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个插件功能比较强大，它“默默地”给你的SpringBoot程序，加上了一些<code>Controller</code>，来帮你达到监控等目的。好，加好了就可以，其他什么事情都不用做。<br>重新启动这个项目<code>mvn spring-boot:run</code>，再访问以下<code>http://127.0.0.1/beans</code>，看看。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">  "<span class="attribute">context</span>" : <span class="value"><span class="string">"application"</span></span>,</span><br><span class="line">  "<span class="attribute">parent</span>" : <span class="value"><span class="literal">null</span></span>,</span><br><span class="line">  "<span class="attribute">beans</span>" : <span class="value">[ &#123;</span><br><span class="line">    "<span class="attribute">bean</span>" : <span class="value"><span class="string">"application"</span></span>,</span><br><span class="line">    "<span class="attribute">scope</span>" : <span class="value"><span class="string">"singleton"</span></span>,</span><br><span class="line">    "<span class="attribute">type</span>" : <span class="value"><span class="string">"com.mycompany.app.Application$$EnhancerBySpringCGLIB$$a295be6a"</span></span>,</span><br><span class="line">    "<span class="attribute">resource</span>" : <span class="value"><span class="string">"null"</span></span>,</span><br><span class="line">    "<span class="attribute">dependencies</span>" : <span class="value">[ ]</span><br><span class="line">  </span>&#125;, &#123;</span><br><span class="line">    "<span class="attribute">bean</span>" : <span class="value"><span class="string">"org.springframework.boot.autoconfigure.PropertyPlaceholderAutoConfiguration"</span></span>,</span><br><span class="line">    "<span class="attribute">scope</span>" : <span class="value"><span class="string">"singleton"</span></span>,</span><br><span class="line">    "<span class="attribute">type</span>" : <span class="value"><span class="string">"org.springframework.boot.autoconfigure.PropertyPlaceholderAutoConfiguration$$EnhancerBySpringCGLIB$$1a9215c6"</span></span>,</span><br><span class="line">    "<span class="attribute">resource</span>" : <span class="value"><span class="string">"null"</span></span>,</span><br><span class="line">    "<span class="attribute">dependencies</span>" : <span class="value">[ ]</span><br><span class="line">  </span>&#125;, &#123;</span><br><span class="line">    "<span class="attribute">bean</span>" : <span class="value"><span class="string">"org.springframework.boot.autoconfigure.condition.BeanTypeRegistry"</span></span>,</span><br><span class="line">    "<span class="attribute">scope</span>" : <span class="value"><span class="string">"singleton"</span></span>,</span><br><span class="line">    "<span class="attribute">type</span>" : <span class="value"><span class="string">"org.springframework.boot.autoconfigure.condition.BeanTypeRegistry$OptimizedBeanTypeRegistry"</span></span>,</span><br><span class="line">    "<span class="attribute">resource</span>" : <span class="value"><span class="string">"null"</span></span>,</span><br><span class="line">    "<span class="attribute">dependencies</span>" : <span class="value">[ ]</span><br><span class="line">  </span>&#125;, &#123;</span><br><span class="line">    "<span class="attribute">bean</span>" : <span class="value"><span class="string">"propertySourcesPlaceholderConfigurer"</span></span>,</span><br><span class="line">    "<span class="attribute">scope</span>" : <span class="value"><span class="string">"singleton"</span></span>,</span><br><span class="line">    "<span class="attribute">type</span>" : <span class="value"><span class="string">"org.springframework.context.support.PropertySourcesPlaceholderConfigurer"</span></span>,</span><br><span class="line">    "<span class="attribute">resource</span>" : <span class="value"><span class="string">"class path resource [org/springframework/boot/autoconfigure/PropertyPlaceholderAutoConfiguration.class]"</span></span>,</span><br><span class="line">    "<span class="attribute">dependencies</span>" : <span class="value">[ ]</span><br><span class="line">  </span>&#125;</span><br><span class="line">]</span></span><br></pre></td></tr></table></figure>
<p>不知道你发现了没有，我上面的的JSON是非常漂亮地被格式化了，非常方便阅读，你的浏览器看到的JSON，都是挤作一个团儿，非常难受吧。</p>
<p>添加一个文件：<code>classpath:/META-INF/application.properties</code>，并添加仅仅一条配置。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring<span class="class">.jackson</span><span class="class">.serialization</span><span class="class">.indent_output</span>=true</span><br></pre></td></tr></table></figure>
<p>注意！小老弟是因为受篇幅的限制只列出了三项，这个一定要亲手试一试。在你遇到问题时，请使用此功能，你一定要非常了解你的Spring上下文中到底<br>有些什么组件，如果不是这样的话，可是很容易踩到坑的。 小老弟严肃地开发时，这些bean的源代码，都是一定要大致浏览一遍的。这里先告诉各位一个基本方法，<br>以后我们谈到具体某种技术的时候，再来详细剖析也不迟。</p>
<h3 id="1-3_SpringBoot配置文件">1.3 SpringBoot配置文件</h3><p>正如上一个部分的小节你看到的：<code>classpath:META-INF/application.properties</code>。使用SpringBoot的一个好处就是你可以从成吨的<code>.xml</code>配置文件中稍微<br>解放出一点点。SpringBoot提供两种配置方式，<code>.properties</code>(你已经看到了)，另一种配置方式是<code>.yml</code>。你要是问我哪种方式更好，那么我告诉你，两种差不多。<br>你要问我为什么在整个文章坚持使用<code>.properties</code>，我还真没法回答你，小老弟我是南方人，虽然甜粽子也好吃，但我更偏好咸粽子。<br>想使用<code>.yml</code>方式配置的朋友自己看官方文档吧。</p>
<p>诸如上面提到的<code>spring.jackson.serialization.indent_output</code>我姑且称呼为“SpringBoot预设配置”，SpringBoot提供的预设配置非常丰富，而且相当一部分是有默认值的。<br>如果你还是SpringBoot新手，那么你可能看得一头雾水。没关系，以后慢慢解释。官方文档附录收录了所有预设配置，请<a href="http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#common-application-properties" target="_blank" rel="external">点击</a>这里。</p>
<p>除了“SpringBoot预设配置”之外，我们能自定义吗？当然可以了。此外SpringBoot还提供了一个有用的元注释<code>@EnableConfigurationProperties</code> <br><br>它完整的名称是<code>org.springframework.boot.context.properties.EnableConfigurationProperties</code>，它的用法非常简单了。</p>
<p>假设你的配置：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo<span class="class">.bar</span><span class="class">.name</span>=BillGates</span><br><span class="line">foo<span class="class">.bar</span><span class="class">.age</span>=<span class="number">60</span></span><br><span class="line">foo<span class="class">.bar</span><span class="class">.phone-number</span>=<span class="number">13812345678</span></span><br></pre></td></tr></table></figure></p>
<p>你可以使用这样一个Bean来封装这样的配置:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@ConfigurationProperties</span>(prefix = <span class="string">"foo.bar"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfigBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String phoneNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你就可以让SpringBoot自动帮你把配置绑定到<code>MyConfigBean</code>上了。就像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Configuration</span></span><br><span class="line"><span class="annotation">@EnableConfigurationProperties</span>(&#123;MyConfigBean.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MyConfigBean myConfigBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非常方便吧？光是这样还不够好，其实你的<code>ConfigBean</code>里还可以添加上<code>hibernate-validator</code>(JSR-303)元注释，用来验证配置的正确性。这里就不举例子了，自己试一试就知道了。<br><br>其实还有一种配置项的读取方法，SpringBoot把所有的配置放在一个<code>Placeholder Configurer</code>这种方式出现的非常早了，早在Spring2.x时代貌似就有了。你如果对<code>xml</code>方式配置Spring的话，<br>你可能对下面一个片段比较熟悉。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"dataSource"</span> <span class="attribute">class</span>=<span class="value">"com.mchange.v2.c3p0.ComboPooledDataSource"</span> <span class="attribute">destroy-method</span>=<span class="value">"close"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"driverClass"</span> <span class="attribute">value</span>=<span class="value">"$&#123;jdbc.driverClass&#125;"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"jdbcUrl"</span> <span class="attribute">value</span>=<span class="value">"$&#123;jdbc.url&#125;"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"user"</span> <span class="attribute">value</span>=<span class="value">"$&#123;jdbc.username&#125;"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"password"</span> <span class="attribute">value</span>=<span class="value">"$&#123;jdbc.password&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果你现在依然用<code>xml</code>来配置Spring的话，你的<code>application.properties</code>依然能这么用，这毫无问题。如果你使用“Java Code”配置Spring的话，你可以使用<code>@Value</code>元注释。<br>(这是Spring提供的功能，和SpringBoot关系并不大)就像是下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Value</span>(<span class="string">"$&#123;foo.bar.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Value</span>(<span class="string">"$&#123;foo.bar.age&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Value</span>(<span class="string">"$&#123;foo.bar.phone-number&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> phoneNumber;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyStupidBean <span class="title">myStupidBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyStupidBean(name, age, phoneNumber);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4_Spring配置文件">1.4 Spring配置文件</h3><p>小老弟整个教程都将采用”Java Code”配置方式，但是你要是非要用<code>xml</code>或者你更激进一点喜欢使用<code>groovy dsl</code>，也不是不行。你可以这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@SpringBootApplication</span></span><br><span class="line"><span class="annotation">@ImportResource</span>(&#123;<span class="string">"classpath:conf1.xml"</span>, <span class="string">"classpath:conf2.groovy"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置方式，并没有孰优孰劣之分。不要因为这个与别人争吵，挑一个你自己喜欢的方式就可以了。</p>
<h3 id="1-5_关于Bean的Scan。">1.5 关于Bean的Scan。</h3><p>小老弟习惯用Bean的扫描，如果不用的话，所有的业务Bean，比如说”DAO”，”SERVICE”都需要一个个手工配置的，我觉得这并没有什么实际的好处。<br>事实上，<code>@SpringBootApplication</code>元注释“封装”了<code>@ComponentScan</code>，你使用<code>@SpringBootApplication</code>的同时，包扫描就自动打开了。<br>那么，我们的问题就来了，从哪个package开始扫描呢？是这样的，它扫描启动main方法所在的那个类所在的包及其所有的子包。稍微有点绕吧，没看懂的再看一遍。</p>
<p>如果你正在开发一个基于SpringBoot的应用。那么官方给出的最佳实践是这样。看一看下面的目录结构。</p>
<ul>
<li>com.mycompany.myapp<ul>
<li>dao<ul>
<li>impl</li>
</ul>
</li>
<li>service<ul>
<li>impl</li>
</ul>
</li>
<li>controller</li>
<li>domain</li>
</ul>
</li>
</ul>
<p>大约就是这样的，你的启动程序及其Spring的所有配置类都直接放在<code>com.mycompany.myapp</code>package下。其他的业务相关的组件，让它们被扫描到上下文就好了。<br>SpringBoot建议你保持配置的清爽。 小老弟的所有配套示例代码，也基本上是使用这样一个package结构。</p>
<p>请意识到，上面小节给出的”hello world”程序，<code>com.mycompany.app.Application</code>即是一个配置类，又同时是一个<code>Spring MVC Controller</code>，这只是为了使代码简短而生造的一个例子。</p>
]]></content>
    <summary type="html">
    <![CDATA[动手构建基于spring-boot的hello world。spring-boot哎哟不错系列第二篇，哎哟不错系列只记录spring-boot使用过程中重要的部分。]]>
    
    </summary>
    
      <category term="spring-boot" scheme="http://miclee.cn/tags/spring-boot/"/>
    
      <category term="spring" scheme="http://miclee.cn/categories/spring/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为什么要使用SLF4J而不是Log4J]]></title>
    <link href="http://miclee.cn/2015/12/17/slf4j/"/>
    <id>http://miclee.cn/2015/12/17/slf4j/</id>
    <published>2015-12-17T05:36:11.000Z</published>
    <updated>2016-04-07T03:45:14.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> 每一个Java程序员都知道日志对于任何一个Java应用程序，尤其是服务端程序是至关重要的，而很多程序员也已经熟悉各种不同的日志库如java.util.logging、Apache log4j、logback。但如果你还不知道SLF4J（Simple logging facade for Java）的话，那么是时候去在你项目中学习使用SLF4J了。 在这篇文章中，我们将学习为什么使用SLF4J比log4j或者java.util.logging要优秀。 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="介绍">介绍</h2><p>SLF4J不同于其他日志类库，与其它有很大的不同。SLF4J(Simple logging Facade for Java)不是一个真正的日志实现，而是一个抽象层（ abstraction layer），它允许你在后台使用任意一个日志类库。如果是在编写供内外部都可以使用的API或者通用类库，那么你真不会希望使用你类库的客户端必须使用你选择的日志类库。</p>
<p>如果一个项目已经使用了log4j，而你加载了一个类库，比方说 Apache Active MQ——它依赖于于另外一个日志类库logback，那么你就需要把它也加载进去。但如果Apache Active MQ使用了SLF4J，你可以继续使用你的日志类库而无语忍受加载和维护一个新的日志框架的痛苦。</p>
<p>总的来说，SLF4J使你的代码独立于任意一个特定的日志API，这是一个对于开发API的开发者很好的思想。虽然抽象日志类库的思想已经不是新鲜的事物而且Apache commons logging也已经在使用这种思想了，但现在SLF4J正迅速成为Java世界的日志标准。让我们再看看几个使用SLF4J而不是log4j、logback或者java.util.logging的理由。</p>
<h2 id="SLF4J对比Log4J，logback和java-util-Logging的优势">SLF4J对比Log4J，logback和java.util.Logging的优势</h2><p>正如我之前说的，在你的代码中使用SLF4J写日志语句的主要出发点是使得你的程序独立于任意特定的日志类库，依赖于特定类可能需要不同与你已有的配置，并且导致更多维护的麻烦。但除此之外，还要一个SLF4J API的特性使得我坚持使用SLF4J而抛弃我长期间钟爱的Lof4j的理由，是被称为占位符(place holder)，在代码中表示为“{}”的特性。占位符是一个非常类似于在String的format()方法中的%s，因为它会在运行时被某个提供的实际字符串所替换。这不仅降低了你代码中字符串连接次数，而且还节省了新建的String对象。即使你可能没需要那些对象，但这个依旧成立，取决于你的生产环境的日志级别，例如在DEBUG或者INFO级别的字符串连接。因为String对象是不可修改的并且它们建立在一个String池中，它们消耗堆内存( heap memory)而且大多数时间他们是不被需要的，例如当你的应用程序在生产环境以ERROR级别运行时候，一个String使用在DEBUG语句就是不被需要的。通过使用SLF4J,你可以在运行时延迟字符串的建立，这意味着只有需要的String对象才被建立。而如果你已经使用log4j，那么你已经对于在if条件中使用debug语句这种变通方案十分熟悉了，但SLF4J的占位符就比这个好用得多。</p>
<p>这是你在Log4j中使用的方案，但肯定这一点都不有趣并且降低了代码可读性因为增加了不必要的繁琐重复代码(boiler-plate code)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">"Processing trade with id: "</span> + id + <span class="string">" symbol: "</span> + symbol);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一方面，如果你使用SLF4J的话，你可以得到在极简洁的格式的结果，就像以下展示的一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">"Processing trade with id: &#123;&#125; and symbol : &#123;&#125; "</span>, id, symbol);</span><br></pre></td></tr></table></figure>
<p>在SLF4J，我们不需要字符串连接而且不会导致暂时不需要的字符串消耗。取而代之的，我们在一个以占位符和以参数传递实际值的模板格式下写日志信息。你可能会在想万一我有很个参数怎么办？嗯，那么你可以选择使用变量参数版本的日志方法或者用以Object数组传递。这是一个相当的方便和高效方法的打日志方法。记住，在生产最终日志信息的字符串之前，这个方法会检查一个特定的日志级别是不是打开了，这不仅降低了内存消耗而且预先降低了CPU去处理字符串连接命令的时间。这里是使用SLF4J日志方法的代码，来自于slf4j-log4j12-1.6.1.jar中的Log4j的适配器类Log4jLoggerAdapter。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String format, Object arg1, Object arg2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);</span><br><span class="line">        logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，我们也很值得知道打日志是对应用程序的性能有着很大影响的，在生产环节上只进行必要的日志记录是我们所建议的。</p>
<h2 id="怎么用SLF4J做Log4J的日志记录">怎么用SLF4J做Log4J的日志记录</h2><p>除了以上好处，我想还有一个告诫，就是为了使用SLF4J，你不仅需要包含SLF4J的API jar包，例如 slf4j-api-1.6.1.jar，还需要相关Jar包，这取决于你在后台使用的日志类库。如果你想要使用和Log4J 一起使用SLF4J ，Simple Logging Facade for Java,，你需要包含以下的Jar包在你的classpath中，取决于哪个SLF4J和你在使用的Log4J的版本。例如：</p>
<ul>
<li>slf4j-api-1.6.1.jar – JAR for SLF4J API</li>
<li>log4j-1.2.16.jar – JAR for Log4J API</li>
<li>slf4j-log4j12-1.6.1.jar – Log4J Adapter for SLF4J</li>
</ul>
<p>如果你在使用Maven去管理你的项目依赖，你只需要包含SLF4J JAR包，maven会包含它的依赖的相关包。为了和SLF4J一起中使用Log4J，你可以包含以下的依赖在你项目中的pom.xml。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.6.1<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.6.1<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>还有，如果你对于使用变量参数版本（variable argument version ）的日志方法感兴趣的话，那么就导入SLF4J 1.7的版本吧。</p>
<h2 id="总结">总结</h2><p>总结这次说的，我建议使用SLF4J的而不是直接使用 Log4j, commons logging, logback 或者 java.util.logging 已经足够充分了。</p>
<ol>
<li>在你的开源或内部类库中使用SLF4J会使得它独立于任何一个特定的日志实现，这意味着不需要管理多个日志配置或者多个日志类库，你的客户端会很感激这点。</li>
<li>SLF4J提供了基于占位符的日志方法，这通过去除检查isDebugEnabled(), isInfoEnabled()等等，提高了代码可读性。</li>
<li>通过使用SLF4J的日志方法，你可以延迟构建日志信息（Srting）的开销，直到你真正需要，这对于内存和CPU都是高效的。</li>
<li>作为附注，更少的暂时的字符串意味着垃圾回收器（Garbage Collector）需要做更好的工作，这意味着你的应用程序有为更好的吞吐量和性能。</li>
<li>这些好处只是冰山一角，你将在开始使用SL4J和阅读其中代码的时候知道更多的好处。我强烈建议，任何一个新的Java程序员，都应该使用SLF4J做日志而不是使用包括Log4J在内的其他日志API。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[每一个Java程序员都知道日志对于任何一个Java应用程序，尤其是服务端程序是至关重要的，而很多程序员也已经熟悉各种不同的日志库如java.util.logging、Apache log4j、logback。但如果你还不知道SLF4J（Simple logging facade for Java）的话，那么是时候去在你项目中学习使用SLF4J了。 在这篇文章中，我们将学习为什么使用SLF4J比log4j或者java.util.logging要优秀。]]>
    
    </summary>
    
      <category term="slf4j" scheme="http://miclee.cn/tags/slf4j/"/>
    
      <category term="java" scheme="http://miclee.cn/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[常用Maven插件介绍]]></title>
    <link href="http://miclee.cn/2015/12/16/maven-plugin/"/>
    <id>http://miclee.cn/2015/12/16/maven-plugin/</id>
    <published>2015-12-16T08:36:27.000Z</published>
    <updated>2016-04-07T03:45:14.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> Maven本质上是一个插件框架，它的核心并不执行任何具体的构建任务，所有这些任务都交给插件来完成，例如编译源代码是由maven-compiler-plugin完成的。进一步说，每个任务对应了一个插件目标（goal），每个插件会有一个或者多个目标，例如maven-compiler-plugin的compile目标用来编译位于src/main/java/目录下的主源码，testCompile目标用来编译位于src/test/java/目录下的测试源码。 </em></strong><br><a id="more"></a></p>
<hr>
<blockquote>
<p>多年来Maven社区积累了大量的经验，并随之形成了一个成熟的插件生态圈。Maven官方有两个插件列表，第一个列表的GroupId为org.apache.maven.plugins，这里的插件最为成熟，具体地址为：<a href="http://maven.apache.org/plugins/index.html" target="_blank" rel="external">http://maven.apache.org/plugins/index.html</a>。第二个列表的GroupId为org.codehaus.mojo，这里的插件没有那么核心，但也有不少十分有用，其地址为：<a href="http://mojo.codehaus.org/plugins.html" target="_blank" rel="external">http://mojo.codehaus.org/plugins.html</a>。</p>
</blockquote>
<h2 id="maven-antrun-plugin">maven-antrun-plugin</h2><p><a href="http://maven.apache.org/plugins/maven-antrun-plugin" target="_blank" rel="external">http://maven.apache.org/plugins/maven-antrun-plugin</a></p>
<p>maven-antrun-plugin能让用户在Maven项目中运行Ant任务。用户可以直接在该插件的配置以Ant的方式编写Target，然后交给该插件的run目标去执行。在一些由Ant往Maven迁移的项目中，该插件尤其有用。此外当你发现需要编写一些自定义程度很高的任务，同时又觉得Maven不够灵活时，也可以以Ant的方式实现之。maven-antrun-plugin的run目标通常与生命周期绑定运行。</p>
<h2 id="maven-archetype-plugin">maven-archetype-plugin</h2><p><a href="http://maven.apache.org/archetype/maven-archetype-plugin/" target="_blank" rel="external">http://maven.apache.org/archetype/maven-archetype-plugin/</a></p>
<p>Archtype指项目的骨架，Maven初学者最开始执行的Maven命令可能就是mvn archetype:generate，这实际上就是让maven-archetype-plugin生成一个很简单的项目骨架，帮助开发者快速上手。可能也有人看到一些文档写了mvn archetype:create，但实际上create目标已经被弃用了，取而代之的是generate目标，该目标使用交互式的方式提示用户输入必要的信息以创建项目，体验更好。maven-archetype-plugin还有一些其他目标帮助用户自己定义项目原型，例如你由一个产品需要交付给很多客户进行二次开发，你就可以为他们提供一个Archtype，帮助他们快速上手。</p>
<h2 id="maven-dependency-plugin">maven-dependency-plugin</h2><p><a href="http://maven.apache.org/plugins/maven-dependency-plugin/" target="_blank" rel="external">http://maven.apache.org/plugins/maven-dependency-plugin/</a></p>
<p>maven-dependency-plugin最大的用途是帮助分析项目依赖，dependency:list能够列出项目最终解析到的依赖列表，dependency:tree能进一步的描绘项目依赖树，dependency:analyze可以告诉你项目依赖潜在的问题，如果你有直接使用到的却未声明的依赖，该目标就会发出警告。maven-dependency-plugin还有很多目标帮助你操作依赖文件，例如dependency:copy-dependencies能将项目依赖从本地Maven仓库复制到某个特定的文件夹下面。</p>
<h2 id="maven-enforcer-plugin">maven-enforcer-plugin</h2><p><a href="http://maven.apache.org/plugins/maven-enforcer-plugin/" target="_blank" rel="external">http://maven.apache.org/plugins/maven-enforcer-plugin/</a></p>
<p>在一个稍大一点的组织或团队中，你无法保证所有成员都熟悉Maven，那他们做一些比较愚蠢的事情就会变得很正常，例如给项目引入了外部的SNAPSHOT依赖而导致构建不稳定，使用了一个与大家不一致的Maven版本而经常抱怨构建出现诡异问题。maven-enforcer-plugin能够帮助你避免之类问题，它允许你创建一系列规则强制大家遵守，包括设定Java版本、设定Maven版本、禁止某些依赖、禁止SNAPSHOT依赖。只要在一个父POM配置规则，然后让大家继承，当规则遭到破坏的时候，Maven就会报错。除了标准的规则之外，你还可以扩展该插件，编写自己的规则。maven-enforcer-plugin的enforce目标负责检查规则，它默认绑定到生命周期的validate阶段。</p>
<h2 id="maven-help-plugin">maven-help-plugin</h2><p><a href="http://maven.apache.org/plugins/maven-help-plugin/" target="_blank" rel="external">http://maven.apache.org/plugins/maven-help-plugin/</a></p>
<p>maven-help-plugin是一个小巧的辅助工具，最简单的help:system可以打印所有可用的环境变量和Java系统属性。help:effective-pom和help:effective-settings最为有用，它们分别打印项目的有效POM和有效settings，有效POM是指合并了所有父POM（包括Super POM）后的XML，当你不确定POM的某些信息从何而来时，就可以查看有效POM。有效settings同理，特别是当你发现自己配置的settings.xml没有生效时，就可以用help:effective-settings来验证。此外，maven-help-plugin的describe目标可以帮助你描述任何一个Maven插件的信息，还有all-profiles目标和active-profiles目标帮助查看项目的Profile。</p>
<h2 id="maven-release-plugin">maven-release-plugin</h2><p><a href="http://maven.apache.org/plugins/maven-release-plugin/" target="_blank" rel="external">http://maven.apache.org/plugins/maven-release-plugin/</a></p>
<p>maven-release-plugin的用途是帮助自动化项目版本发布，它依赖于POM中的SCM信息。release:prepare用来准备版本发布，具体的工作包括检查是否有未提交代码、检查是否有SNAPSHOT依赖、升级项目的SNAPSHOT版本至RELEASE版本、为项目打标签等等。release:perform则是签出标签中的RELEASE源码，构建并发布。版本发布是非常琐碎的工作，它涉及了各种检查，而且由于该工作仅仅是偶尔需要，因此手动操作很容易遗漏一些细节，maven-release-plugin让该工作变得非常快速简便，不易出错。maven-release-plugin的各种目标通常直接在命令行调用，因为版本发布显然不是日常构建生命周期的一部分。</p>
<h2 id="maven-resources-plugin">maven-resources-plugin</h2><p><a href="http://maven.apache.org/plugins/maven-resources-plugin/" target="_blank" rel="external">http://maven.apache.org/plugins/maven-resources-plugin/</a></p>
<p>为了使项目结构更为清晰，Maven区别对待Java代码文件和资源文件，maven-compiler-plugin用来编译Java代码，maven-resources-plugin则用来处理资源文件。默认的主资源文件目录是src/main/resources，很多用户会需要添加额外的资源文件目录，这个时候就可以通过配置maven-resources-plugin来实现。此外，资源文件过滤也是Maven的一大特性，你可以在资源文件中使用${propertyName}形式的Maven属性，然后配置maven-resources-plugin开启对资源文件的过滤，之后就可以针对不同环境通过命令行或者Profile传入属性的值，以实现更为灵活的构建。</p>
<h2 id="maven-surefire-plugin">maven-surefire-plugin</h2><p><a href="http://maven.apache.org/plugins/maven-surefire-plugin/" target="_blank" rel="external">http://maven.apache.org/plugins/maven-surefire-plugin/</a></p>
<p>可能是由于历史的原因，Maven 2/3中用于执行测试的插件不是maven-test-plugin，而是maven-surefire-plugin。其实大部分时间内，只要你的测试类遵循通用的命令约定（以Test结尾、以TestCase结尾、或者以Test开头），就几乎不用知晓该插件的存在。然而在当你想要跳过测试、排除某些测试类、或者使用一些TestNG特性的时候，了解maven-surefire-plugin的一些配置选项就很有用了。例如 mvn test -Dtest=FooTest 这样一条命令的效果是仅运行FooTest测试类，这是通过控制maven-surefire-plugin的test参数实现的。</p>
<h2 id="build-helper-maven-plugin">build-helper-maven-plugin</h2><p><a href="http://mojo.codehaus.org/build-helper-maven-plugin/" target="_blank" rel="external">http://mojo.codehaus.org/build-helper-maven-plugin/</a></p>
<p>Maven默认只允许指定一个主Java代码目录和一个测试Java代码目录，虽然这其实是个应当尽量遵守的约定，但偶尔你还是会希望能够指定多个源码目录（例如为了应对遗留项目），build-helper-maven-plugin的add-source目标就是服务于这个目的，通常它被绑定到默认生命周期的generate-sources阶段以添加额外的源码目录。需要强调的是，这种做法还是不推荐的，因为它破坏了 Maven的约定，而且可能会遇到其他严格遵守约定的插件工具无法正确识别额外的源码目录。</p>
<p>build-helper-maven-plugin的另一个非常有用的目标是attach-artifact，使用该目标你可以以classifier的形式选取部分项目文件生成附属构件，并同时install到本地仓库，也可以deploy到远程仓库。</p>
<h2 id="exec-maven-plugin">exec-maven-plugin</h2><p><a href="http://mojo.codehaus.org/exec-maven-plugin/" target="_blank" rel="external">http://mojo.codehaus.org/exec-maven-plugin/</a></p>
<p>exec-maven-plugin很好理解，顾名思义，它能让你运行任何本地的系统程序，在某些特定情况下，运行一个Maven外部的程序可能就是最简单的问题解决方案，这就是exec:exec的用途，当然，该插件还允许你配置相关的程序运行参数。除了exec目标之外，exec-maven-plugin还提供了一个java目标，该目标要求你提供一个mainClass参数，然后它能够利用当前项目的依赖作为classpath，在同一个JVM中运行该mainClass。有时候，为了简单的演示一个命令行Java程序，你可以在POM中配置好exec-maven-plugin的相关运行参数，然后直接在命令运行 mvn exec:java 以查看运行效果。</p>
<h2 id="jetty-maven-plugin">jetty-maven-plugin</h2><p><a href="http://wiki.eclipse.org/Jetty/Feature/Jetty_Maven_Plugin" target="_blank" rel="external">http://wiki.eclipse.org/Jetty/Feature/Jetty_Maven_Plugin</a></p>
<p>在进行Web开发的时候，打开浏览器对应用进行手动的测试几乎是无法避免的，这种测试方法通常就是将项目打包成war文件，然后部署到Web容器中，再启动容器进行验证，这显然十分耗时。为了帮助开发者节省时间，jetty-maven-plugin应运而生，它完全兼容 Maven项目的目录结构，能够周期性地检查源文件，一旦发现变更后自动更新到内置的Jetty Web容器中。做一些基本配置后（例如Web应用的contextPath和自动扫描变更的时间间隔），你只要执行 mvn jetty:run ，然后在IDE中修改代码，代码经IDE自动编译后产生变更，再由jetty-maven-plugin侦测到后更新至Jetty容器，这时你就可以直接测试Web页面了。需要注意的是，jetty-maven-plugin并不是宿主于Apache或Codehaus的官方插件，因此使用的时候需要额外的配置settings.xml的pluginGroups元素，将org.mortbay.jetty这个pluginGroup加入。</p>
<h2 id="tomcat7-maven-plugin">tomcat7-maven-plugin</h2><p><a href="http://tomcat.apache.org/maven-plugin-trunk/" target="_blank" rel="external">http://tomcat.apache.org/maven-plugin-trunk/</a></p>
<p>内嵌一个tomcat容器</p>
<h2 id="versions-maven-plugin">versions-maven-plugin</h2><p><a href="http://mojo.codehaus.org/versions-maven-plugin/" target="_blank" rel="external">http://mojo.codehaus.org/versions-maven-plugin/</a></p>
<p>很多Maven用户遇到过这样一个问题，当项目包含大量模块的时候，为他们集体更新版本就变成一件烦人的事情，到底有没有自动化工具能帮助完成这件事情呢？（当然你可以使用sed之类的文本操作工具，不过不在本文讨论范围）答案是肯定的，versions-maven- plugin提供了很多目标帮助你管理Maven项目的各种版本信息。例如最常用的，命令 mvn versions:set -DnewVersion=1.1-SNAPSHOT 就能帮助你把所有模块的版本更新到1.1-SNAPSHOT。该插件还提供了其他一些很有用的目标，display-dependency- updates能告诉你项目依赖有哪些可用的更新；类似的display-plugin-updates能告诉你可用的插件更新；然后use- latest-versions能自动帮你将所有依赖升级到最新版本。最后，如果你对所做的更改满意，则可以使用 mvn versions:commit 提交，不满意的话也可以使用 mvn versions:revert 进行撤销。</p>
<h2 id="maven-javadoc-plugin">maven-javadoc-plugin</h2><p><a href="http://maven.apache.org/plugins/maven-javadoc-plugin/" target="_blank" rel="external">http://maven.apache.org/plugins/maven-javadoc-plugin/</a></p>
<p>顾名思义，生成javadoc</p>
<h2 id="spring-boot-maven-plugin">spring-boot-maven-plugin</h2><p><a href="http://docs.spring.io/spring-boot/docs/current/maven-plugin/" target="_blank" rel="external">http://docs.spring.io/spring-boot/docs/current/maven-plugin/</a></p>
<p>SpringBoot的Maven插件，根据不同goal有不同用处：</p>
<table>
<thead>
<tr>
<th>Goal</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>spring-boot:help</td>
<td>展示插件帮助信息</td>
</tr>
<tr>
<td>spring-boot:repackage</td>
<td>将maven-jar-plugin插件构建的JAR包 或者maven-war-plugin插件构建的war包重新打包（类型根据项目packaging属性）。repackage的类型默认根据package的类型去猜测，可能的值有JAR, WAR, ZIP, DIR, NONE。WAR/JAR的项目默认打包成可执行的，此时需要有main class。或者设置属性 layout=NONE，则只简单打包成jar或者war。</td>
</tr>
<tr>
<td>spring-boot:run</td>
<td>执行一个项目（基于pom而不是jar）</td>
</tr>
<tr>
<td>spring-boot:start</td>
<td>不同于run，start可以加入其他goal，常用于跟测试整合，如需要应用在某个测试案例前或者后启动</td>
</tr>
<tr>
<td>spring-boot-stop</td>
<td>关闭被”start” goal开启的应用，常用于某个测试案例完成后调用</td>
</tr>
</tbody>
</table>
<p>加上springloaded依赖，则可实现热部署。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>springloaded<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.2.3.RELEASE<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[Maven本质上是一个插件框架，它的核心并不执行任何具体的构建任务，所有这些任务都交给插件来完成，例如编译源代码是由maven-compiler-plugin完成的。进一步说，每个任务对应了一个插件目标（goal），每个插件会有一个或者多个目标，例如maven-compiler-plugin的compile目标用来编译位于src/main/java/目录下的主源码，testCompile目标用来编译位于src/test/java/目录下的测试源码。]]>
    
    </summary>
    
      <category term="maven" scheme="http://miclee.cn/tags/maven/"/>
    
      <category term="java" scheme="http://miclee.cn/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【转】使用 Spring Security 保护 Web 应用的安全]]></title>
    <link href="http://miclee.cn/2015/12/14/spring-security/"/>
    <id>http://miclee.cn/2015/12/14/spring-security/</id>
    <published>2015-12-14T03:29:16.000Z</published>
    <updated>2015-12-28T06:29:04.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> 安全一直是 Web 应用开发中非常重要的一个方面。从安全的角度来说，需要考虑用户认证和授权两个方面。为 Web 应用增加安全方面的能力并非一件简单的事情，需要考虑不同的认证和授权机制。Spring Security 为使用 Spring 框架的 Web 应用提供了良好的支持。本文将详细介绍如何使用 Spring Security 框架为 Web 应用提供安全支持。 </em></strong><br><a id="more"></a></p>
<hr>
<blockquote>
<p>在 Web 应用开发中，安全一直是非常重要的一个方面。安全虽然属于应用的非功能性需求，但是应该在应用开发的初期就考虑进来。如果在应用开发的后期才考虑安全的问题，就可能陷入一个两难的境地：一方面，应用存在严重的安全漏洞，无法满足用户的要求，并可能造成用户的隐私数据被攻击者窃取；另一方面，应用的基本架构已经确定，要修复安全漏洞，可能需要对系统的架构做出比较重大的调整，因而需要更多的开发时间，影响应用的发布进程。因此，从应用开发的第一天就应该把安全相关的因素考虑进来，并在整个应用的开发过程中。</p>
</blockquote>
<h2 id="Spring_Security_简介">Spring Security 简介</h2><p>Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。一般来说，Web 应用的安全性包括用户认证（Authentication）和用户授权（Authorization）两个部分。用户认证指的是验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。</p>
<p>对于上面提到的两种应用情景，Spring Security 框架都有很好的支持。在用户认证方面，Spring Security 框架支持主流的认证方式，包括 HTTP 基本认证、HTTP 表单验证、HTTP 摘要认证、OpenID 和 LDAP 等。在用户授权方面，Spring Security 提供了基于角色的访问控制和访问控制列表（Access Control List，ACL），可以对应用中的领域对象进行细粒度的控制。</p>
<blockquote>
<p>未完待续。。。。。。<br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-springsecurity/" target="_blank" rel="external">原文链接</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[安全一直是 Web 应用开发中非常重要的一个方面。从安全的角度来说，需要考虑用户认证和授权两个方面。为 Web 应用增加安全方面的能力并非一件简单的事情，需要考虑不同的认证和授权机制。Spring Security 为使用 Spring 框架的 Web 应用提供了良好的支持。本文将详细介绍如何使用 Spring Security 框架为 Web 应用提供安全支持。]]>
    
    </summary>
    
      <category term="spring" scheme="http://miclee.cn/tags/spring/"/>
    
      <category term="spring" scheme="http://miclee.cn/categories/spring/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[spring-boot哎哟不错(四) —— spring-boot-admin 使用介绍]]></title>
    <link href="http://miclee.cn/2015/11/28/spring-boot-4/"/>
    <id>http://miclee.cn/2015/11/28/spring-boot-4/</id>
    <published>2015-11-28T07:48:35.000Z</published>
    <updated>2015-12-22T07:52:40.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> spring-boot应用监控平台。spring-boot哎哟不错系列第四篇，哎哟不错系列只记录spring-boot使用过程中重要的部分。 </em></strong><br><a id="more"></a></p>
<hr>
<p>spring-boot应用监控平台使用方法简介：</p>
<h2 id="客户端">客户端</h2><ul>
<li>pom.xml增加以下依赖：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>配置文件增加属性：</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring<span class="class">.boot</span><span class="class">.admin</span><span class="class">.url</span>=http:<span class="comment">//localhost:8001</span></span><br></pre></td></tr></table></figure>
<p>如果为.yml格式，则如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">spring</span>:</span><br><span class="line">  <span class="attribute">boot</span>:</span><br><span class="line">    <span class="attribute">admin</span>:</span><br><span class="line">      <span class="attribute">url</span>: <span class="attribute">http</span>:<span class="comment">//localhost:8001</span></span><br></pre></td></tr></table></figure>
<h2 id="服务端">服务端</h2><ul>
<li>只提供服务</li>
</ul>
<p>pom.xml增加以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-admin-server<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-admin-server-ui<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>只需要增加 @EnableAdminServer 一个注解即可创建admin应用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Configuration</span></span><br><span class="line"><span class="annotation">@EnableAutoConfiguration</span></span><br><span class="line"><span class="annotation">@EnableAdminServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      SpringApplication.run(Application.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>服务端加客户端（注册自身）</li>
</ul>
<p>在上面配置之外，再增加属性配置：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring<span class="class">.boot</span><span class="class">.admin</span><span class="class">.url</span>=http:<span class="comment">//localhost:8001</span></span><br></pre></td></tr></table></figure>
<p>如果为.yml格式，则如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">spring</span>:</span><br><span class="line">  <span class="attribute">boot</span>:</span><br><span class="line">    <span class="attribute">admin</span>:</span><br><span class="line">      <span class="attribute">url</span>: <span class="attribute">http</span>:<span class="comment">//localhost:8001</span></span><br></pre></td></tr></table></figure>
<h2 id="客户端免配置模式">客户端免配置模式</h2><p>特别的，服务端增加spring-clouds注解 @EnableDiscoveryClient，并包含一个实现方式，(e.g. Eureka)，即可实现客户端免配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableAdminServer</span><br><span class="line">public class SpringBootAdminApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringBootAdminApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.0.3.RELEASE<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[spring-boot应用监控平台。spring-boot哎哟不错系列第四篇，哎哟不错系列只记录spring-boot使用过程中重要的部分。]]>
    
    </summary>
    
      <category term="spring" scheme="http://miclee.cn/categories/spring/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[免费编程书籍]]></title>
    <link href="http://miclee.cn/2015/11/25/free-programming-books/"/>
    <id>http://miclee.cn/2015/11/25/free-programming-books/</id>
    <published>2015-11-25T02:40:03.000Z</published>
    <updated>2015-12-17T06:11:02.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> 免费编程书籍 </em></strong><br><a id="more"></a></p>
<hr>
<h2 id="目录">目录</h2><ul>
<li><a href="#语言无关">语言无关</a><ul>
<li><a href="#在线教育">在线教育</a></li>
<li><a href="#软件开发方法">软件开发方法</a></li>
<li><a href="#操作系统">操作系统</a></li>
<li><a href="#版本控制">版本控制</a></li>
<li><a href="#数据库">数据库</a></li>
<li><a href="#正则表达式">正则表达式</a></li>
<li><a href="#智能系统">智能系统</a></li>
<li><a href="#分布式系统">分布式系统</a></li>
<li><a href="#编译原理">编译原理</a></li>
<li><a href="#函数式概念">函数式概念</a></li>
<li><a href="#计算机图形学">计算机图形学</a></li>
<li><a href="#web服务器">WEB服务器</a></li>
<li><a href="#编辑器">编辑器</a></li>
<li><a href="#nosql">NoSQL</a></li>
<li><a href="#postgresql">PostgreSQL</a></li>
<li><a href="#mysql">MySQL</a></li>
<li><a href="#管理和监控">管理和监控</a></li>
<li><a href="#项目相关">项目相关</a></li>
<li><a href="#设计模式">设计模式</a></li>
<li><a href="#web">Web</a></li>
<li><a href="#大数据">大数据</a></li>
<li><a href="#编程艺术">编程艺术</a></li>
<li><a href="#其它">其它</a></li>
</ul>
</li>
<li><a href="#语言相关">语言相关</a><ul>
<li><a href="#android">Android</a></li>
<li><a href="#awk">AWK</a></li>
<li><a href="#cc">C/C++</a></li>
<li><a href="#coffeescript">CoffeeScript</a></li>
<li><a href="#dart">Dart</a></li>
<li><a href="#elasticsearch">Elasticsearch</a></li>
<li><a href="#erlang">Erlang</a></li>
<li><a href="#fortran">Fortran</a></li>
<li><a href="#golang">Golang</a></li>
<li><a href="#haskell">Haskell</a></li>
<li><a href="#html--css">HTML / CSS</a></li>
<li><a href="#http">HTTP</a></li>
<li><a href="#ios">iOS</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#javascript">JavaScript</a></li>
<li><a href="#latex">LaTeX</a></li>
<li><a href="#lisp">LISP</a></li>
<li><a href="#lua">Lua</a></li>
<li><a href="#markdown">Markdown</a></li>
<li><a href="#nodejs">Node.js</a></li>
<li><a href="#perl">Perl</a></li>
<li><a href="#php">PHP</a></li>
<li><a href="#python">Python</a></li>
<li><a href="#r">R</a></li>
<li><a href="#restructuredtext">reStructuredText</a></li>
<li><a href="#ruby">Ruby</a></li>
<li><a href="#scala">Scala</a></li>
<li><a href="#scheme">Scheme</a></li>
<li><a href="#shell">Shell</a></li>
<li><a href="#swift">Swift</a></li>
<li><a href="#vim">Vim</a></li>
<li><a href="#visual-prolog">Visual Prolog</a></li>
</ul>
</li>
</ul>
<h2 id="语言无关">语言无关</h2><h3 id="在线教育">在线教育</h3><ul>
<li><a href="https://www.codeschool.com" target="_blank" rel="external">CodeSchool</a></li>
<li><a href="http://www.codecademy.com/?locale_code=zh" target="_blank" rel="external">Codecademy</a></li>
<li><a href="https://www.coursera.org/courses?orderby=upcoming&amp;lngs=zh" target="_blank" rel="external">Coursera</a></li>
<li><a href="http://learnxinyminutes.com" target="_blank" rel="external">Learn X in Y minutes</a> (数十种语言快速入门教程)</li>
<li><a href="https://www.shiyanlou.com" target="_blank" rel="external">shiyanlou</a></li>
<li><a href="http://teamtreehouse.com" target="_blank" rel="external">TeamTreeHouse</a></li>
<li><a href="https://www.udacity.com" target="_blank" rel="external">Udacity</a></li>
<li><a href="https://www.xuetangx.com" target="_blank" rel="external">xuetangX</a></li>
<li><a href="http://www.imooc.com/course/list" target="_blank" rel="external">慕课网</a> (丰富的移动端开发、php开发、web前端、html5教程以及css3视频教程等课程资源)</li>
<li><a href="http://www.jikexueyuan.com" target="_blank" rel="external">极客学院</a></li>
<li><a href="http://edu.51cto.com" target="_blank" rel="external">51CTO学院</a></li>
<li><a href="http://www.jisuanke.com" target="_blank" rel="external">计蒜客</a></li>
</ul>
<h3 id="软件开发方法">软件开发方法</h3><ul>
<li><a href="https://github.com/justinyhuang/Functional-Programming-For-The-Rest-of-Us-Cn" target="_blank" rel="external">傻瓜函数编程</a> (《Functional Programming For The Rest of Us》中文版)</li>
<li><a href="http://www.infoq.com/cn/minibooks/scrum-xp-from-the-trenches" target="_blank" rel="external">硝烟中的 Scrum 和 XP</a></li>
</ul>
<h3 id="操作系统">操作系统</h3><ul>
<li><a href="http://man.chinaunix.net/linux/debian/reference/reference.zh-cn.html" target="_blank" rel="external">Debian 参考手册 </a></li>
<li><a href="http://wiki.ubuntu.org.cn/UbuntuManual" target="_blank" rel="external">Ubuntu 参考手册 </a></li>
<li><a href="http://www.freebsd.org/doc/zh_CN.UTF-8/books/handbook/" target="_blank" rel="external">FreeBSD 使用手册</a></li>
<li><a href="http://happypeter.github.io/LGCB/book/" target="_blank" rel="external">Linux Guide for Complete Beginners</a></li>
<li><a href="http://cb.vu/unixtoolbox_zh_CN.xhtml" target="_blank" rel="external">UNIX TOOLBOX</a></li>
<li><a href="http://vbird.dic.ksu.edu.tw/linux_basic/linux_basic.php" target="_blank" rel="external">鸟哥的 Linux 私房菜 基础学习篇</a></li>
<li><a href="http://vbird.dic.ksu.edu.tw/linux_server/" target="_blank" rel="external">鸟哥的 Linux 私房菜 服务器架设篇</a></li>
<li><a href="http://i.linuxtoy.org/docs/guide/index.html" target="_blank" rel="external">开源世界旅行手册</a></li>
<li><a href="http://sourceforge.net/apps/trac/elpi/wiki/ALP" target="_blank" rel="external">Linux 系统高级编程</a></li>
<li><a href="http://billie66.github.io/TLCL/index.html" target="_blank" rel="external">The Linux Command Line</a> (中英文版)</li>
<li><a href="http://oss.org.cn/kernel-book/ldd3/index.html" target="_blank" rel="external">Linux 设备驱动</a> (第三版)</li>
<li><a href="http://www.kerneltravel.net/kernel-book/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81.html" target="_blank" rel="external">深入分析Linux内核源码</a></li>
<li><a href="http://works.jinbuguo.com/lfs/lfs62/index.html" target="_blank" rel="external">Linux 构建指南</a></li>
<li><a href="https://github.com/me115/linuxtools_rst" target="_blank" rel="external">Linux工具快速教程</a></li>
<li><a href="http://tinylab.gitbooks.io/linux-doc" target="_blank" rel="external">Linux Documentation (中文版)</a></li>
<li><a href="http://tinylab.gitbooks.io/elinux" target="_blank" rel="external">嵌入式 Linux 知识库 (eLinux.org 中文版)</a></li>
<li><a href="https://github.com/tobegit3hub/understand_linux_process" target="_blank" rel="external">理解Linux进程</a></li>
<li><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/" target="_blank" rel="external">Operating Systems: Three Easy Pieces</a></li>
<li><a href="https://www.gitbook.com/book/objectkuan/ucore-docs/details" target="_blank" rel="external">uCore Lab: Operating System Course in Tsinghua University</a></li>
<li><a href="https://github.com/widuu/chinese_docker" target="_blank" rel="external">Docker中文指南</a></li>
<li><a href="https://github.com/yeasy/docker_practice" target="_blank" rel="external">Docker —— 从入门到实践</a></li>
<li><a href="http://yuedu.baidu.com/ebook/d817967416fc700abb68fca1" target="_blank" rel="external">Docker入门实战</a></li>
<li><a href="http://freeradius.akagi201.org" target="_blank" rel="external">FreeRADIUS新手入门</a></li>
<li><a href="http://aaaaaashu.gitbooks.io/mac-dev-setup/content/" target="_blank" rel="external">Mac 开发配置手册</a></li>
<li><a href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md" target="_blank" rel="external">命令行的艺术</a></li>
</ul>
<h3 id="版本控制">版本控制</h3><ul>
<li><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="external">Git - 简易指南</a></li>
<li><a href="http://gitbook.liuhui998.com" target="_blank" rel="external">Git Community Book 中文版</a></li>
<li><a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/" target="_blank" rel="external">Git magic</a></li>
<li><a href="http://gitref.justjavac.com" target="_blank" rel="external">Git 参考手册</a></li>
<li><a href="https://github.com/gotgit/gotgithub" target="_blank" rel="external">Got GitHub</a></li>
<li><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="external">Pro Git</a></li>
<li><a href="https://www.gitbook.com/book/0532/progit/details" target="_blank" rel="external">Pro Git 中文版</a> (整理在gitbook上)</li>
<li><a href="http://pcottle.github.io/learnGitBranching/" target="_blank" rel="external">学习 Git 分支</a> (点击右下角按钮可切换至简体及正体中文)</li>
<li><a href="http://igit.linuxtoy.org/index.html" target="_blank" rel="external">沉浸式学 Git</a></li>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">Git教程</a> （本文由 <a href="http://weibo.com/liaoxuefeng" target="_blank" rel="external">@廖雪峰</a> 创作，如果觉得本教程对您有帮助，可以去 <a href="https://itunes.apple.com/cn/app/git-jiao-cheng/id876420437" target="_blank" rel="external">iTunes</a> 购买）</li>
<li><a href="http://backlogtool.com/git-guide/cn/" target="_blank" rel="external">猴子都能懂的GIT入门</a></li>
<li><a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/" target="_blank" rel="external">Git Magic</a></li>
<li><a href="http://www.worldhello.net/gotgithub/index.html" target="_blank" rel="external">GotGitHub</a></li>
<li><a href="http://mercurial.selenic.com/wiki/ChineseTutorial" target="_blank" rel="external">Mercurial 使用教程</a></li>
<li><a href="http://bucunzai.net/hginit/" target="_blank" rel="external">HgInit (中文版)</a></li>
<li><a href="https://github.com/flyhigher139/Git-Cheat-Sheet" target="_blank" rel="external">Git-Cheat-Sheet</a> （感谢 @flyhigher139 翻译了中文版）</li>
<li><a href="http://snowdream86.gitbooks.io/github-cheat-sheet/content/zh/index.html" target="_blank" rel="external">GitHub秘籍</a></li>
<li><a href="https://github.com/waylau/github-help" target="_blank" rel="external">Github帮助文档</a></li>
<li><a href="http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html" target="_blank" rel="external">git-flow 备忘清单</a></li>
<li><a href="http://svnbook.red-bean.com/nightly/zh/index.html" target="_blank" rel="external">svn 手册</a></li>
</ul>
<h3 id="数据库">数据库</h3><ul>
<li><a href="http://www.redisbook.com" target="_blank" rel="external">Redis 设计与实现</a></li>
<li><a href="https://github.com/justinyhuang/the-little-mongodb-book-cn" target="_blank" rel="external">The Little MongoDB Book 中文版</a></li>
</ul>
<h3 id="正则表达式">正则表达式</h3><ul>
<li><a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="external">正则表达式30分钟入门教程</a></li>
</ul>
<h3 id="智能系统">智能系统</h3><ul>
<li><a href="https://github.com/gmszone/designiot" target="_blank" rel="external">一步步搭建物联网系统</a></li>
</ul>
<h3 id="分布式系统">分布式系统</h3><ul>
<li><a href="http://dcaoyuan.github.io/papers/pdfs/Scalability.pdf" target="_blank" rel="external">走向分布式</a> (PDF)</li>
</ul>
<h3 id="编译原理">编译原理</h3><ul>
<li><a href="https://github.com/DeathKing/Learning-SICP" target="_blank" rel="external">《计算机程序的结构和解释》公开课 翻译项目</a></li>
</ul>
<h3 id="函数式概念">函数式概念</h3><ul>
<li><a href="https://github.com/justinyhuang/Functional-Programming-For-The-Rest-of-Us-Cn" target="_blank" rel="external">傻瓜函数编程</a></li>
</ul>
<h3 id="计算机图形学">计算机图形学</h3><ul>
<li><a href="https://github.com/zilongshanren/opengl-tutorials" target="_blank" rel="external">OpenGL 教程</a></li>
</ul>
<h3 id="WEB服务器">WEB服务器</h3><ul>
<li><a href="http://tengine.taobao.org/book/index.html" target="_blank" rel="external">Nginx开发从入门到精通</a> (淘宝团队出品)</li>
<li><a href="http://www.ttlsa.com/nginx/nginx-stu-pdf/" target="_blank" rel="external">Nginx教程从入门到精通</a> (PDF版本，运维生存时间出品)</li>
<li><a href="http://works.jinbuguo.com/apache/menu22/index.html" target="_blank" rel="external">Apache 中文手册</a></li>
</ul>
<h3 id="编辑器">编辑器</h3><ul>
<li><a href="http://exvim.github.io/docs-zh/intro/" target="_blank" rel="external">exvim–vim 改良成IDE项目</a></li>
<li><a href="http://learnvimscriptthehardway.onefloweroneworld.com" target="_blank" rel="external">笨方法学Vimscript 中译本</a></li>
<li><a href="https://github.com/vimcn/vimcdoc" target="_blank" rel="external">Vim中文文档</a></li>
<li><a href="https://github.com/yangyangwithgnu/use_vim_as_ide" target="_blank" rel="external">所需即所获：像 IDE 一样使用 vim</a></li>
<li><a href="https://github.com/aqua7regia/tmux-Productive-Mouse-Free-Development_zh" target="_blank" rel="external">tmux:高效的全键盘开发工具</a></li>
</ul>
<h3 id="NoSQL">NoSQL</h3><ul>
<li><a href="http://www.yankay.com/wp-content/NoSql_Database_Note.html" target="_blank" rel="external">NoSQL数据库笔谈</a> (<a href="http://yankaycom-wordpress.stor.sinaapp.com/uploads/2012/12/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%B0%88v2.pdf" target="_blank" rel="external">PDF</a>)</li>
<li><a href="http://redisbook.com" target="_blank" rel="external">Redis 设计与实现</a></li>
<li><a href="http://www.redisdoc.com" target="_blank" rel="external">Redis 命令参考</a></li>
<li><a href="https://github.com/huangz1990/redis-3.0-annotated" target="_blank" rel="external">带有详细注释的 Redis 3.0 代码</a></li>
<li><a href="https://github.com/huangz1990/annotated_redis_source" target="_blank" rel="external">带有详细注释的 Redis 2.6 代码</a></li>
<li><a href="https://github.com/justinyhuang/the-little-mongodb-book-cn/blob/master/mongodb.md" target="_blank" rel="external">The Little MongoDB Book</a></li>
<li><a href="https://github.com/JasonLai256/the-little-redis-book/blob/master/cn/redis.md" target="_blank" rel="external">The Little Redis Book</a></li>
<li><a href="http://docs.neo4j.org.cn" target="_blank" rel="external">Neo4j 简体中文手册 v1.8</a></li>
<li><a href="http://neo4j.tw" target="_blank" rel="external">Neo4j .rb 中文資源</a></li>
<li><a href="http://disquebook.com" target="_blank" rel="external">Disque 使用教程</a></li>
</ul>
<h3 id="PostgreSQL">PostgreSQL</h3><ul>
<li><a href="http://works.jinbuguo.com/postgresql/menu823/index.html" target="_blank" rel="external">PostgreSQL 8.2.3 中文文档</a></li>
<li><a href="http://www.postgres.cn/docs/9.3/index.html" target="_blank" rel="external">PostgreSQL 9.3.1 中文文档</a></li>
</ul>
<h3 id="MySQL">MySQL</h3><ul>
<li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="external">MySQL索引背后的数据结构及算法原理</a></li>
<li><a href="http://www.cnblogs.com/mr-wid/archive/2013/05/09/3068229.html" target="_blank" rel="external">21分钟MySQL入门教程</a></li>
</ul>
<h3 id="管理和监控">管理和监控</h3><ul>
<li><a href="http://kibana.logstash.es" target="_blank" rel="external">ELKstack 中文指南</a></li>
<li><a href="http://udn.yyuap.com/doc/mastering-elasticsearch/" target="_blank" rel="external">Mastering Elasticsearch(中文版)</a></li>
<li><a href="https://www.gitbook.com/book/fuxiaopang/learnelasticsearch/details" target="_blank" rel="external">ElasticSearch 权威指南</a></li>
<li><a href="http://es.xiaoleilu.com" target="_blank" rel="external">Elasticsearch 权威指南（中文版）</a></li>
<li><a href="https://github.com/chenryn/logstash-best-practice-cn" target="_blank" rel="external">Logstash 最佳实践</a></li>
<li><a href="http://bbs.konotes.org/workdoc/puppet-27/" target="_blank" rel="external">Puppet 2.7 Cookbook 中文版</a></li>
</ul>
<h3 id="项目相关">项目相关</h3><ul>
<li><a href="http://article.yeeyan.org/view/2251/94882" target="_blank" rel="external">持续集成（第二版）</a> (译言网)</li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-ap/" target="_blank" rel="external">让开发自动化系列专栏</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-cq/" target="_blank" rel="external">追求代码质量</a></li>
<li><a href="https://github.com/fool2fish/selenium-doc" target="_blank" rel="external">selenium 中文文档</a></li>
<li><a href="http://local.joelonsoftware.com/wiki/Chinese_(Simplified" target="_blank" rel="external">Joel谈软件</a>)</li>
<li><a href="http://local.joelonsoftware.com/wiki/%E9%A6%96%E9%A0%81" target="_blank" rel="external">約耳談軟體(Joel on Software)</a></li>
<li><a href="https://github.com/waylau/Gradle-2-User-Guide" target="_blank" rel="external">Gradle 2 用户指南</a></li>
<li><a href="http://yuedu.baidu.com/ebook/f23af265998fcc22bcd10da2" target="_blank" rel="external">Gradle 中文使用文档</a></li>
<li><a href="https://github.com/ecomfe/spec" target="_blank" rel="external">编码规范</a></li>
<li><a href="http://www.ituring.com.cn/book/1143" target="_blank" rel="external">开源软件架构</a></li>
<li><a href="http://docs.huihoo.com/gnu/linux/gmake.html" target="_blank" rel="external">GNU make 指南</a></li>
</ul>
<h3 id="设计模式">设计模式</h3><ul>
<li><a href="https://github.com/me115/design_patterns" target="_blank" rel="external">图说设计模式</a></li>
<li><a href="http://blog.csdn.net/lovelion/article/details/17517213" target="_blank" rel="external">史上最全设计模式导学目录</a></li>
</ul>
<h3 id="Web">Web</h3><ul>
<li><a href="http://www.20thingsilearned.com/zh-CN/home" target="_blank" rel="external">关于浏览器和网络的 20 项须知</a></li>
<li><a href="http://jinlong.github.io/2013/08/29/devtoolsecrets/" target="_blank" rel="external">浏览器开发工具的秘密</a></li>
<li><a href="https://github.com/CN-Chrome-DevTools/CN-Chrome-DevTools" target="_blank" rel="external">Chrome 开发者工具中文手册</a></li>
<li><a href="http://open.chrome.360.cn/extension_dev/overview.html" target="_blank" rel="external">Chrome扩展开发文档</a></li>
<li><a href="http://www.gruntjs.net" target="_blank" rel="external">Grunt中文文档</a></li>
<li><a href="http://www.gulpjs.com.cn/docs/" target="_blank" rel="external">gulp中文文档</a></li>
<li><a href="https://github.com/nimojs/gulp-book" target="_blank" rel="external">Gulp 入门指南</a></li>
<li><a href="http://yeomanjs.org" target="_blank" rel="external">Yeoman中文文档</a></li>
<li><a href="https://github.com/AlloyTeam/Mars" target="_blank" rel="external">移动Web前端知识库</a></li>
<li><a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="external">正则表达式30分钟入门教程</a></li>
<li><a href="https://github.com/fouber/blog/issues/2" target="_blank" rel="external">前端开发体系建设日记</a></li>
<li><a href="https://github.com/hoosin/mobile-web-favorites" target="_blank" rel="external">移动前端开发收藏夹</a></li>
<li><a href="https://github.com/darcyliu/google-styleguide/blob/master/JSONStyleGuide.md" target="_blank" rel="external">JSON风格指南</a></li>
<li><a href="https://github.com/bolasblack/http-api-guide" target="_blank" rel="external">HTTP 接口设计指北</a></li>
<li><a href="https://github.com/hacke2/hacke2.github.io/issues/1" target="_blank" rel="external">前端资源分享（一）</a></li>
<li><a href="https://github.com/hacke2/hacke2.github.io/issues/3" target="_blank" rel="external">前端资源分享（二）</a></li>
<li><a href="http://coderlmn.github.io/code-standards/" target="_blank" rel="external">前端代码规范 及 最佳实践</a></li>
<li><a href="http://man.lupaworld.com/content/network/wireshark/index.html" target="_blank" rel="external">Wireshark用户手册</a></li>
<li><a href="https://community.emc.com/thread/194901" target="_blank" rel="external">一站式学习Wireshark</a></li>
<li><a href="http://happypeter.github.io/tealeaf-http/" target="_blank" rel="external">HTTP 下午茶</a></li>
<li><a href="http://yuedu.baidu.com/ebook/478d1a62376baf1ffc4fad99?pn=1" target="_blank" rel="external">HTTP/2.0 中文翻译</a></li>
<li><a href="https://www.gitbook.com/book/ye11ow/http2-explained/details" target="_blank" rel="external">http2讲解</a></li>
<li><a href="https://www.gitbook.com/book/juntao/3-web-designs-in-3-weeks/details" target="_blank" rel="external">3 Web Designs in 3 Weeks</a></li>
</ul>
<h3 id="大数据">大数据</h3><ul>
<li><a href="https://github.com/Flowerowl/Big-Data-Resources" target="_blank" rel="external">大数据/数据挖掘/推荐系统/机器学习相关资源</a></li>
<li><a href="https://github.com/jizhang/guidetodatamining" target="_blank" rel="external">面向程序员的数据挖掘指南</a></li>
<li><a href="https://code.csdn.net/CODE_Translation/spark_matei_phd" target="_blank" rel="external">大型集群上的快速和通用数据处理架构</a></li>
<li><a href="https://github.com/linyiqun/DataMiningAlgorithm" target="_blank" rel="external">数据挖掘中经典的算法实现和详细的注释</a></li>
<li><a href="https://aiyanbo.gitbooks.io/spark-programming-guide-zh-cn/content/" target="_blank" rel="external">Spark 编程指南简体中文版</a></li>
</ul>
<h3 id="编程艺术">编程艺术</h3><ul>
<li><a href="http://huyuefeng.me/intro-to-prog/" target="_blank" rel="external">编程入门指南</a></li>
<li><a href="https://github.com/julycoding/The-Art-Of-Programming-by-July" target="_blank" rel="external">程序员编程艺术</a></li>
<li><a href="http://www.oschina.net/translate/what-every-programmer-should-know-about-memory-part1?print" target="_blank" rel="external">每个程序员都应该了解的内存知识(译)</a>【第一部分】</li>
<li><a href="http://read.douban.com/ebook/4972883/" target="_blank" rel="external">取悦的工序：如何理解游戏</a> (豆瓣阅读，免费书籍)</li>
<li><a href="http://xiaobeicn.gitbooks.io/programming-skills-summary/" target="_blank" rel="external">编程技巧总汇</a></li>
</ul>
<h3 id="其它">其它</h3><ul>
<li><a href="http://softwaredownload.gitbooks.io/openwrt-fanqiang/" target="_blank" rel="external">OpenWrt智能、自动、透明翻墙路由器教程</a></li>
<li><a href="https://community.emc.com/docs/DOC-16067" target="_blank" rel="external">SAN 管理入门系列</a></li>
<li><a href="http://sketchcn.com/sketch-chinese-user-manual.html#introduce" target="_blank" rel="external">Sketch 中文手册</a></li>
<li><a href="http://ifeve.com/perfbook/" target="_blank" rel="external">深入理解并行编程</a></li>
</ul>
<h2 id="语言相关">语言相关</h2><h3 id="Android">Android</h3><ul>
<li><a href="http://www.apkbus.com/design/index.html" target="_blank" rel="external">Android Design(中文版)</a></li>
<li>Google Material Design 正體中文版 (<a href="http://wcc723.gitbooks.io/google_design_translate/content/style-icons.html" target="_blank" rel="external">译本一</a> <a href="https://github.com/1sters/material_design_zh" target="_blank" rel="external">译本二</a>)</li>
<li><a href="http://wiki.jikexueyuan.com/project/material-design/" target="_blank" rel="external">Material Design 中文版</a></li>
<li><a href="http://hukai.me/android-training-course-in-chinese/index.html" target="_blank" rel="external">Google Android官方培训课程中文版</a></li>
<li><a href="http://stormzhang.github.io/android/2014/07/07/learn-android-from-rookie/" target="_blank" rel="external">Android学习之路</a></li>
<li><a href="https://github.com/bboyfeiyu/android-tech-frontier" target="_blank" rel="external">Android开发技术前线(android-tech-frontier)</a></li>
<li><a href="https://github.com/FX-Max/Point-of-Android" target="_blank" rel="external">Point-of-Android</a> Android 一些重要知识点解析整理</li>
<li><a href="http://leanote.com/blog/post/561658f938f41126b2000298?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="external">Android6.0新特性详解</a></li>
</ul>
<h3 id="AWK">AWK</h3><ul>
<li><a href="https://github.com/wuzhouhui/awk" target="_blank" rel="external">awk程序设计语言</a></li>
<li><a href="http://awk.readthedocs.org/en/latest/index.html" target="_blank" rel="external">awk中文指南</a></li>
</ul>
<h3 id="C">C</h3><ul>
<li><a href="http://c-faq-chn.sourceforge.net/ccfaq/ccfaq.html" target="_blank" rel="external">C 语言常见问题集</a></li>
<li><a href="http://doc.lellansin.com" target="_blank" rel="external">C/C++ 学习教程</a></li>
<li><a href="https://github.com/limingth/NCCL" target="_blank" rel="external">新概念 C 语言教程</a></li>
<li><a href="http://docs.linuxtone.org/ebooks/C&amp;CPP/c/" target="_blank" rel="external">Linux C 编程一站式学习</a></li>
</ul>
<h3 id="C++">C++</h3><ul>
<li><a href="https://github.com/wuye9036/CppTemplateTutorial" target="_blank" rel="external">C++ Template 进阶指南</a></li>
<li><a href="http://www.prglab.com/cms/" target="_blank" rel="external">C++ 基础教程</a></li>
<li><a href="https://github.com/forhappy/A-Detailed-Cplusplus-Concurrency-Tutorial" target="_blank" rel="external">C++ 并发编程指南</a></li>
<li><a href="http://www.ituring.com.cn/book/1203" target="_blank" rel="external">像计算机科学家一样思考（C++版)</a> (《How To Think Like a Computer Scientist: C++ Version》中文版)</li>
<li><a href="http://tinylab.gitbooks.io/cbook" target="_blank" rel="external">C 语言编程透视</a></li>
<li><a href="https://github.com/leeyiw/cgdb-manual-in-chinese" target="_blank" rel="external">CGDB中文手册</a></li>
<li><a href="https://github.com/hellogcc/100-gdb-tips/blob/master/src/index.md" target="_blank" rel="external">100个gdb小技巧</a></li>
<li><a href="https://github.com/hellogcc/100-gcc-tips/blob/master/src/index.md" target="_blank" rel="external">100个gcc小技巧</a></li>
<li><a href="https://github.com/anjuke/zguide-cn" target="_blank" rel="external">ZMQ 指南</a></li>
<li><a href="http://scc.qibebt.cas.cn/docs/linux/base/%B8%FA%CE%D2%D2%BB%C6%F0%D0%B4Makefile-%B3%C2%F0%A9.pdf" target="_blank" rel="external">跟我一起写Makefile(PDF)</a> (PDF)</li>
<li><a href="http://docs.huihoo.com/gnu/linux/gmake.html" target="_blank" rel="external">GNU make 指南</a></li>
<li><a href="http://zh-google-styleguide.readthedocs.org/en/latest/google-cpp-styleguide/contents/" target="_blank" rel="external">Google C++ 风格指南</a></li>
<li><a href="https://github.com/andycai/cprimer" target="_blank" rel="external">C/C++ Primer</a> (by @andycai)</li>
<li><a href="http://www.nowamagic.net/librarys/books/contents/c" target="_blank" rel="external">简单易懂的C魔法</a></li>
<li><a href="http://sewm.pku.edu.cn/src/paradise/reference/CMake%20Practice.pdf" target="_blank" rel="external">Cmake 实践</a> (PDF版)</li>
<li><a href="http://www.sunistudio.com/cppfaq/" target="_blank" rel="external">C++ FAQ LITE(中文版)</a></li>
<li><a href="https://github.com/Mooophy/Cpp-Primer" target="_blank" rel="external">C++ Primer 5th Answers</a></li>
<li><a href="http://chenxiaowei.gitbooks.io/cpp_concurrency_in_action/" target="_blank" rel="external">C++ 并发编程(基于C++11)</a></li>
<li><a href="http://www.kuqin.com/qtdocument/tutorial.html" target="_blank" rel="external">QT 教程</a></li>
</ul>
<h3 id="CoffeeScript">CoffeeScript</h3><ul>
<li><a href="http://coffee-script.org" target="_blank" rel="external">CoffeeScript 中文</a></li>
<li><a href="https://github.com/elrrrrrrr/coffeescript-style-guide/blob/master/README-ZH.md" target="_blank" rel="external">CoffeeScript 编程风格指南</a></li>
</ul>
<h3 id="Dart">Dart</h3><ul>
<li><a href="http://dart.lidian.info/wiki/Language_Tour" target="_blank" rel="external">Dart 语言导览</a></li>
</ul>
<h3 id="Elasticsearch">Elasticsearch</h3><ul>
<li><a href="https://github.com/looly/elasticsearch-definitive-guide-cn" target="_blank" rel="external">Elasticsearch 权威指南</a> （《Elasticsearch the definitive guide》中文版）</li>
<li><a href="http://kibana.logstash.es" target="_blank" rel="external">ELKstack 中文指南</a></li>
<li><a href="http://udn.yyuap.com/doc/mastering-elasticsearch/" target="_blank" rel="external">Mastering Elasticsearch(中文版)</a></li>
</ul>
<h3 id="Erlang">Erlang</h3><ul>
<li><a href="https://github.com/liancheng/cpie-cn" target="_blank" rel="external">Erlang 并发编程</a> (《Concurrent Programming in Erlang (Part I)》中文版)</li>
</ul>
<h3 id="Fortran">Fortran</h3><ul>
<li><a href="http://micro.ustc.edu.cn/Fortran/ZJDing/" target="_blank" rel="external">Fortran77和90/95编程入门</a></li>
</ul>
<h3 id="Golang">Golang</h3><ul>
<li><a href="https://github.com/astaxie/build-web-application-with-golang" target="_blank" rel="external">Go Web 编程</a></li>
<li><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN" target="_blank" rel="external">Go 入门指南</a> (《The Way to Go》中文版)</li>
<li><a href="http://go-tour-zh.appsp0t.com" target="_blank" rel="external">Go 指南</a> (《A Tour of Go》中文版)</li>
<li><a href="https://github.com/Unknwon/go-fundamental-programming" target="_blank" rel="external">Go 编程基础</a></li>
<li><a href="http://mikespook.com/learning-go/" target="_blank" rel="external">学习Go语言</a></li>
<li><a href="https://github.com/astaxie/Go-in-Action" target="_blank" rel="external">Go实战开发</a> (当我收录此项目时，作者已经写完第三章，如果读完前面章节觉得有帮助，可以给作者<a href="https://me.alipay.com/astaxie" target="_blank" rel="external">捐赠</a>，以鼓励作者的继续创作)</li>
<li><a href="https://github.com/astaxie/NPWG_zh" target="_blank" rel="external">Network programming with Go 中文翻译版本</a></li>
<li><a href="http://www.hellogcc.org/effective_go.html" target="_blank" rel="external">Effective Go</a></li>
<li><a href="https://github.com/polaris1119/The-Golang-Standard-Library-by-Example" target="_blank" rel="external">Go 语言标准库</a></li>
<li><a href="http://gorevel.cn/docs/manual/index.html" target="_blank" rel="external">Revel 框架手册</a></li>
<li><a href="http://blog.csdn.net/dc_726/article/details/46565241" target="_blank" rel="external">Java程序员的Golang入门指南</a></li>
<li><a href="https://github.com/hyper-carrot/go_command_tutorial" target="_blank" rel="external">Go命令教程</a></li>
<li><a href="https://github.com/achun/Go-Blog-In-Action" target="_blank" rel="external">Go语言博客实践</a></li>
<li><a href="https://github.com/golang-china/golangdoc.translations" target="_blank" rel="external">Go 官方文档翻译</a></li>
</ul>
<h3 id="Groovy">Groovy</h3><ul>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-pg/" target="_blank" rel="external">实战 Groovy 系列</a></li>
</ul>
<h3 id="Haskell">Haskell</h3><ul>
<li><a href="http://learnyouahaskell-zh-tw.csie.org" target="_blank" rel="external">Haskell 趣学指南</a></li>
<li><a href="http://rwh.readthedocs.org/en/latest/" target="_blank" rel="external">Real World Haskell 中文版</a></li>
</ul>
<h3 id="HTML_/_CSS">HTML / CSS</h3><ul>
<li><a href="http://zh.learnlayout.com" target="_blank" rel="external">学习CSS布局</a></li>
<li><a href="https://github.com/chadluo/CSS-Guidelines/blob/master/README.md" target="_blank" rel="external">通用 CSS 笔记、建议与指导</a></li>
<li><a href="http://css.doyoe.com" target="_blank" rel="external">CSS参考手册</a></li>
<li><a href="https://github.com/waylau/css3-tutorial" target="_blank" rel="external">CSS3 Tutorial 《CSS3 教程》</a></li>
<li><a href="http://yanxyz.github.io/emmet-docs/" target="_blank" rel="external">Emmet 文档</a></li>
<li><a href="http://alloyteam.github.io/CodeGuide/" target="_blank" rel="external">前端代码规范</a> (腾讯 AlloyTeam 团队)</li>
<li><a href="http://codeguide.bootcss.com" target="_blank" rel="external">HTML和CSS编码规范</a></li>
<li><a href="http://www.w3school.com.cn/html5/" target="_blank" rel="external">HTML5 教程</a></li>
<li><a href="http://sass-guidelin.es/zh/" target="_blank" rel="external">Sass Guidelines 中文</a></li>
</ul>
<h3 id="HTTP">HTTP</h3><ul>
<li><a href="http://happypeter.github.io/tealeaf-http" target="_blank" rel="external">HTTP 下午茶</a></li>
</ul>
<h3 id="iOS">iOS</h3><ul>
<li><a href="https://github.com/qinjx/30min_guides/blob/master/ios.md" target="_blank" rel="external">iOS开发60分钟入门</a></li>
<li><a href="http://isux.tencent.com/ios-human-interface-guidelines-ui-design-basics-ios7.html" target="_blank" rel="external">iOS7人机界面指南</a></li>
<li><a href="http://zh-google-styleguide.readthedocs.org/en/latest/google-objc-styleguide/" target="_blank" rel="external">Google Objective-C Style Guide 中文版</a></li>
<li><a href="http://wileam.com/iphone-6-screen-cn/" target="_blank" rel="external">iPhone 6 屏幕揭秘</a></li>
<li><a href="http://nilsun.github.io/apple-watch/" target="_blank" rel="external">Apple Watch开发初探</a></li>
<li><a href="https://developer.apple.com/library/ios/referencelibrary/GettingStarted/RoadMapiOSCh/index.html" target="_blank" rel="external">马上着手开发 iOS 应用程序</a></li>
<li><a href="https://github.com/jkyin/Subtitle" target="_blank" rel="external">网易斯坦福大学公开课：iOS 7应用开发字幕文件</a></li>
</ul>
<h3 id="Java">Java</h3><ul>
<li><a href="https://github.com/waylau/apache-shiro-1.2.x-reference" target="_blank" rel="external">Apache Shiro 用户指南</a></li>
<li><a href="https://github.com/waylau/Jersey-2.x-User-Guide" target="_blank" rel="external">Jersey 2.x 用户指南</a></li>
<li><a href="https://github.com/waylau/spring-framework-4-reference" target="_blank" rel="external">Spring Framework 4.x参考文档</a></li>
<li><a href="https://github.com/qibaoguang/Spring-Boot-Reference-Guide" target="_blank" rel="external">Spring Boot参考指南</a> (翻译中)</li>
<li><a href="http://mybatis.github.io/mybatis-3/zh/index.html" target="_blank" rel="external">MyBatis中文文档</a></li>
<li><a href="https://github.com/waylau/RestDemo" target="_blank" rel="external">用jersey构建REST服务</a></li>
<li><a href="https://github.com/waylau/activiti-5.x-user-guide" target="_blank" rel="external">Activiti 5.x 用户指南</a></li>
<li><a href="http://www.hawstein.com/posts/google-java-style.html" target="_blank" rel="external">Google Java编程风格指南</a></li>
<li><a href="https://github.com/waylau/netty-4-user-guide" target="_blank" rel="external">Netty 4.x 用户指南</a></li>
<li><a href="https://github.com/waylau/essential-netty-in-action" target="_blank" rel="external">Netty 实战(精髓)</a></li>
<li><a href="https://github.com/waylau/rest-in-action" target="_blank" rel="external">REST 实战</a></li>
<li><a href="https://github.com/waylau/java-code-conventions" target="_blank" rel="external">Java 编码规范</a></li>
<li><a href="https://github.com/waylau/apache-mina-2.x-user-guide" target="_blank" rel="external">Apache MINA 2 用户指南</a></li>
<li><a href="https://github.com/waylau/h2-database-doc" target="_blank" rel="external">H2 Database 教程</a></li>
<li><a href="https://github.com/waylau/servlet-3.1-specification" target="_blank" rel="external">Java Servlet 3.1 规范</a></li>
<li><a href="https://github.com/waylau/jsse-reference-guide" target="_blank" rel="external">JSSE 参考指南</a></li>
</ul>
<h3 id="Javascript">Javascript</h3><ul>
<li><a href="http://typeof.net/s/jsmech/" target="_blank" rel="external">Javascript 原理</a></li>
<li><a href="http://bq69.com/blog/articles/script/868/google-javascript-style-guide.html" target="_blank" rel="external">Google JavaScript 代码风格指南</a></li>
<li><a href="https://github.com/darcyliu/google-styleguide/blob/master/JSONStyleGuide.md" target="_blank" rel="external">Google JSON 风格指南</a></li>
<li><a href="https://github.com/adamlu/javascript-style-guide" target="_blank" rel="external">Airbnb JavaScript 规范</a></li>
<li><a href="http://javascript.ruanyifeng.com" target="_blank" rel="external">JavaScript 标准参考教程（alpha）</a></li>
<li><a href="http://pij.robinqu.me" target="_blank" rel="external">Javascript编程指南</a> (<a href="https://github.com/RobinQu/Programing-In-Javascript" target="_blank" rel="external">源码</a>)</li>
<li><a href="https://github.com/justjavac/12-javascript-quirks" target="_blank" rel="external">javascript 的 12 个怪癖</a></li>
<li><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/" target="_blank" rel="external">JavaScript 秘密花园</a></li>
<li><a href="http://icodeit.org/jsccp/" target="_blank" rel="external">JavaScript核心概念及实践</a> (PDF) (此书已由人民邮电出版社出版发行，但作者依然免费提供PDF版本，希望开发者们去购买，支持作者)</li>
<li><a href="https://github.com/jayli/javascript-patterns" target="_blank" rel="external">《JavaScript 模式》</a> “JavaScript patterns”中译本</li>
<li><a href="http://justjavac.com/named-function-expressions-demystified.html" target="_blank" rel="external">命名函数表达式探秘</a>  (注:原文由<a href="http://www.cn-cuckoo.com" target="_blank" rel="external">为之漫笔</a>翻译，原始地址无法打开，所以此处地址为我博客上的备份)</li>
<li><a href="http://www.oschina.net/translate/learning-javascript-design-patterns" target="_blank" rel="external">学用 JavaScript 设计模式</a> (开源中国)</li>
<li><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="external">深入理解JavaScript系列</a></li>
<li><a href="http://es6.ruanyifeng.com" target="_blank" rel="external">ECMAScript 6 入门</a> (作者：阮一峰)</li>
<li><a href="http://liubin.github.io/promises-book/" target="_blank" rel="external">JavaScript Promise迷你书</a></li>
<li><a href="https://github.com/getify/You-Dont-Know-JS" target="_blank" rel="external">You-Dont-Know-JS</a> (深入JavaScript语言核心机制的系列图书)</li>
<li>jQuery<ul>
<li><a href="http://www.nowamagic.net/librarys/books/contents/jquery" target="_blank" rel="external">简单易懂的JQuery魔法</a></li>
<li><a href="http://i5ting.github.io/How-to-write-jQuery-plugin/build/jquery.plugin.html" target="_blank" rel="external">How to write jQuery plugin</a></li>
</ul>
</li>
<li>Node.js<ul>
<li><a href="http://www.nodebeginner.org/index-zh-cn.html" target="_blank" rel="external">Node入门</a></li>
<li><a href="http://nqdeng.github.io/7-days-nodejs/" target="_blank" rel="external">七天学会NodeJS</a></li>
<li><a href="https://github.com/nodejs-tw/nodejs-wiki-book" target="_blank" rel="external">Nodejs Wiki Book</a> (繁体中文)</li>
<li><a href="http://expressjs.jser.us" target="_blank" rel="external">express.js 中文文档</a></li>
<li><a href="https://github.com/turingou/koa-guide" target="_blank" rel="external">koa 中文文档</a></li>
<li><a href="https://github.com/nswbmw/N-blog" target="_blank" rel="external">使用 Express + MongoDB 搭建多人博客</a></li>
<li><a href="http://javascript.ruanyifeng.com/nodejs/express.html" target="_blank" rel="external">Express框架</a></li>
<li><a href="https://github.com/alsotang/node-lessons" target="_blank" rel="external">Node.js 包教不包会</a></li>
<li><a href="https://www.npmjs.org/package/learnyounode-zh-cn" target="_blank" rel="external">Learn You The Node.js For Much Win! (中文版)</a></li>
<li><a href="http://i5ting.github.io/node-debug-tutorial/" target="_blank" rel="external">Node debug 三法三例</a></li>
<li><a href="https://www.gitbook.com/book/0532/nodejs/details" target="_blank" rel="external">nodejs中文文档</a></li>
</ul>
</li>
<li>underscore.js<ul>
<li><a href="http://learningcn.com/underscore/" target="_blank" rel="external">Underscore.js中文文档</a></li>
</ul>
</li>
<li>backbone.js<ul>
<li><a href="http://www.css88.com/doc/backbone/" target="_blank" rel="external">backbone.js中文文档</a></li>
<li><a href="http://www.the5fire.com/backbone-js-tutorials-pdf-download.html" target="_blank" rel="external">backbone.js入门教程</a> (PDF)</li>
<li><a href="https://github.com/the5fire/backbonejs-learning-note" target="_blank" rel="external">Backbone.js入门教程第二版</a></li>
<li><a href="http://feliving.github.io/developing-backbone-applications" target="_blank" rel="external">Developing Backbone.js Applications(中文版)</a></li>
</ul>
</li>
<li>AngularJS<ul>
<li><a href="https://github.com/mgechev/angularjs-style-guide/blob/master/README-zh-cn.md" target="_blank" rel="external">AngularJS最佳实践和风格指南</a></li>
<li><a href="https://github.com/peiransun/angularjs-cn" target="_blank" rel="external">AngularJS中译本</a></li>
<li><a href="https://github.com/zensh/AngularjsTutorial_cn" target="_blank" rel="external">AngularJS入门教程</a></li>
<li><a href="https://github.com/xufei/Make-Your-Own-AngularJS/blob/master/01.md" target="_blank" rel="external">构建自己的AngularJS</a></li>
<li><a href="http://www.waylau.com/build-angularjs-app-with-yeoman-in-windows/" target="_blank" rel="external">在Windows环境下用Yeoman构建AngularJS项目</a></li>
</ul>
</li>
<li>Zepto.js<ul>
<li><a href="http://mweb.baidu.com/zeptoapi/" target="_blank" rel="external">Zepto.js 中文文档</a></li>
</ul>
</li>
<li>React.js<ul>
<li><a href="http://reactjs.cn" target="_blank" rel="external">React.js 中文文档</a></li>
<li><a href="https://github.com/fakefish/react-webpack-cookbook" target="_blank" rel="external">React webpack-cookbook</a></li>
<li><a href="http://fraserxu.me/intro-to-react/" target="_blank" rel="external">React 入门教程</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/react-native/" target="_blank" rel="external">React Native 中文文档(含最新Android内容)</a></li>
</ul>
</li>
<li>impress.js<ul>
<li><a href="https://github.com/kokdemo/impress.js-tutorial-in-Chinese" target="_blank" rel="external">impress.js的中文教程</a></li>
</ul>
</li>
<li>CoffeeScript<ul>
<li><a href="https://github.com/geekplux/coffeescript-style-guide" target="_blank" rel="external">CoffeeScript 编码风格指南</a></li>
</ul>
</li>
<li>ExtJS<ul>
<li><a href="http://extjs-doc-cn.github.io/ext4api/" target="_blank" rel="external">Ext4.1.0 中文文档</a></li>
</ul>
</li>
<li>Meteor<ul>
<li><a href="http://zh.discovermeteor.com" target="_blank" rel="external">Discover Meteor</a></li>
</ul>
</li>
<li>D3.js<ul>
<li><a href="https://github.com/mbostock/d3/wiki/API--%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C" target="_blank" rel="external">官方API文档</a></li>
<li><a href="http://www.pkuwwt.tk/d3-tutorial-cn/about.html" target="_blank" rel="external">pkuwwt的D3教程</a></li>
<li><a href="http://blog.csdn.net/zhang__tianxu/article/category/1623437" target="_blank" rel="external">张天旭的D3教程</a></li>
<li><a href="http://www.cnblogs.com/winleisure/tag/D3.js/" target="_blank" rel="external">楚狂人的D3教程</a></li>
<li><a href="http://www.ourd3js.com/wordpress/?cat=2" target="_blank" rel="external">D3.js 入门系列</a> (还有进阶、高级等系列)</li>
</ul>
</li>
<li><a href="http://www.ituring.com.cn/minibook/950" target="_blank" rel="external">Chrome扩展及应用开发</a></li>
</ul>
<h3 id="LaTeX">LaTeX</h3><ul>
<li><a href="http://www.dralpha.com/zh/tech/tech.htm" target="_blank" rel="external">LaTeX 笔记</a></li>
<li><a href="http://ctan.org/pkg/lshort-zh-cn" target="_blank" rel="external">一份不太简短的 LaTeX2ε 介绍</a></li>
<li><a href="http://web.math.isu.edu.tw/yeh/HowTo/HowToTex/latex123.pdf" target="_blank" rel="external">大家來學 LaTeX</a> (PDF)</li>
</ul>
<h3 id="LISP">LISP</h3><ul>
<li><a href="http://acl.readthedocs.org/en/latest/" target="_blank" rel="external">ANSI Common Lisp 中文翻译版</a></li>
<li><a href="http://www.ituring.com.cn/minibook/862" target="_blank" rel="external">Common Lisp 高级编程技术</a> (《On Lisp》中文版)</li>
</ul>
<h3 id="Lua">Lua</h3><ul>
<li><a href="http://www.w3cschool.cc/manual/lua53doc/contents.html" target="_blank" rel="external">Lua 5.3 参考手册</a></li>
</ul>
<h3 id="Markdown">Markdown</h3><ul>
<li><a href="http://wowubuntu.com/markdown/basic.html" target="_blank" rel="external">Markdown 快速入门</a></li>
<li><a href="http://jianshu.io/p/7bd23251da0a" target="_blank" rel="external">Markdown 简明教程</a></li>
<li><a href="http://wowubuntu.com/markdown/" target="_blank" rel="external">Markdown 语法说明</a></li>
<li><a href="http://jianshu.io/p/q81RER" target="_blank" rel="external">献给写作者的 Markdown 新手指南</a></li>
</ul>
<h3 id="Node-js">Node.js</h3><ul>
<li><a href="http://www.nodebeginner.org/index-zh-cn.html" target="_blank" rel="external">Node 入门</a></li>
<li><a href="https://www.gitbook.com/book/0532/nodejs/details" target="_blank" rel="external">The NodeJS 中文文档</a>（社区翻译）</li>
<li><a href="http://nqdeng.github.io/7-days-nodejs/" target="_blank" rel="external">七天学会NodeJS</a> 阿里出品，很好的入门资料</li>
</ul>
<h3 id="Perl">Perl</h3><ul>
<li><a href="https://github.com/fayland/chinese-perl-book" target="_blank" rel="external">Master Perl Today</a></li>
<li><a href="http://www.cbi.pku.edu.cn/chinese/documents/perl/index.htm" target="_blank" rel="external">Perl 5 教程</a></li>
<li><a href="http://www.yiibai.com/perl" target="_blank" rel="external">Perl 教程</a></li>
<li><a href="https://github.com/horus/modern_perl_book" target="_blank" rel="external">《Modern Perl》中文版</a></li>
</ul>
<h3 id="PHP">PHP</h3><ul>
<li><a href="http://www.php-internals.com/book/" target="_blank" rel="external">深入理解 PHP 内核</a></li>
<li><a href="http://php.net/manual/zh/" target="_blank" rel="external">PHP5中文手册</a></li>
<li><a href="http://www.walu.cc/phpbook/preface.md" target="_blank" rel="external">PHP扩展开发及内核应用</a></li>
<li><a href="http://wusuopu.gitbooks.io/symfony2_tutorial/content" target="_blank" rel="external">Symfony2 实例教程</a></li>
<li><a href="http://wulijun.github.io/php-the-right-way/" target="_blank" rel="external">PHP 之道</a></li>
</ul>
<h3 id="Python">Python</h3><ul>
<li><a href="http://djangobook.py3k.cn/2.0/" target="_blank" rel="external">Django book 2.0</a></li>
<li><a href="http://docspy3zh.readthedocs.org/en/latest/" target="_blank" rel="external">Python 3 文档(简体中文) 3.2.2 documentation</a></li>
<li><a href="http://www.pythondoc.com" target="_blank" rel="external">Python 中文学习大本营</a></li>
<li><a href="http://woodpecker.org.cn/diveintopython/" target="_blank" rel="external">深入 Python</a></li>
<li><a href="http://woodpecker.org.cn/diveintopython3/" target="_blank" rel="external">深入 Python 3</a></li>
<li><a href="http://sebug.net/paper/books/LearnPythonTheHardWay/" target="_blank" rel="external">笨办法学 Python</a></li>
<li><a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/" target="_blank" rel="external">简明 Python 教程</a> (《A Byte of Python》中文版)</li>
</ul>
<h3 id="R">R</h3><ul>
<li><a href="http://cran.r-project.org/doc/contrib/Ding-R-intro_cn.pdf" target="_blank" rel="external">R 导论</a> (《An Introduction to R》中文版) (PDF)</li>
<li><a href="http://cran.r-project.org/doc/contrib/Liu-FAQ.pdf" target="_blank" rel="external">153分钟学会 R</a> (PDF)</li>
<li><a href="http://www.biosino.org/R/R-doc/files/R4beg_cn_2.0.pdf" target="_blank" rel="external">《R for beginners》中文版</a> (PDF)</li>
<li><a href="http://yanping.me/shiny-tutorial/" target="_blank" rel="external">用 R 构建 Shiny 应用程序</a> (《Building ‘Shiny’ Applications with R》中文版)</li>
<li><a href="http://cran.r-project.org/doc/contrib/Xu-Statistics_and_R.pdf" target="_blank" rel="external">统计学与 R 读书笔记</a> (PDF)</li>
</ul>
<h3 id="reStructuredText">reStructuredText</h3><ul>
<li><a href="http://www.pythondoc.com/sphinx/rest.html" target="_blank" rel="external">reStructuredText 入门</a></li>
<li><a href="http://jwch.sdut.edu.cn/book/rst.html" target="_blank" rel="external">reStructuredText 简明教程</a></li>
</ul>
<h3 id="Ruby">Ruby</h3><ul>
<li><a href="https://github.com/JuanitoFatas/rails-style-guide/blob/master/README-zhCN.md" target="_blank" rel="external">Rails 风格指南</a></li>
<li><a href="http://railstutorial-china.org" target="_blank" rel="external">Ruby on Rails Tutorial 原书第 2 版</a></li>
<li><a href="http://ihower.tw/rails4/" target="_blank" rel="external">Ruby on Rails 实战圣经</a></li>
<li><a href="https://github.com/JuanitoFatas/ruby-style-guide/blob/master/README-zhCN.md" target="_blank" rel="external">Ruby 风格指南</a></li>
<li><a href="http://lrthw.github.io" target="_blank" rel="external">笨方法学 Ruby</a></li>
</ul>
<h3 id="Scala">Scala</h3><ul>
<li><a href="http://twitter.github.io/effectivescala/index-cn.html" target="_blank" rel="external">Effective Scala</a></li>
<li><a href="http://twitter.github.io/scala_school/zh_cn/index.html" target="_blank" rel="external">Scala 课堂</a> (Twitter的Scala中文教程)</li>
<li><a href="https://www.gitbook.com/book/windor/beginners-guide-to-scala/details" target="_blank" rel="external">Scala 初学者指南</a> (The Neophyte’s Guide to Scala)</li>
</ul>
<h3 id="Scheme">Scheme</h3><ul>
<li><a href="http://deathking.github.io/yast-cn/" target="_blank" rel="external">Scheme 入门教程</a> (《Yet Another Scheme Tutorial》中文版)</li>
<li><a href="http://r6rs.mrliu.org" target="_blank" rel="external">算法语言Scheme修订<sup>6</sup>报告</a>（R<sup>6</sup>RS简体中文翻译）</li>
</ul>
<h3 id="Shell">Shell</h3><ul>
<li><a href="http://wiki.ubuntu.org.cn/Shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80" target="_blank" rel="external">Shell 编程基础</a></li>
<li><a href="https://github.com/qinjx/30min_guides/blob/master/shell.md" target="_blank" rel="external">Shell 脚本编程30分钟入门</a></li>
<li><a href="http://billie66.github.io/TLCL/book/zh" target="_blank" rel="external">The Linux Command Line 中文版</a></li>
</ul>
<h3 id="Swift">Swift</h3><ul>
<li><a href="https://www.gitbook.io/book/numbbbbb/-the-swift-programming-language-" target="_blank" rel="external">《The Swift Programming Language》中文版</a></li>
</ul>
<h3 id="Vim">Vim</h3><ul>
<li><a href="http://www.study-area.org/tips/vim/index.html" target="_blank" rel="external">大家來學 VIM</a></li>
<li><a href="http://man.chinaunix.net/newsoft/vi/doc/help.html" target="_blank" rel="external">Vim Manual(中文版)</a></li>
</ul>
<h3 id="Visual_Prolog">Visual Prolog</h3><ul>
<li><a href="http://wiki.visual-prolog.com/index.php?title=A_Beginners_Guide_to_Visual_Prolog_in_Chinese" target="_blank" rel="external">Visual Prolog 7初学指南</a></li>
<li><a href="http://wiki.visual-prolog.com/index.php?title=Visual_Prolog_for_Tyros_in_Chinese" target="_blank" rel="external">Visual Prolog 7边练边学</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[免费编程书籍]]>
    
    </summary>
    
      <category term="books" scheme="http://miclee.cn/tags/books/"/>
    
      <category term="blog" scheme="http://miclee.cn/categories/blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA的23种设计模式(三)]]></title>
    <link href="http://miclee.cn/2015/08/27/java-design-pattern-3/"/>
    <id>http://miclee.cn/2015/08/27/java-design-pattern-3/</id>
    <published>2015-08-27T09:18:22.000Z</published>
    <updated>2016-04-07T03:45:14.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> 行为型模式 11种 </em></strong><br><a id="more"></a></p>
<hr>
<p>  本章是关于设计模式的最后一讲，会讲到第三种设计模式——行为型模式，共11种，这11种模式的关系：</p>
<ul>
<li><p>第一类：通过父类与子类的关系进行实现</p>
<ul>
<li>策略模式</li>
<li>模板方法模式</li>
</ul>
</li>
<li><p>第二类：两个类之间</p>
<ul>
<li>观察者模式</li>
<li>迭代子模式</li>
<li>责任链模式</li>
<li>命令模式</li>
</ul>
</li>
<li><p>第三类：类的状态</p>
<ul>
<li>备忘录模式</li>
<li>状态模式</li>
</ul>
</li>
<li><p>第四类：通过中间类</p>
<ul>
<li>访问者模式</li>
<li>中介者模式</li>
<li>解释器模式</li>
</ul>
</li>
</ul>
<ol>
<li><p>策略模式（strategy）<br>策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。<br>需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口。<br>策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种算法做封装。因此，策略模式多用在算法决策系统中，外部用户只需要决定用哪个算法即可。<br>其实本质就是定义个接口，并提供不同的实现。</p>
</li>
<li><p>模板方法模式（Template Method）<br>模板方法模式就是指：一个抽象类中，有一个主方法，再定义1…n个方法，可以是抽象的，也可以是实际的方法。<br>定义一个类，继承该抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用</p>
</li>
<li><p>观察者模式（Observer）<br>包括这个模式在内的接下来的四个模式，都是类和类之间的关系，不涉及到继承。<br>观察者模式很好理解，类似于邮件订阅和RSS订阅，当我们浏览一些博客或wiki时，经常会看到RSS图标，就这的意思是，当你订阅了该文章，如果后续有更新，会及时通知你。其实，简单来讲就一句话：当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系。</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[行为型模式 11种]]>
    
    </summary>
    
      <category term="java" scheme="http://miclee.cn/tags/java/"/>
    
      <category term="java" scheme="http://miclee.cn/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA的23种设计模式(二)]]></title>
    <link href="http://miclee.cn/2015/08/27/java-design-pattern-2/"/>
    <id>http://miclee.cn/2015/08/27/java-design-pattern-2/</id>
    <published>2015-08-27T09:18:22.000Z</published>
    <updated>2016-04-07T03:45:14.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> 结构型模式 七种 </em></strong><br><a id="more"></a></p>
<hr>
<pre><code>在JAVA的<span class="number">23</span>种设计模式(一)中讲了<span class="number">5</span>种创建型模式，这篇讲以下<span class="number">7</span>种结构型模式：适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
</code></pre><p>其中对象的适配器模式是各种模式的起源，我们看下面的图：  <img src="https://raw.githubusercontent.com/OfMicLee/img-hosting/master/java/java-design-2.png" alt="结构型模式"></p>
<ol>
<li><p>适配器模式（Adapter）</p>
<p>适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。</p>
<ul>
<li>类的适配器模式</li>
</ul>
<p>核心思想就是：有一个Source类，拥有一个方法，待适配，目标接口时Targetable，通过Adapter类，将Source的功能扩展到Targetable里</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Source类，拥有一个方法，待适配</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> </span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      System.out.println(<span class="string">"this is original method!"</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//目标接口 Targetable，即期望拥有的功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Targetable</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* 与原类中的方法相同 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">/* 新类的方法 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adapter类继承Source类，实现Targetable接口，这样Targetable接口的实现类就具有了Source类的功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Source</span> <span class="keyword">implements</span> <span class="title">Targetable</span> </span>&#123;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"this is the targetable method!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对象的适配器模式  </li>
</ul>
<p>基本思路和类的适配器模式相同，只是将Adapter类作修改，这次不继承Source类，而是持有Source类的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> <span class="keyword">implements</span> <span class="title">Targetable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Source source;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Wrapper</span><span class="params">(Source source)</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.source = source;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"this is the targetable method!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		source.method1();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接口的适配器模式（<strong>常用</strong>）</li>
</ul>
<p>这种模式比较常见，就是在接口和实现类之间增加一个抽象类来实现公共部分功能，子类继承抽象类，只需要实现抽象类里未实现的接口方法即可。</p>
</li>
<li><p>装饰模式</p>
<p>顾名思义，装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sourceable</span> </span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> <span class="keyword">implements</span> <span class="title">Sourceable</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"the original method!"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Sourceable</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Sourceable source;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Sourceable source)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>();  </span><br><span class="line">        <span class="keyword">this</span>.source = source;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"before decorator!"</span>);  </span><br><span class="line">        source.method();  </span><br><span class="line">        System.out.println(<span class="string">"after decorator!"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>应用场景：<ul>
<li>需要扩展一个类的功能。</li>
<li>动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。）</li>
</ul>
</li>
<li>缺点：产生过多相似的对象，不易排错！</li>
</ul>
</li>
<li><p>代理模式（Proxy）</p>
<p>其实每个模式名称就表明了该模式的作用，代理模式就是多一个代理类出来，替原对象进行一些操作。<br>代理模式和装饰的区别在于：<br>装饰模式是将功能类实例化出来后交给装饰类去补充功能；<br>代理模式是在代理类内部去实例化功能类，调用者不用关心功能类，完全交给代理类；<br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Sourceable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Source source;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.source = <span class="keyword">new</span> Source();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"before proxy!"</span>);</span><br><span class="line">		source.method();</span><br><span class="line">    System.out.println(<span class="string">"after proxy!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>外观模式（Facade）</p>
<p>外观模式是为了解决类与类之家的依赖关系的，像spring一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口，看下类图：（我们以一个计算机的启动过程为例）<br><img src="https://raw.githubusercontent.com/OfMicLee/img-hosting/master/java/java-design-facade.png" alt="外观模式"></p>
<p>如果我们没有Computer类，那么，CPU、Memory、Disk他们之间将会相互持有实例，产生关系，这样会造成严重的依赖，修改一个类，可能会带来其他类的修改，这不是我们想要看到的，有了Computer类，他们之间的关系被放在了Computer类里，这样就起到了解耦的作用，这，就是外观模式。</p>
</li>
</ol>
<p>10、桥接模式（Bridge）</p>
<p>  桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与实现化解耦，使得二者可以独立变化，像我们常用的JDBC桥DriverManager一样，JDBC进行连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动，原因就是JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了。<br>  如下：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Bridge bridge = <span class="keyword">new</span> MyBridge();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*调用第一个对象*/</span></span><br><span class="line">		Sourceable source1 = <span class="keyword">new</span> SourceSub1();</span><br><span class="line">		bridge.setSource(source1);</span><br><span class="line">		bridge.method();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*调用第二个对象*/</span></span><br><span class="line">		Sourceable source2 = <span class="keyword">new</span> SourceSub2();</span><br><span class="line">		bridge.setSource(source2);</span><br><span class="line">		bridge.method();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这样，就通过对Bridge类的调用，实现了对接口Sourceable的实现类SourceSub1和SourceSub2的调用。</p>
<ol>
<li><p>组合模式（Composite）</p>
<p>组合模式有时又叫部分-整体模式在处理类似树形结构的问题时比较方便，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> TreeNode parent;</span><br><span class="line">	<span class="keyword">private</span> Vector&lt;TreeNode&gt; children = <span class="keyword">new</span> Vector&lt;TreeNode&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">getParent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> parent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParent</span><span class="params">(TreeNode parent)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.parent = parent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//添加孩子节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">		children.add(node);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除孩子节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">		children.remove(node);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//取得孩子节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Enumeration&lt;TreeNode&gt; <span class="title">getChildren</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> children.elements();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span> </span>&#123;</span><br><span class="line">	TreeNode root = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Tree</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		root = <span class="keyword">new</span> TreeNode(name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Tree tree = <span class="keyword">new</span> Tree(<span class="string">"A"</span>);</span><br><span class="line">		TreeNode nodeB = <span class="keyword">new</span> TreeNode(<span class="string">"B"</span>);</span><br><span class="line">		TreeNode nodeC = <span class="keyword">new</span> TreeNode(<span class="string">"C"</span>);</span><br><span class="line"></span><br><span class="line">		nodeB.add(nodeC);</span><br><span class="line">		tree.root.add(nodeB);</span><br><span class="line">		System.out.println(<span class="string">"build the tree finished!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用场景：将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树，数等。</p>
</li>
<li><p>享元模式（Flyweight）</p>
<p>享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。<br>最典型的使用场景：数据库连接池的实现。</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[结构型模式 七种]]>
    
    </summary>
    
      <category term="java" scheme="http://miclee.cn/tags/java/"/>
    
      <category term="java" scheme="http://miclee.cn/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA的23种设计模式(一)]]></title>
    <link href="http://miclee.cn/2015/08/27/java-design-pattern-1/"/>
    <id>http://miclee.cn/2015/08/27/java-design-pattern-1/</id>
    <published>2015-08-27T09:18:22.000Z</published>
    <updated>2016-04-07T03:45:14.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em> 创建型模式 五种 </em></strong><br><a id="more"></a></p>
<hr>
<p><strong>设计模式（Design pattern）</strong> 是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。</p>
<h2 id="设计模式的分类">设计模式的分类</h2><ul>
<li><p>创建型模式 五种</p>
<ul>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
<li>单例模式</li>
<li>建造者模式</li>
<li>原型模式</li>
</ul>
</li>
<li><p>结构型模式 七种</p>
<ul>
<li>适配器模式</li>
<li>装饰器模式</li>
<li>代理模式</li>
<li>外观模式</li>
<li>桥接模式</li>
<li>组合模式</li>
<li>享元模式</li>
</ul>
</li>
<li><p>行为型模式 十一种</p>
<ul>
<li>策略模式</li>
<li>模板方法模式</li>
<li>观察者模式</li>
<li>迭代子模式</li>
<li>责任链模式</li>
<li>命令模式</li>
<li>备忘录模式</li>
<li>状态模式</li>
<li>访问者模式</li>
<li>中介者模式</li>
<li>解释器模式</li>
</ul>
</li>
<li><p>其实还有两类：并发型模式和线程池模式</p>
</li>
</ul>
<p><strong><em> 用一张图来表示下设计模式之间的关系：</em></strong> <img src="https://raw.githubusercontent.com/OfMicLee/img-hosting/master/java/java-design.png" alt="java-design"></p>
<h2 id="设计模式的六大原则">设计模式的六大原则</h2><ol>
<li><p>开闭原则（Open Close Principle）</p>
<p>开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类</p>
</li>
<li><p>里氏替换原则（Liskov Substitution Principle）</p>
<p>任何基类可以出现的地方，子类一定可以出现。<br>里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
</li>
<li><p>依赖倒转原则（Dependence Inversion Principle）</p>
<p>这个是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p>
</li>
<li><p>接口隔离原则（Interface Segregation Principle）</p>
<p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</p>
</li>
<li><p>迪米特原则（最少知道原则）（Demeter Principle）</p>
<p>为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
</li>
<li><p>合成复用原则（Composite Reuse Principle）</p>
<p>原则是尽量使用合成/聚合的方式，而不是使用继承。</p>
</li>
</ol>
<h2 id="Java的23中设计模式">Java的23中设计模式</h2><ol>
<li><p>工厂方法模式（Factory Method）</p>
<ul>
<li><p>普通工厂模式</p>
<p>就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。</p>
</li>
<li><p>多个工厂方法模式</p>
<p>多个工厂方法模式是在一个工厂类里提供多个工厂方法，分别创建不同的对象</p>
</li>
<li><p>静态工厂方法模式</p>
<p>创建实例对象的方法为static， 一般情况下会采用这种模式</p>
</li>
</ul>
</li>
<li><p>抽象工厂模式（Abstract Factory）</p>
<p>工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，<br>所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，<br>直接增加新的工厂类就可以了，不需要修改之前的代码。<br>简而言之，就是将原先的工厂类设计为Interface，实例不同对象用不同的工厂实例。</p>
</li>
<li><p>单例模式（Singleton）</p>
<p>单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。这样的模式有几个好处：</p>
<ul>
<li>某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。</li>
<li>省去了new操作符，降低了系统内存的使用频率，减轻GC压力。</li>
<li>有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。</li>
</ul>
</li>
<li><p>建造者模式（Builder）</p>
<p>工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> List&lt;Sender&gt; list = <span class="keyword">new</span> ArrayList&lt;Sender&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceMailSender</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; i++)&#123;</span><br><span class="line">			list.add(<span class="keyword">new</span> MailSender());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceSmsSender</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; i++)&#123;</span><br><span class="line">			list.add(<span class="keyword">new</span> SmsSender());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这点看出，建造者模式将很多功能集成到一个类里，这个类可以创造出比较复杂的东西。<br>所以与工厂模式的区别就是：工厂模式关注的是创建单个产品，而建造者模式则关注创建复合对象，多个部分。因此，是选择工厂模式还是建造者模式，依实际情况而定。</p>
</li>
<li><p>原型模式（Prototype）</p>
<p>原型模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。<br>在Java中，复制对象通过clone()实现。</p>
<ul>
<li>浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。</li>
<li>深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;  </span><br><span class="line">   <span class="keyword">private</span> String string;  </span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> SerializableObject obj;  </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 浅复制 */</span>  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;  </span><br><span class="line">       Prototype proto = (Prototype) <span class="keyword">super</span>.clone();  </span><br><span class="line">       <span class="keyword">return</span> proto;  </span><br><span class="line">   &#125;  </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 深复制 */</span>  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">deepClone</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;  </span><br><span class="line"></span><br><span class="line">       <span class="comment">/* 写入当前对象的二进制流 */</span>  </span><br><span class="line">       ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();  </span><br><span class="line">       ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);  </span><br><span class="line">       oos.writeObject(<span class="keyword">this</span>);  </span><br><span class="line"></span><br><span class="line">       <span class="comment">/* 读出二进制流产生的新对象 */</span>  </span><br><span class="line">       ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());  </span><br><span class="line">       ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis);  </span><br><span class="line">       <span class="keyword">return</span> ois.readObject();  </span><br><span class="line">   &#125;  </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">return</span> string;  </span><br><span class="line">   &#125;  </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setString</span><span class="params">(String string)</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">this</span>.string = string;  </span><br><span class="line">   &#125;  </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> SerializableObject <span class="title">getObj</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">return</span> obj;  </span><br><span class="line">   &#125;  </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(SerializableObject obj)</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">this</span>.obj = obj;  </span><br><span class="line">   &#125;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerializableObject</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>要实现深复制，需要采用流的形式读入当前对象的二进制输入，再写出二进制数据对应的对象</em></strong>  </p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[创建型模式 五种]]>
    
    </summary>
    
      <category term="java" scheme="http://miclee.cn/tags/java/"/>
    
      <category term="java" scheme="http://miclee.cn/categories/java/"/>
    
  </entry>
  
</feed>
